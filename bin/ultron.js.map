{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/delaunay-fast/delaunay.js","node_modules/eventemitter3/index.js","node_modules/request-frame/dist/request-frame.js","node_modules/vkey/index.js","src/game/game.js","src/game/index.js","src/game/state.js","src/game/statelist.js","src/game/statestack.js","src/geometry/gpc.js","src/geometry/grid/cell.js","src/geometry/grid/grid.js","src/geometry/grid/index.js","src/geometry/index.js","src/geometry/linesegment2.js","src/geometry/polygon2.js","src/geometry/quadtree/boundsnode.js","src/geometry/quadtree/index.js","src/geometry/quadtree/pointnode.js","src/geometry/quadtree/quadtree.js","src/geometry/regularpolygon2.js","src/geometry/triangle2.js","src/geometry/vector2.js","src/geometry/visibilitypolygon.js","src/src/index.js","src/input/index.js","src/input/mousewheel-polyfill.js","src/input/unified.js","src/linkedlist/doublylinkedlist.js","src/linkedlist/index.js","src/procedural/building.js","src/procedural/graph.js","src/procedural/index.js","src/timer/gameloop.js","src/timer/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3oGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACbA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;AACA;AACA;AACA","file":"ultron.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var Delaunay;\n\n(function() {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i, dx, dy, dmax, xmid, ymid;\n\n    for(i = vertices.length; i--; ) {\n      if(vertices[i][0] < xmin) xmin = vertices[i][0];\n      if(vertices[i][0] > xmax) xmax = vertices[i][0];\n      if(vertices[i][1] < ymin) ymin = vertices[i][1];\n      if(vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n\n    return [\n      [xmid - 20 * dmax, ymid -      dmax],\n      [xmid            , ymid + 20 * dmax],\n      [xmid + 20 * dmax, ymid -      dmax]\n    ];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;\n\n    /* Check for coincident points */\n    if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)\n      throw new Error(\"Eek! Coincident points!\");\n\n    if(fabsy1y2 < EPSILON) {\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (x2 + x1) / 2.0;\n      yc  = m2 * (xc - mx2) + my2;\n    }\n\n    else if(fabsy2y3 < EPSILON) {\n      m1  = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc  = (x3 + x2) / 2.0;\n      yc  = m1 * (xc - mx1) + my1;\n    }\n\n    else {\n      m1  = -((x2 - x1) / (y2 - y1));\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc  = (fabsy1y2 > fabsy2y3) ?\n        m1 * (xc - mx1) + my1 :\n        m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for(j = edges.length; j; ) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for(i = j; i; ) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if((a === m && b === n) || (a === n && b === m)) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function(vertices, key) {\n      var n = vertices.length,\n          i, j, indices, st, open, closed, edges, dx, dy, a, b, c;\n\n      /* Bail if there aren't enough vertices to form any triangles. */\n      if(n < 3)\n        return [];\n\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n      vertices = vertices.slice(0);\n\n      if(key)\n        for(i = n; i--; )\n          vertices[i] = vertices[i][key];\n\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n      indices = new Array(n);\n\n      for(i = n; i--; )\n        indices[i] = i;\n\n      indices.sort(function(i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      \n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n      open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges  = [];\n\n      /* Incrementally add each vertex to the mesh. */\n      for(i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n        for(j = open.length; j--; ) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n          if(dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n\n          /* If we're outside the circumcircle, skip this triangle. */\n          dy = vertices[c][1] - open[j].y;\n          if(dx * dx + dy * dy - open[j].r > EPSILON)\n            continue;\n\n          /* Remove the triangle and add it's edges to the edge list. */\n          edges.push(\n            open[j].i, open[j].j,\n            open[j].j, open[j].k,\n            open[j].k, open[j].i\n          );\n          open.splice(j, 1);\n        }\n\n        /* Remove any doubled edges. */\n        dedup(edges);\n\n        /* Add a new triangle for each edge. */\n        for(j = edges.length; j; ) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n      for(i = open.length; i--; )\n        closed.push(open[i]);\n      open.length = 0;\n\n      for(i = closed.length; i--; )\n        if(closed[i].i < n && closed[i].j < n && closed[i].k < n)\n          open.push(closed[i].i, closed[i].j, closed[i].k);\n\n      /* Yay, we're done! */\n      return open;\n    },\n    contains: function(tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||\n         (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||\n         (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||\n         (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))\n        return null;\n\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n\n      /* Degenerate tri. */\n      if(i === 0.0)\n        return null;\n\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n\n      /* If we're outside the tri, fail. */\n      if(u < 0.0 || v < 0.0 || (u + v) > 1.0)\n        return null;\n\n      return [u, v];\n    }\n  };\n\n  if(typeof module !== \"undefined\")\n    module.exports = Delaunay;\n})();\n","'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\n *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for\n *   optimal cross-browser development.\n *    Version:  v1.4.0\n *     License:  MIT\n *      Copyright Julien Etienne 2015 All Rights Reserved.\n *        github:  https://github.com/julienetie/request-frame\n *‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n */\n(function (window) {\n\n/**\n * @param  {String} type - request | cancel | native.\n * @return {Function} Timing function.\n */\nfunction requestFrame(type) {\n    // The only vendor prefixes required.\n    var vendors = ['moz', 'webkit'],\n\n        // Disassembled timing function abbreviations.\n        aF = 'AnimationFrame',\n        rqAF = 'Request' + aF,\n\n        // Final assigned functions.\n        assignedRequestAnimationFrame,\n        assignedCancelAnimationFrame,\n\n        // Initial time of the timing lapse.\n        previousTime = 0,\n\n        mozRAF = window.mozRequestAnimationFrame,\n        mozCAF = window.mozCancelAnimationFrame,\n\n        // Checks for firefox 4 - 10 function pair mismatch.\n        hasMozMismatch = mozRAF && !mozCAF,\n\n        func;\n\n    // Date.now polyfill, mainly for legacy IE versions.\n    if (!Date.now) {\n        Date.now = function() {\n            return new Date().getTime();\n        };\n    }\n\n    /**\n     * hasIOS6RequestAnimationFrameBug.\n     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}\n     * - for Commentary.\n     * @Copyright 2015 - Julien Etienne. \n     * @License: MIT.\n     */\n    function hasIOS6RequestAnimationFrameBug() {\n        var webkitRAF = window.webkitRequestAnimationFrame,\n            rAF = window.requestAnimationFrame,\n\n            // CSS/ Device with max for iOS6 Devices.\n            hasMobileDeviceWidth = screen.width <= 768 ? true : false,\n\n            // Only supports webkit prefixed requestAnimtionFrane.\n            requiresWebkitprefix = !(webkitRAF && rAF),\n\n            // iOS6 webkit browsers don't support performance now.\n            hasNoNavigationTiming = window.performance ? false : true,\n\n            iOS6Notice = 'setTimeout is being used as a substitiue for' +\n            'requestAnimationFrame due to a bug within iOS 6 builds',\n\n            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&\n            hasNoNavigationTiming;\n\n        function bugCheckresults(timingFnA, timingFnB, notice) {\n            if (timingFnA || timingFnB) {\n                console.warn(notice);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function displayResults() {\n            if (hasIOS6Bug) {\n                return bugCheckresults(webkitRAF, rAF, iOS6Notice);\n            } else {\n                return false;\n            }\n        }\n\n        return displayResults();\n    }\n\n    /**\n     * Native clearTimeout function.\n     * @return {Function}\n     */\n    function clearTimeoutWithId(id) {\n        clearTimeout(id);\n    }\n\n    /**\n     * Based on a polyfill by Erik, introduced by Paul Irish & \n     * further improved by Darius Bacon.\n     * @see  {@link http://www.paulirish.com/2011/\n     * requestanimationframe-for-smart-animating}\n     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/\n     * master/requestAnimationFrame.js}\n     * @callback {Number} Timestamp.\n     * @return {Function} setTimeout Function.\n     */\n    function setTimeoutWithTimestamp(callback) {\n        var immediateTime = Date.now(),\n            lapsedTime = Math.max(previousTime + 16, immediateTime);\n        return setTimeout(function() {\n                callback(previousTime = lapsedTime);\n            },\n            lapsedTime - immediateTime);\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the setTimeoutWithTimestamp function.\n     * @return {Function}\n     */\n    function queryRequestAnimationFrame() {\n        if (Array.prototype.filter) {\n            assignedRequestAnimationFrame = window['request' + aF] ||\n                window[vendors.filter(function(vendor) {\n                    if (window[vendor + rqAF] !== undefined)\n                        return vendor;\n                }) + rqAF] || setTimeoutWithTimestamp;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedRequestAnimationFrame;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the clearTimeoutWithId function.\n     * @return {Function}\n     */\n    function queryCancelAnimationFrame() {\n        var cancellationNames = [];\n        if (Array.prototype.map) {\n            vendors.map(function(vendor) {\n                return ['Cancel', 'CancelRequest'].map(\n                    function(cancellationNamePrefix) {\n                        cancellationNames.push(vendor +\n                            cancellationNamePrefix + aF);\n                    });\n            });\n        } else {\n            return clearTimeoutWithId;\n        }\n\n        /**\n         * Checks for the prefixed cancelAnimationFrame implementation.\n         * @param  {Array} prefixedNames - An array of the prefixed names. \n         * @param  {Number} i - Iteration start point.\n         * @return {Function} prefixed cancelAnimationFrame function.\n         */\n        function prefixedCancelAnimationFrame(prefixedNames, i) {\n            var cancellationFunction;\n            for (; i < prefixedNames.length; i++) {\n                if (window[prefixedNames[i]]) {\n                    cancellationFunction = window[prefixedNames[i]];\n                    break;\n                }\n            }\n            return cancellationFunction;\n        }\n\n        // Use truthly function\n        assignedCancelAnimationFrame = window['cancel' + aF] ||\n            prefixedCancelAnimationFrame(cancellationNames, 0) ||\n            clearTimeoutWithId;\n\n        // Check for iOS 6 bug\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedCancelAnimationFrame;\n        } else {\n            return clearTimeoutWithId;\n        }\n    }\n\n    function getRequestFn() {\n        if (hasMozMismatch) {\n            return setTimeoutWithTimestamp;\n        } else {\n            return queryRequestAnimationFrame();\n        }\n    }\n\n    function getCancelFn() {\n        return queryCancelAnimationFrame();\n    }\n\n    function setNativeFn() {\n        if (hasMozMismatch) {\n            window.requestAnimationFrame = setTimeoutWithTimestamp;\n            window.cancelAnimationFrame = clearTimeoutWithId;\n        } else {\n            window.requestAnimationFrame = queryRequestAnimationFrame();\n            window.cancelAnimationFrame = queryCancelAnimationFrame();\n        }\n    }\n\n    /**\n     * The type value \"request\" singles out firefox 4 - 10 and \n     * assigns the setTimeout function if plausible.\n     */\n\n    switch (type) {\n        case 'request':\n        case '':\n            func = getRequestFn();\n            break;\n\n        case 'cancel':\n            func = getCancelFn();\n            break;\n\n        case 'native':\n            setNativeFn();\n            break;\n        default:\n            throw new Error('RequestFrame parameter is not a type.');\n    }\n    return func;\n}\n\n\n// Node.js/ CommonJS\nif (typeof module === 'object' && typeof module.exports === 'object') {\nmodule.exports = exports = requestFrame;\n}\n\n// AMD\nelse if (typeof define === 'function' && define.amd) {\ndefine(function() {\n  return requestFrame;\n});\n}\n\n// Default to window as global\nelse if (typeof window === 'object') {\nwindow.requestFrame = requestFrame;\n}\n/* global -module, -exports, -define */\n\n}((typeof window === \"undefined\" ? {} : window)));\n","var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n","'use strict';\n\nvar StateStack = require('./statestack');\nvar GameLoop = require('../timer/gameloop');\nvar NOOP = function() {};\n\nexports = module.exports = Game;\n\nfunction Game () {\n  this.states = {};\n  this.statestack = new StateStack();\n  this.gameloop = new GameLoop();\n\n  var self = this;\n\n  this.gameloop.setBegin(\n    function(timestamp, frameDelta) {\n      self.begin(timestamp, frameDelta);\n      self.statestack.begin(timestamp, frameDelta);\n    }\n  );\n\n  this.gameloop.setUpdate(\n    function(simulationTimestep) {\n      self.update(simulationTimestep);\n      self.statestack.update(simulationTimestep);\n    }\n  );\n\n  this.gameloop.setRender(\n    function(percentageTimestepRemaining) {\n      self.render(percentageTimestepRemaining);\n      self.statestack.render(percentageTimestepRemaining);\n    }\n  );\n\n  this.gameloop.setEnd(\n    function(fps, panic) {\n      self.end(fps. panic);\n      self.statestack.end(fps, panic);\n    }\n  );\n\n}\n\n/* GAMELOOP HANDLING */\n\nGame.prototype.start = function() {\n  return this.gameloop.start();\n};\n\nGame.prototype.stop = function() {\n  return this.gameloop.stop();\n};\n\nGame.prototype.begin = NOOP;\nGame.prototype.end = NOOP;\nGame.prototype.update = NOOP;\nGame.prototype.render = NOOP;\n\n\n\n/* STATE HANDLING */\n\nGame.prototype.addState = function(state) {\n  state.game = this;\n  this.states[state.name] = state;\n  return this;\n};\n\nGame.prototype.startState = function (stateName) {\n  var state = this.states[stateName];\n  if (!state) {\n    return;\n  }\n  return this.statestack.push(this.states[stateName]);\n};\n\nGame.prototype.stopState = function (stateName) {\n  var state = this.states[stateName];\n  if (!state) {\n    return;\n  }\n  return this.statestack.pop(state);\n};\n","module.exports = {\n  Game: require('./game'),\n  State: require('./state'),\n  StateList: require('./statelist'),\n  StateStack: require('./statestack')\n};\n","'use strict';\n\nexports = module.exports = State;\n\nvar NOOP = function() {};\n\nfunction State ( name ) {\n    this.name = name;\n}\n\nState.prototype.begin = NOOP;\nState.prototype.update = NOOP;\nState.prototype.render = NOOP;\nState.prototype.end = NOOP;\nState.prototype.onEnter = NOOP;\nState.prototype.onExit = NOOP;\n","'use strict';\n\nexports = module.exports = StateList;\n\nfunction StateList() {\n    this.states = [];\n}\n\nStateList.prototype.pop = function () {\n    return this.states.pop();\n};\n\nStateList.prototype.push = function ( state ) {\n    return this.states.push(state);\n};\n\nStateList.prototype.top = function (depth) {\n    depth = depth || 0;\n    return this.states[this.states.length-(depth+1)];\n};\n","'use strict';\n\nvar StateList = require('./statelist');\n\nexports = module.exports = StateStack;\n\nfunction StateStack() {\n    this.states = new StateList();\n}\n\nStateStack.prototype.begin = function (timestamp, frameDelta) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.begin(timestamp, frameDelta) ) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.update = function (simulationTimestep) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.update(simulationTimestep)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.render = function (percentageTimestepRemaining) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.render(percentageTimestepRemaining)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.end = function (fps, panic) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.end(fps, panic)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.pop = function () {\n    var state = this.states.pop();\n    state.onExit();\n    return state;\n};\n\nStateStack.prototype.push = function (state) {\n    this.states.push(state);\n    return state.onEnter();\n};\n","'use strict';\n\nvar gpcas = gpcas || {};\ngpcas.util = {};\ngpcas.geometry = {};\n\nexports = module.exports = gpcas;\n\n//////////\nvar Clip, BundleState, LmtNode, TopPolygonNode, AetTree, HState, VertexType, VertexNode, ItNodeTable, StNode;\n\n//Object.prototype.equals = function(x) {\nfunction equals(x1, x) {\n\n    var p;\n    for(p in x1) {\n        if(typeof(x[p])==='undefined') {return false;}\n    }\n\n    for(p in x1) {\n        if (x1[p]) {\n            switch(typeof(x1[p])) {\n                case 'object':\n                    if (!equals(x1[p], x[p])) { return false; } break;\n                case 'function':\n                    if (typeof(x[p])==='undefined' ||\n                        (p !== 'equals' && x1[p].toString() !== x[p].toString()))\n                        return false;\n                    break;\n                default:\n                    if (x1[p] !== x[p]) { return false; }\n            }\n        } else {\n            if (x[p])\n                return false;\n        }\n    }\n\n    for(p in x) {\n        if(typeof(x1[p])==='undefined') {return false;}\n    }\n\n    return true;\n}\n///point\nvar Point = function(x,y) {\n    this.x = x;\n    this.y = y;\n};\ngpcas.geometry.Point = Point;\n\n////////////// CLASS ArrayHelper ////////////////////////////////////\ngpcas.util.ArrayHelper = function() {};\nvar gpcstatic = gpcas.util.ArrayHelper;\n\ngpcstatic.create2DArray = function(x,y){\n    var a = [];\n    for (var i=0; i<x; i++){\n        a[i]= [];\n    }\n    return a;\n};\ngpcstatic.valueEqual = function(obj1, obj2) {\n    if (obj1===obj2) return true;\n    if(equals(obj1, obj2)) return true;\n\n    return false;\n}\ngpcstatic.sortPointsClockwise = function(vertices) {\n    var isArrayList  = false;\n\n    if (vertices instanceof gpcas.util.ArrayList){\n        vertices= vertices.toArray();\n        isArrayList=true;\n    }\n\n    //point\n    var maxTop   = null;\n    var maxBottom  = null;\n    var maxLeft   = null;\n    var maxRight  = null;\n\n\n    var maxLeftIndex;\n    var newVertices = vertices;\n\n\n\n    for (var i  = 0; i<vertices.length; i++){\n        var vertex  = vertices[i] ;\n\n        if ((maxTop===null)||(maxTop.y>vertex.y)||((maxTop.y===vertex.y)&&(vertex.x<maxTop.x))){\n            maxTop=vertex;\n        }\n        if ((maxBottom===null)||(maxBottom.y<vertex.y)||((maxBottom.y===vertex.y)&&(vertex.x>maxBottom.x))){\n            maxBottom=vertex;\n        }\n        if ((maxLeft===null)||(maxLeft.x>vertex.x)||((maxLeft.x===vertex.x)&&(vertex.y>maxLeft.y))){\n            maxLeft=vertex;\n            maxLeftIndex=i;\n        }\n        if ((maxRight===null)||(maxRight.x<vertex.x)||((maxRight.x===vertex.x)&&(vertex.y<maxRight.y))){\n            maxRight=vertex;\n        }\n    }\n\n    if (maxLeftIndex>0){\n        newVertices = []\n        var j = 0;\n        for (var i=maxLeftIndex; i<vertices.length;i++){\n            newVertices[j++]=vertices[i];\n        }\n        for (var i=0; i<maxLeftIndex; i++){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n\n    var reverse  = false;\n    for(var i=0 ; i<vertices.length;i++) {\n        var vertex = vertices[i];\n        if (equals(vertex, maxBottom)){\n            reverse=true;\n            break;\n        } else if (equals(vertex, maxTop)){\n            break;\n        }\n    }\n    if (reverse){\n        newVertices=[]\n        newVertices[0]=vertices[0];\n        var j =1;\n        for (var i=vertices.length-1; i>0; i--){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n    return (isArrayList?(new gpcas.util.ArrayList(vertices)):(vertices));\n}\n\n/////////////// END ArrayHelper  ////////////////////////////////////////////////\n\nvar ArrayHelper = gpcas.util.ArrayHelper;\n////////////////// CLASS ArrayList  /////////////////////////\n\ngpcas.util.ArrayList = function(arr) {\n\tthis._array = [];\n\tif(arr != null) {\n\t\tthis._array=arr;\n\t}\n\n};\nvar p = gpcas.util.ArrayList.prototype;\n\np.add = function(value) {\n    this._array.push(value);\n};\np.get = function(index) {\n    return this._array[index];\n};\np.size = function() {\n\treturn this._array.length;\n};\np.clear = function() {\n    this._array  = [];\n\n};\np.equals = function(list) {\n    if (this._array.length != list.size()) return false;\n\n    for (var i = 0; i<this._array.length ; i++){\n        var obj1  = this._array[i];\n        var obj2  = list.get(i);\n\n        if (!ArrayHelper.valueEqual(obj1,obj2)){\n            return false;\n        }\n    }\n    return true;\n}\np.hashCode = function(){\n    return 0;\n};\np.isEmpty = function() {\n    return (this._array.length == 0);\n}\np.toArray = function(){\n    return this._array;\n}\n///////////////// END ArrayList ////////////////////////\n\n\n\n\n\n\ngpcas.geometry.Clip = function(){};\ngpcas.geometry.Clip.DEBUG = false;\ngpcas.geometry.Clip.GPC_EPSILON = 2.2204460492503131e-016;\ngpcas.geometry.Clip.GPC_VERSION = \"2.31\";\ngpcas.geometry.Clip.LEFT = 0;\ngpcas.geometry.Clip.RIGHT = 1;\ngpcas.geometry.Clip.ABOVE = 0;\ngpcas.geometry.Clip.BELOW = 1;\ngpcas.geometry.Clip.CLIP = 0;\ngpcas.geometry.Clip.SUBJ = 1;\nClip = gpcas.geometry.Clip;\n\n\n\nvar p = gpcas.geometry.Clip.prototype;\nvar gpcstatic = gpcas.geometry.Clip;\n\n// ----------------------\n// --- gpcstatic Methods ---\n// ----------------------\n\n/**\n * Return the intersection of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he intersection with\n * @param p2        One of the polygons to performt he intersection with\n * @param polyClass The type of <code>Poly</code> to return\n */\n\ngpcstatic.intersection = function(p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_INT, p1, p2, polyClass );\n};\n\n\n\n/**\n * Return the union of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he union with\n * @param p2        One of the polygons to performt he union with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.union = function(p1, p2, polyClass) {\n\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n\n\treturn gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_UNION, p1, p2, polyClass );\n};\n\n\n/**\n * Return the xor of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he xor with\n * @param p2        One of the polygons to performt he xor with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.xor = function( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_XOR, p1, p2, polyClass );\n};\n\n\n/**\n * Return the difference of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        Polygon from which second polygon will be substracted\n * @param p2        Second polygon\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.difference = function ( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_DIFF, p2, p1, polyClass );\n}\ngpcstatic.intersection = function( p1, p2) {\n\treturn gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, \"PolyDefault.class\" );\n}\n\n\n// -----------------------\n// --- Private Methods ---\n// -----------------------\n\n/**\n * Create a new <code>Poly</code> type object using <code>polyClass</code>.\n */\ngpcstatic.createNewPoly = function ( polyClass) {\n    /* TODO :\n     try\n     {\n     return (Poly)polyClass.newInstance();\n     }\n     catch( var e:Exception)\n     {\n     throw new RuntimeException(e);\n     }*/\n    if (polyClass==\"PolySimple\"){\n        return new gpcas.geometry.PolySimple();\n    }\n    if (polyClass==\"PolyDefault\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\tif (polyClass==\"PolyDefault.class\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\n    return null;\n}\n\n/**\n * <code>clip()</code> is the main method of the clipper algorithm.\n * This is where the conversion from really begins.\n */\ngpcstatic.clip = function ( op, subj, clip, polyClass) {\n    var result = gpcas.geometry.Clip.createNewPoly( polyClass ) ;\n\n    /* Test for trivial NULL result cases */\n    if( (subj.isEmpty() && clip.isEmpty()) ||\n        (subj.isEmpty() && ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF))) ||\n        (clip.isEmpty() &&  (op == gpcas.geometry.OperationType.GPC_INT)) )\n    {\n        return result ;\n    }\n\n\n\n    /* Identify potentialy contributing contours */\n    if( ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF)) &&\n        !subj.isEmpty() && !clip.isEmpty() )\n    {\n        gpcas.geometry.Clip.minimax_test(subj, clip, op);\n    }\n\n\t//console.log(\"SUBJ \" + subj);\n    //console.log(\"CLIP \" + clip);\n\n\n\n    /* Build LMT */\n    var lmt_table = new gpcas.geometry.LmtTable();\n    var sbte = new gpcas.geometry.ScanBeamTreeEntries();\n    var s_heap= null ;\n    var c_heap= null ;\n\n\n\n    if (!subj.isEmpty())\n    {\n        s_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, subj, gpcas.geometry.Clip.SUBJ, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for subj ---------\");\n        lmt_table.print();\n    }\n    if (!clip.isEmpty())\n    {\n        c_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, clip, gpcas.geometry.Clip.CLIP, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for clip ---------\");\n        lmt_table.print();\n    }\n\n    /* Return a NULL result if no contours contribute */\n    if (lmt_table.top_node == null)\n    {\n        return result;\n    }\n\n    /* Build scanbeam table from scanbeam tree */\n    var sbt = sbte.build_sbt();\n\n\n\n    var parity= [];\n    parity[0] = gpcas.geometry.Clip.LEFT ;\n    parity[1] = gpcas.geometry.Clip.LEFT ;\n\n    /* Invert clip polygon for difference operation */\n    if (op == gpcas.geometry.OperationType.GPC_DIFF)\n    {\n        parity[Clip.CLIP]= gpcas.geometry.Clip.RIGHT;\n    }\n\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(sbt);\n    }\n\n    var local_min = lmt_table.top_node ;\n\n    var out_poly = new TopPolygonNode(); // used to create resulting Poly\n\n    var aet = new AetTree();\n    var scanbeam = 0;\n\n\n\n    /* Process each scanbeam */\n    while( scanbeam < sbt.length )\n    {\n        /* Set yb and yt to the bottom and top of the scanbeam */\n        var yb = sbt[scanbeam++];\n        var yt = 0.0;\n        var dy = 0.0;\n        if( scanbeam < sbt.length )\n        {\n            yt = sbt[scanbeam];\n            dy = yt - yb;\n        }\n\n\n\n        /* === SCANBEAM BOUNDARY PROCESSING ================================ */\n\n        /* If LMT node corresponding to yb exists */\n        if (local_min != null )\n        {\n            if (local_min.y == yb)\n            {\n                /* Add edges starting at this local minimum to the AET */\n                for( var edge= local_min.first_bound; (edge != null) ; edge= edge.next_bound)\n                {\n                    gpcas.geometry.Clip.add_edge_to_aet( aet, edge );\n                }\n\n                local_min = local_min.next;\n            }\n        }\n\n        if( gpcas.geometry.Clip.DEBUG )\n        {\n            aet.print();\n        }\n        /* Set dummy previous x value */\n        var px = -Number.MAX_VALUE;\n\n        /* Create bundles within AET */\n        var e0 = aet.top_node ;\n        var e1 = aet.top_node ;\n\n\n\n        /* Set up bundle fields of first edge */\n        aet.top_node.bundle[Clip.ABOVE][ aet.top_node.type ] = (aet.top_node.top.y != yb) ? 1: 0;\n        aet.top_node.bundle[Clip.ABOVE][ ((aet.top_node.type==0) ? 1: 0) ] = 0;\n        aet.top_node.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n        for (var next_edge= aet.top_node.next ; (next_edge != null); next_edge = next_edge.next)\n        {\n            var ne_type= next_edge.type ;\n            var ne_type_opp= ((next_edge.type==0) ? 1: 0); //next edge type opposite\n\n            /* Set up bundle fields of next edge */\n            next_edge.bundle[Clip.ABOVE][ ne_type     ]= (next_edge.top.y != yb) ? 1: 0;\n            next_edge.bundle[Clip.ABOVE][ ne_type_opp ] = 0;\n            next_edge.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n            /* Bundle edges above the scanbeam boundary if they coincide */\n            if ( next_edge.bundle[Clip.ABOVE][ne_type] == 1)\n            {\n                if (Clip.EQ(e0.xb, next_edge.xb) && gpcas.geometry.Clip.EQ(e0.dx, next_edge.dx) && (e0.top.y != yb))\n                {\n                    next_edge.bundle[Clip.ABOVE][ ne_type     ] ^= e0.bundle[Clip.ABOVE][ ne_type     ];\n                    next_edge.bundle[Clip.ABOVE][ ne_type_opp ]  = e0.bundle[Clip.ABOVE][ ne_type_opp ];\n                    next_edge.bstate[Clip.ABOVE] = BundleState.BUNDLE_HEAD;\n                    e0.bundle[Clip.ABOVE][Clip.CLIP] = 0;\n                    e0.bundle[Clip.ABOVE][Clip.SUBJ] = 0;\n                    e0.bstate[Clip.ABOVE] = BundleState.BUNDLE_TAIL;\n                }\n                e0 = next_edge;\n\n            }\n        }\n\n        var horiz= [] ;\n        horiz[Clip.CLIP]= HState.NH;\n        horiz[Clip.SUBJ]= HState.NH;\n\n        var exists= [] ;\n        exists[Clip.CLIP] = 0;\n        exists[Clip.SUBJ] = 0;\n\n        var cf= null ;\n\n        /* Process each edge at this scanbeam boundary */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next )\n        {\n            exists[Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP] + (edge.bundle[Clip.BELOW][Clip.CLIP] << 1);\n            exists[Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ] + (edge.bundle[Clip.BELOW][Clip.SUBJ] << 1);\n\n            if( (exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0) )\n            {\n                /* Set bundle side */\n                edge.bside[Clip.CLIP] = parity[Clip.CLIP];\n                edge.bside[Clip.SUBJ] = parity[Clip.SUBJ];\n\n                var contributing= false ;\n                var br=0;\n                var bl=0;\n                var tr=0;\n                var tl=0;\n                /* Determine contributing status and quadrant occupancies */\n                if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && ((parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && ((parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP]!=0) && (parity[Clip.SUBJ]!=0)) ? 1: 0;\n                    bl = ( ((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1: 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) !=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0)) !=0) ) ? 1: 0;\n                    tl = (((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0))?1:0;\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                {\n                    contributing= (exists[Clip.CLIP]!=0) || (exists[Clip.SUBJ]!=0);\n                    br= (parity[Clip.CLIP]) ^ (parity[Clip.SUBJ]);\n                    bl= (parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) ^ (parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    tr= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0));\n                    tl= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])\n                        ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]);\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && (!(parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && (!(parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br= ((parity[Clip.CLIP]!=0) || (parity[Clip.SUBJ]!=0))?1:0;\n                    bl= (((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                    tr= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0))!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0))!=0) ) ?1:0;\n                    tl= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0) ) ? 1:0;\n                }\n                else\n                {\n                    //console.log(\"ERROR : Unknown op\");\n                }\n\n                /* Update parity */\n                parity[Clip.CLIP] ^= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                parity[Clip.SUBJ] ^= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n\n                /* Update horizontal state */\n                if (exists[Clip.CLIP]!=0)\n                {\n                    horiz[Clip.CLIP] = HState.next_h_state[horiz[Clip.CLIP]][((exists[Clip.CLIP] - 1) << 1) + parity[Clip.CLIP]];\n                }\n                if( exists[Clip.SUBJ]!=0)\n                {\n                    horiz[Clip.SUBJ] = HState.next_h_state[horiz[Clip.SUBJ]][((exists[Clip.SUBJ] - 1) << 1) + parity[Clip.SUBJ]];\n                }\n\n                if (contributing)\n                {\n                    var xb= edge.xb;\n\n\n\n                    var vclass= VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                        case VertexType.IMN:\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.ELI:\n                            edge.outp[Clip.BELOW].add_left( xb, yb);\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            break;\n                        case VertexType.EMX:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            break;\n                        case VertexType.ILI:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.IRI:\n                            edge.outp[Clip.BELOW].add_right( xb, yb );\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMX:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb );\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMM:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.EMM:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.LED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_left( xb, yb);\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        case VertexType.RED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_right( xb, yb );\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing conditional */\n            } /* End of edge exists conditional */\n            if( gpcas.geometry.Clip.DEBUG )\n            {\n                out_poly.print();\n            }\n\t\t\tout_poly.print();\n        } /* End of AET loop */\n\n\n\n        /* Delete terminating edges from the AET, otherwise compute xt */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n        {\n            if (edge.top.y == yb)\n            {\n                var prev_edge= edge.prev;\n                var next_edge= edge.next;\n\n                if (prev_edge != null)\n                    prev_edge.next = next_edge;\n                else\n                    aet.top_node = next_edge;\n\n                if (next_edge != null )\n                    next_edge.prev = prev_edge;\n\n                /* Copy bundle head state to the adjacent tail edge if required */\n                if ((edge.bstate[Clip.BELOW] == BundleState.BUNDLE_HEAD) && (prev_edge!=null))\n                {\n                    if (prev_edge.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                    {\n                        prev_edge.outp[Clip.BELOW]= edge.outp[Clip.BELOW];\n                        prev_edge.bstate[Clip.BELOW]= BundleState.UNBUNDLED;\n                        if ( prev_edge.prev != null)\n                        {\n                            if (prev_edge.prev.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                            {\n                                prev_edge.bstate[Clip.BELOW] = BundleState.BUNDLE_HEAD;\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if (edge.top.y == yt)\n                    edge.xt= edge.top.x;\n                else\n                    edge.xt= edge.bot.x + edge.dx * (yt - edge.bot.y);\n            }\n        }\n\n        if (scanbeam < sbte.sbt_entries )\n        {\n            /* === SCANBEAM INTERIOR PROCESSING ============================== */\n\n            /* Build intersection table for the current scanbeam */\n            var it_table= new ItNodeTable();\n            it_table.build_intersection_table(aet, dy);\n\n\n\n            /* Process each node in the intersection table */\n\n            for (var intersect= it_table.top_node ; (intersect != null); intersect = intersect.next)\n            {\n\n\n\t\t\t\te0= intersect.ie[0];\n\t\t\t\te1= intersect.ie[1];\n\n                /* Only generate output for contributing intersections */\n\n                if ( ((e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)) &&\n                    ((e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)))\n                {\n                    var p= e0.outp[Clip.ABOVE];\n                    var q= e1.outp[Clip.ABOVE];\n                    var ix= intersect.point.x;\n                    var iy= intersect.point.y + yb;\n\n                    var in_clip= ( ( (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e0.bside[Clip.CLIP]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&  (e1.bside[Clip.CLIP]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&\n                        (e0.bside[Clip.CLIP]!=0) && (e1.bside[Clip.CLIP]!=0) ) ) ? 1: 0;\n\n                    var in_subj= ( ( (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e0.bside[Clip.SUBJ]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&  (e1.bside[Clip.SUBJ]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&\n                        (e0.bside[Clip.SUBJ]!=0) && (e1.bside[Clip.SUBJ]!=0) ) ) ? 1: 0;\n\n                    var tr=0\n                    var tl=0;\n                    var br=0;\n                    var bl=0;\n                    /* Determine quadrant occupancies */\n                    if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                    {\n                        tr= ((in_clip!=0) && (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1:0;\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                    {\n                        tr= in_clip^ in_subj;\n                        tl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        br= (in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        bl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])\n                            ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                    {\n                        tr= ((in_clip!=0) || (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) ||\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                    }\n                    else\n                    {\n                        //console.log(\"ERROR : Unknown op type, \"+op);\n                    }\n\n                    var vclass = VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (p != null)\n                            {\n                                p.add_right(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.ELI:\n                            if (q != null)\n                            {\n                                q.add_left(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.EMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left( ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ILI:\n                            if (p != null)\n                            {\n                                p.add_left(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IRI:\n                            if (q!=null)\n                            {\n                                q.add_right(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        case VertexType.EMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing intersection conditional */\n\n                /* Swap bundle sides in response to edge crossing */\n                if (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e1.bside[Clip.CLIP] = (e1.bside[Clip.CLIP]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e0.bside[Clip.CLIP]= (e0.bside[Clip.CLIP]==0)?1:0;\n                if (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e1.bside[Clip.SUBJ]= (e1.bside[Clip.SUBJ]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e0.bside[Clip.SUBJ]= (e0.bside[Clip.SUBJ]==0)?1:0;\n\n                /* Swap e0 and e1 bundles in the AET */\n                var prev_edge= e0.prev;\n                var next_edge= e1.next;\n                if (next_edge != null)\n                {\n                    next_edge.prev = e0;\n                }\n\n                if (e0.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD)\n                {\n                    var search= true;\n                    while (search)\n                    {\n                        prev_edge= prev_edge.prev;\n                        if (prev_edge != null)\n                        {\n                            if (prev_edge.bstate[Clip.ABOVE] != BundleState.BUNDLE_TAIL)\n                            {\n                                search= false;\n                            }\n                        }\n                        else\n                        {\n                            search= false;\n                        }\n                    }\n                }\n                if (prev_edge == null)\n                {\n                    aet.top_node.prev = e1;\n                    e1.next           = aet.top_node;\n                    aet.top_node      = e0.next;\n                }\n                else\n                {\n                    prev_edge.next.prev = e1;\n                    e1.next             = prev_edge.next;\n                    prev_edge.next      = e0.next;\n                }\n                e0.next.prev = prev_edge;\n                e1.next.prev = e1;\n                e0.next      = next_edge;\n                if( gpcas.geometry.Clip.DEBUG )\n                {\n                    out_poly.print();\n                }\n            } /* End of IT loop*/\n\n            /* Prepare for next scanbeam */\n            for ( var edge= aet.top_node; (edge != null); edge = edge.next)\n            {\n                var next_edge= edge.next;\n                var succ_edge= edge.succ;\n                if ((edge.top.y == yt) && (succ_edge!=null))\n                {\n                    /* Replace AET edge by its successor */\n                    succ_edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    succ_edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    succ_edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    succ_edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    var prev_edge= edge.prev;\n                    if ( prev_edge != null )\n                        prev_edge.next = succ_edge;\n                    else\n                        aet.top_node = succ_edge;\n                    if (next_edge != null)\n                        next_edge.prev= succ_edge;\n                    succ_edge.prev = prev_edge;\n                    succ_edge.next = next_edge;\n                }\n                else\n                {\n                    /* Update this edge */\n                    edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    edge.xb= edge.xt;\n                }\n                edge.outp[Clip.ABOVE]= null;\n            }\n        }\n    } /* === END OF SCANBEAM PROCESSING ================================== */\n\n    /* Generate result polygon from out_poly */\n    result = out_poly.getResult(polyClass);\n\t//console.log(\"result = \"+result);\n\n    return result ;\n}\n\ngpcstatic.EQ = function(a, b) {\n    return (Math.abs(a - b) <= gpcas.geometry.Clip.GPC_EPSILON);\n}\n\ngpcstatic.PREV_INDEX = function( i, n) {\n    return ((i - 1+ n) % n);\n}\n\ngpcstatic.NEXT_INDEX = function(i, n) {\n    return ((i + 1) % n);\n}\n\ngpcstatic.OPTIMAL = function ( p, i) {\n    return (p.getY(gpcas.geometry.Clip.PREV_INDEX (i, p.getNumPoints())) != p.getY(i)) ||\n        (p.getY(gpcas.geometry.Clip.NEXT_INDEX(i, p.getNumPoints())) != p.getY(i)) ;\n}\n\ngpcstatic.create_contour_bboxes = function (p)\n{\n    var box= [] ;\n\n    /* Construct contour bounding boxes */\n    for ( var c= 0; c < p.getNumInnerPoly(); c++)\n    {\n        var inner_poly= p.getInnerPoly(c);\n        box[c] = inner_poly.getBounds();\n    }\n    return box;\n}\n\ngpcstatic.minimax_test = function ( subj, clip, op){\n    var s_bbox= gpcas.geometry.Clip.create_contour_bboxes(subj);\n\tvar c_bbox= gpcas.geometry.Clip.create_contour_bboxes(clip);\n\n\tvar subj_num_poly= subj.getNumInnerPoly();\n\tvar clip_num_poly= clip.getNumInnerPoly();\n\tvar o_table = ArrayHelper.create2DArray(subj_num_poly,clip_num_poly);\n\n\t/* Check all subject contour bounding boxes against clip boxes */\n\tfor( var s= 0; s < subj_num_poly; s++ )\n\t{\n\t    for( var c= 0; c < clip_num_poly ; c++ )\n\t    {\n\t        o_table[s][c] =\n\t            (!((s_bbox[s].getMaxX() < c_bbox[c].getMinX()) ||\n\t                (s_bbox[s].getMinX() > c_bbox[c].getMaxX()))) &&\n\t                (!((s_bbox[s].getMaxY() < c_bbox[c].getMinY()) ||\n\t                    (s_bbox[s].getMinY() > c_bbox[c].getMaxY())));\n\t    }\n\t}\n\n\t/* For each clip contour, search for any subject contour overlaps */\n\tfor( var c= 0; c < clip_num_poly; c++ )\n\t{\n\t    var overlap= false;\n\t    for( var s= 0; !overlap && (s < subj_num_poly) ; s++)\n\t    {\n\t        overlap = o_table[s][c];\n\t    }\n\t    if (!overlap)\n\t    {\n\t        clip.setContributing( c, false ); // Flag non contributing status\n\t    }\n\t}\n\n\tif (op == gpcas.geometry.OperationType.GPC_INT)\n\t{\n\t    /* For each subject contour, search for any clip contour overlaps */\n\t    for ( var s= 0; s < subj_num_poly; s++)\n\t    {\n\t        var overlap= false;\n\t        for ( var c= 0; !overlap && (c < clip_num_poly); c++)\n\t        {\n\t            overlap = o_table[s][c];\n\t        }\n\t        if (!overlap)\n\t        {\n\t            subj.setContributing( s, false ); // Flag non contributing status\n\t        }\n\t    }\n\t}\n}\n\ngpcstatic.bound_list = function( lmt_table, y) {\n    if( lmt_table.top_node == null )\n    {\n        lmt_table.top_node = new LmtNode(y);\n        return lmt_table.top_node ;\n    }\n    else\n    {\n        var prev= null ;\n        var node= lmt_table.top_node ;\n        var done= false ;\n        while( !done )\n        {\n            if( y < node.y )\n            {\n                /* Insert a new LMT node before the current node */\n                var existing_node= node ;\n                node = new LmtNode(y);\n                node.next = existing_node ;\n                if( prev == null )\n                {\n                    lmt_table.top_node = node ;\n                }\n                else\n                {\n                    prev.next = node ;\n                }\n                //               if( existing_node == lmt_table.top_node )\n                //               {\n                //                  lmt_table.top_node = node ;\n                //               }\n                done = true ;\n            }\n            else if ( y > node.y )\n            {\n                /* Head further up the LMT */\n                if( node.next == null )\n                {\n                    node.next = new LmtNode(y);\n                    node = node.next ;\n                    done = true ;\n                }\n                else\n                {\n                    prev = node ;\n                    node = node.next ;\n                }\n            }\n            else\n            {\n                /* Use this existing LMT node */\n                done = true ;\n            }\n        }\n        return node ;\n    }\n}\n\ngpcstatic.insert_bound = function ( lmt_node, e) {\n    if( lmt_node.first_bound == null )\n{\n    /* Link node e to the tail of the list */\n    lmt_node.first_bound = e ;\n}\nelse\n{\n    var done= false ;\n    var prev_bound= null ;\n    var current_bound= lmt_node.first_bound ;\n    while( !done )\n    {\n        /* Do primary sort on the x field */\n        if (e.bot.x <  current_bound.bot.x)\n        {\n            /* Insert a new node mid-list */\n            if( prev_bound == null )\n            {\n                lmt_node.first_bound = e ;\n            }\n            else\n            {\n                prev_bound.next_bound = e ;\n            }\n            e.next_bound = current_bound ;\n\n            //               EdgeNode existing_bound = current_bound ;\n            //               current_bound = e ;\n            //               current_bound.next_bound = existing_bound ;\n            //               if( lmt_node.first_bound == existing_bound )\n            //               {\n            //                  lmt_node.first_bound = current_bound ;\n            //               }\n            done = true ;\n        }\n        else if (e.bot.x == current_bound.bot.x)\n        {\n            /* Do secondary sort on the dx field */\n            if (e.dx < current_bound.dx)\n            {\n                /* Insert a new node mid-list */\n                if( prev_bound == null )\n                {\n                    lmt_node.first_bound = e ;\n                }\n                else\n                {\n                    prev_bound.next_bound = e ;\n                }\n                e.next_bound = current_bound ;\n                //                  EdgeNode existing_bound = current_bound ;\n                //                  current_bound = e ;\n                //                  current_bound.next_bound = existing_bound ;\n                //                  if( lmt_node.first_bound == existing_bound )\n                //                  {\n                //                     lmt_node.first_bound = current_bound ;\n                //                  }\n                done = true ;\n            }\n            else\n            {\n                /* Head further down the list */\n                if( current_bound.next_bound == null )\n                {\n                    current_bound.next_bound = e ;\n                    done = true ;\n                }\n                else\n                {\n                    prev_bound = current_bound ;\n                    current_bound = current_bound.next_bound ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further down the list */\n            if( current_bound.next_bound == null )\n            {\n                current_bound.next_bound = e ;\n                done = true ;\n            }\n            else\n            {\n                prev_bound = current_bound ;\n                current_bound = current_bound.next_bound ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_edge_to_aet = function ( aet, edge) {\n    if ( aet.top_node == null )\n{\n    /* Append edge onto the tail end of the AET */\n    aet.top_node = edge;\n    edge.prev = null ;\n    edge.next= null;\n}\nelse\n{\n    var current_edge= aet.top_node ;\n    var prev= null ;\n    var done= false ;\n    while( !done )\n    {\n        /* Do primary sort on the xb field */\n        if (edge.xb < current_edge.xb)\n        {\n            /* Insert edge here (before the AET edge) */\n            edge.prev= prev;\n            edge.next= current_edge ;\n            current_edge.prev = edge ;\n            if( prev == null )\n            {\n                aet.top_node = edge ;\n            }\n            else\n            {\n                prev.next = edge ;\n            }\n            //               if( current_edge == aet.top_node )\n            //               {\n            //                  aet.top_node = edge ;\n            //               }\n            //               current_edge = edge ;\n            done = true;\n        }\n        else if (edge.xb == current_edge.xb)\n        {\n            /* Do secondary sort on the dx field */\n            if (edge.dx < current_edge.dx)\n            {\n                /* Insert edge here (before the AET edge) */\n                edge.prev= prev;\n                edge.next= current_edge ;\n                current_edge.prev = edge ;\n                if( prev == null )\n                {\n                    aet.top_node = edge ;\n                }\n                else\n                {\n                    prev.next = edge ;\n                }\n                //                  if( current_edge == aet.top_node )\n                //                  {\n                //                     aet.top_node = edge ;\n                //                  }\n                //                  current_edge = edge ;\n                done = true;\n            }\n            else\n            {\n                /* Head further into the AET */\n                prev = current_edge ;\n                if( current_edge.next == null )\n                {\n                    current_edge.next = edge ;\n                    edge.prev = current_edge ;\n                    edge.next = null ;\n                    done = true ;\n                }\n                else\n                {\n                    current_edge = current_edge.next ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further into the AET */\n            prev = current_edge ;\n            if( current_edge.next == null )\n            {\n                current_edge.next = edge ;\n                edge.prev = current_edge ;\n                edge.next = null ;\n                done = true ;\n            }\n            else\n            {\n                current_edge = current_edge.next ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_to_sbtree = function ( sbte, y) {\n    if( sbte.sb_tree == null )\n\t\t{\n\t\t    /* Add a new tree node here */\n\t\t    sbte.sb_tree = new gpcas.geometry.ScanBeamTree( y );\n\t\t    sbte.sbt_entries++ ;\n\t\t    return ;\n\t\t}\n\tvar tree_node= sbte.sb_tree ;\n\tvar done= false ;\n\twhile( !done )\n\t{\n\t    if ( tree_node.y > y)\n\t    {\n\t        if( tree_node.less == null )\n\t        {\n\t            tree_node.less = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.less ;\n\t        }\n\t    }\n\t    else if ( tree_node.y < y)\n\t    {\n\t        if( tree_node.more == null )\n\t        {\n\t            tree_node.more = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.more ;\n\t        }\n\t    }\n\t    else\n\t    {\n\t        done = true ;\n\t    }\n\t}\n}\n\n\ngpcstatic.build_lmt = function( lmt_table,\n\t\t\t\t\t\t\tsbte,\n\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\ttype, //poly type SUBJ/Clip.CLIP\n\t\t\t\t\t\t\top) {\n\t\t\t/* Create the entire input polygon edge table in one go */\n\t\t\tvar edge_table= new gpcas.geometry.EdgeTable();\n\n\t\t\tfor ( var c= 0; c < p.getNumInnerPoly(); c++)\n\t\t\t{\n\t\t\t\tvar ip= p.getInnerPoly(c);\n\t\t\t\tif( !ip.isContributing(0) )\n\t\t\t\t{\n\t\t\t\t\t/* Ignore the non-contributing contour */\n\t\t\t\t\tip.setContributing(0, true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\n\t\t\t\t\t/* Perform contour optimisation */\n\t\t\t\t\tvar num_vertices= 0;\n\t\t\t\t\tvar e_index= 0;\n\t\t\t\t\tedge_table = new gpcas.geometry.EdgeTable();\n\t\t\t\t\tfor ( var i= 0; i < ip.getNumPoints(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( gpcas.geometry.Clip.OPTIMAL(ip, i) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x= ip.getX(i);\n\t\t\t\t\t\t\tvar y= ip.getY(i);\n\t\t\t\t\t\t\tedge_table.addNode( x, y );\n\n\t\t\t\t\t\t\t/* Record vertex in the scanbeam table */\n                            gpcas.geometry.Clip.add_to_sbtree( sbte, ip.getY(i) );\n\n\t\t\t\t\t\t\tnum_vertices++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour forward pass */\n\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a forward local minimum... */\n\t\t\t\t\t\tif( edge_table.FWD_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the next local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.NEXT_INDEX( min, num_vertices );\n\t\t\t\t\t\t\twhile( edge_table.NOT_FMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.NEXT_INDEX( max, num_vertices );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the next edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = gpcas.geometry.BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor ( var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv = gpcas.geometry.Clip.NEXT_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x= ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y= ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx= (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null ;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"fwd\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index += num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour reverse pass */\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a reverse local minimum... */\n\t\t\t\t\t\tif ( edge_table.REV_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the previous local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.PREV_INDEX(min, num_vertices);\n\t\t\t\t\t\t\twhile( edge_table.NOT_RMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.PREV_INDEX(max, num_vertices);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the previous edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor (var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv= gpcas.geometry.Clip.PREV_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y = ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null ;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"rev\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index+= num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn edge_table;\n\t\t}\n\n\ngpcstatic.add_st_edge = function( st, it, edge, dy) {\n    if (st == null)\n    {\n        /* Append edge onto the tail end of the ST */\n        st = new gpcas.geometry.StNode( edge, null );\n    }\n    else\n    {\n        var den= (st.xt - st.xb) - (edge.xt - edge.xb);\n\n        /* If new edge and ST edge don't cross */\n        if( (edge.xt >= st.xt) || (edge.dx == st.dx) || (Math.abs(den) <= gpcas.geometry.Clip.GPC_EPSILON))\n        {\n            /* No intersection - insert edge here (before the ST edge) */\n            var existing_node= st;\n            st = new StNode( edge, existing_node );\n        }\n        else\n        {\n            /* Compute intersection between new edge and ST edge */\n            var r= (edge.xb - st.xb) / den;\n            var x= st.xb + r * (st.xt - st.xb);\n            var y= r * dy;\n\n            /* Insert the edge pointers and the intersection point in the IT */\n            it.top_node = gpcas.geometry.Clip.add_intersection(it.top_node, st.edge, edge, x, y);\n\n            /* Head further into the ST */\n            st.prev = gpcas.geometry.Clip.add_st_edge(st.prev, it, edge, dy);\n        }\n    }\n    return st ;\n}\n\n\n\ngpcstatic.add_intersection = function ( it_node,\n    edge0,\n    edge1,\n    x,\n    y) {\n    if (it_node == null)\n    {\n        /* Append a new node to the tail of the list */\n        it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, null );\n    }\n    else\n    {\n        if ( it_node.point.y > y)\n        {\n            /* Insert a new node mid-list */\n            var existing_node= it_node ;\n            it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, existing_node );\n        }\n        else\n        {\n            /* Head further down the list */\n            it_node.next = gpcas.geometry.Clip.add_intersection( it_node.next, edge0, edge1, x, y);\n        }\n    }\n    return it_node ;\n}\n\n\n/////////// AetTree ////////////////////////////////////\ngpcas.geometry.AetTree = function(){\n    this.top_node = null; //EdgeNode\n};\nAetTree = gpcas.geometry.AetTree;\ngpcas.geometry.AetTree.prototype.print = function() {\n    //console.log(\"aet\");\n    for( var edge= this.top_node ; (edge != null) ; edge = edge.next ) {\n        //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n    }\n}\n\n\n///////////////  BundleState  //////////////////////////////\ngpcas.geometry.BundleState = function(state){\n    this.m_State = state ; //String\n};\ngpcas.geometry.BundleState.UNBUNDLED = new gpcas.geometry.BundleState(\"UNBUNDLED\");\ngpcas.geometry.BundleState.BUNDLE_HEAD = new gpcas.geometry.BundleState(\"BUNDLE_HEAD\");\ngpcas.geometry.BundleState.BUNDLE_TAIL = new gpcas.geometry.BundleState(\"BUNDLE_TAIL\");\ngpcas.geometry.BundleState.prototype.toString = function() {\n    return this.m_State;\n};\nBundleState = gpcas.geometry.BundleState;\n\n/////////////// EdgeNode ////////////////////////////\ngpcas.geometry.EdgeNode = function(){\n\tthis.vertex= new Point(); /* Piggy-backed contour vertex data  */\n\tthis.bot= new Point(); /* Edge lower (x, y) coordinate      */\n\tthis.top= new Point(); /* Edge upper (x, y) coordinate      */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.type;         /* Clip / subject edge flag          */\n\tthis.bundle = ArrayHelper.create2DArray(2,2);      /* Bundle edge flags                 */\n\tthis.bside= [];         /* Bundle left / right indicators    */\n\tthis.bstate= []; /* Edge bundle state                 */\n\tthis.outp= []; /* Output polygon / tristrip pointer */\n\tthis.prev;         /* Previous edge in the AET          */\n\tthis.next;         /* Next edge in the AET              */\n\tthis.pred;         /* Edge connected at the lower end   */\n\tthis.succ;         /* Edge connected at the upper end   */\n\tthis.next_bound;   /* Pointer to next bound in LMT      */\n};\n\n\n\n////////////////   EdgeTable /////////////////////////////////////////\n\n\ngpcas.geometry.EdgeTable = function() {\n\tthis.m_List = new gpcas.util.ArrayList();\n};\ngpcas.geometry.EdgeTable.prototype.addNode = function(x,y){\n\tvar node= new gpcas.geometry.EdgeNode();\n    node.vertex.x = x ;\n    node.vertex.y = y ;\n    this.m_List.add( node );\n\n}\ngpcas.geometry.EdgeTable.prototype.getNode = function (index) {\n\treturn this.m_List.get(index);\n}\ngpcas.geometry.EdgeTable.prototype.FWD_MIN = function(i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n\n    return ((prev.vertex.y >= ith.vertex.y) &&\n                 (next.vertex.y >  ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_FMAX = function ( i) {\n\tvar m_List = this.m_List;\n\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return(next.vertex.y > ith.vertex.y);\n}\ngpcas.geometry.EdgeTable.prototype.REV_MIN = function ( i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return ((prev.vertex.y >  ith.vertex.y) && (next.vertex.y >= ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_RMAX = function (i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return (prev.vertex.y > ith.vertex.y) ;\n}\n\n\n/////////////////////   HState   //////////////////////////////////////\ngpcas.geometry.HState = function(){};\ngpcas.geometry.HState.NH = 0; /* No horizontal edge                */\ngpcas.geometry.HState.BH = 1; /* Bottom horizontal edge            */\ngpcas.geometry.HState.TH = 2; /* Top horizontal edge               */\n\nHState = gpcas.geometry.HState;\n\nvar NH = gpcas.geometry.HState.NH;\nvar BH = gpcas.geometry.HState.BH;\nvar TH = gpcas.geometry.HState.TH;\n\n/* Horizontal edge state transitions within scanbeam boundary */\ngpcas.geometry.HState.next_h_state =\n      [\n      /*        ABOVE     BELOW     CROSS */\n      /*        L   R     L   R     L   R */\n      /* NH */ [BH, TH,   TH, BH,   NH, NH],\n      /* BH */ [NH, NH,   NH, NH,   TH, TH],\n      /* TH */ [NH, NH,   NH, NH,   BH, BH]\n      ];\n\n\n\n///////////////////////    \t  IntersectionPoint /////////////////////////////\ngpcas.geometry.IntersectionPoint = function(p1,p2,p3){\n\tthis.polygonPoint1 = p1; /* of Point */;\n\tthis.polygonPoint2 = p2;  /* of Point */;\n\tthis.intersectionPoint = p3 ;\n};\ngpcas.geometry.IntersectionPoint.prototype.toString = function (){\n\treturn \"P1 :\"+polygonPoint1.toString()+\" P2:\"+polygonPoint2.toString()+\" IP:\"+intersectionPoint.toString();\n}\n\n\n///////////////////////////    ItNode   ///////////////\ngpcas.geometry.ItNode = function(edge0, edge1, x, y, next){\n\tthis.ie= [];     /* Intersecting edge (bundle) pair   */\n\tthis.point= new Point(x,y); /* Point of intersection             */\n\tthis.next=next;                         /* The next intersection table node  */\n\n\tthis.ie[0] = edge0 ;\n    this.ie[1] = edge1 ;\n\n};\n\n\n///////////////////////////    ItNodeTable   ///////////////\ngpcas.geometry.ItNodeTable = function(){\n\tthis.top_node;\n}\nItNodeTable = gpcas.geometry.ItNodeTable;\n\ngpcas.geometry.ItNodeTable.prototype.build_intersection_table = function (aet, dy) {\n    var st= null ;\n\n    /* Process each AET edge */\n    for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n    {\n        if( (edge.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) ||\n                (edge.bundle[Clip.ABOVE][Clip.CLIP] != 0) ||\n                (edge.bundle[Clip.ABOVE][Clip.SUBJ] != 0) )\n        {\n            st = gpcas.geometry.Clip.add_st_edge(st, this, edge, dy);\n        }\n\n\n    }\n}\n\n////////////// Line //////////////////////////\ngpcas.geometry.Line = function(){\n\tthis.start;\n\tthis.end;\n}\n\n////////////   LineHelper /////////////////////\n\ngpcas.geometry.LineHelper = function(){};\ngpcas.geometry.LineHelper.equalPoint = function (p1,p2){\n\treturn ((p1[0]==p2[0])&&(p1[1]==p2[1]));\n}\ngpcas.geometry.LineHelper.equalVertex = function(s1,e1,s2,e2) {\n\treturn (\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,s2))&&(gpcas.geometry.LineHelper.equalPoint(e1,e2)))\n\t\t||\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,e2))&&(gpcas.geometry.LineHelper.equalPoint(e1,s2)))\n\t\t);\n}\ngpcas.geometry.LineHelper.distancePoints = function(p1, p2){\n\treturn Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\n}\ngpcas.geometry.LineHelper.clonePoint = function(p){\n\treturn [p[0],p[1]];\n}\ngpcas.geometry.LineHelper.cloneLine = function(line){\n\tvar res  = [];\n\tfor (var i = 0; i<line.length; i++){\n\t\tres[i]=[line[i][0],line[i][1]];\n\t}\n\treturn res;\n}\ngpcas.geometry.LineHelper.addLineToLine = function(line1,line2) {\n\tfor (var i = 0; i<line2.length; i++){\n\t\tline1.push(clonePoint(line2[i]));\n\t}\n}\ngpcas.geometry.LineHelper.roundPoint = function(p) {\n\tp[0]=Math.round(p[0]);\n\tp[1]=Math.round(p[1]);\n}\n//---------------------------------------------------------------\n//Checks for intersection of Segment if as_seg is true.\n//Checks for intersection of Line if as_seg is false.\n//Return intersection of Segment \"AB\" and Segment \"EF\" as a Point\n//Return null if there is no intersection\n//---------------------------------------------------------------\ngpcas.geometry.LineHelper.lineIntersectLine = function(A,B,E,F,as_seg)\n{\n\tif(as_seg == null) as_seg = true;\n\tvar ip;\n\tvar a1;\n\tvar a2;\n\tvar b1;\n\tvar b2;\n\tvar c1;\n\tvar c2;\n\n\ta1= B.y-A.y;\n\tb1= A.x-B.x;\n\tc1= B.x*A.y - A.x*B.y;\n\ta2= F.y-E.y;\n\tb2= E.x-F.x;\n\tc2= F.x*E.y - E.x*F.y;\n\n\tvar denom=a1*b2 - a2*b1;\n\tif(denom == 0){\n\t\treturn null;\n\t}\n\tip=new Point();\n\tip.x=(b1*c2 - b2*c1)/denom;\n\tip.y=(a2*c1 - a1*c2)/denom;\n\n\t//---------------------------------------------------\n\t//Do checks to see if intersection to endpoints\n\t//distance is longer than actual Segments.\n\t//Return null if it is with any.\n\t//---------------------------------------------------\n\tif(as_seg){\n\t\tif(Math.pow((ip.x - B.x) + (ip.y - B.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - A.x) + (ip.y - A.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\n\t\tif(Math.pow((ip.x - F.x) + (ip.y - F.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - E.x) + (ip.y - E.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn new Point(Math.round(ip.x),Math.round(ip.y));\n}\n\n\n//////////////  LineIntersection  ///////////////////////\ngpcas.geometry.LineIntersection = function(){};\ngpcas.geometry.LineIntersection.iteratePoints = function(points, s1, s2,e1,e2) {\n\tvar direction=true;\n\tvar pl = points.length;\n\tvar s1Ind = points.indexOf(s1);\n\tvar s2Ind = points.indexOf(s2);\n\tvar start = s1Ind;\n\n\tif (s2Ind>s1Ind) direction=false;\n\tvar newPoints  = [];\n\tvar point  ;\n\n\tif (direction){\n\t\tfor (var i =0; i<pl; i++){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var i =pl; i>=0; i--){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newPoints;\n}\n\ngpcas.geometry.LineIntersection.intersectPoly = function(poly, line /* of Points */){\n\tvar res = [];\n\tvar numPoints = poly.getNumPoints();\n\n\t//points\n\tvar ip ;\n\tvar p1 ;\n\tvar p2 ;\n\tvar p3 ;\n\tvar p4 ;\n\tvar firstIntersection  = null;\n\tvar lastIntersection   = null;\n\tvar firstIntersectionLineIndex=-1;\n\tvar lastIntersectionLineIndex=-1;\n\tvar firstFound  = false;\n\n\tfor (var i  = 1; i<line.length; i++){\n\t\tp1=line[i-1];\n\t\tp2=line[i];\n\t\tvar maxDist  = 0;\n\t\tvar minDist\t = Number.MAX_VALUE;\n\t\tvar dist  = -1;\n\t\tfor (var j  = 0; j<numPoints; j++){\n\t\t\tp3=poly.getPoint(j==0?numPoints-1:j-1);\n\t\t\tp4=poly.getPoint(j);\n\t\t\tif ((ip=LineHelper.lineIntersectLine(p1,p2,p3,p4))!=null){\n\t\t\t\tdist=Point.distance(ip,p2);\n\n\t\t\t\tif ((dist>maxDist)&&(!firstFound)){\n\t\t\t\t\tmaxDist=dist;\n\t\t\t\t\tfirstIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tfirstIntersectionLineIndex=i;\n\t\t\t\t}\n\t\t\t\tif (dist<minDist){\n\t\t\t\t\tminDist=dist;\n\t\t\t\t\tlastIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tlastIntersectionLineIndex=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfirstFound=(firstIntersection!=null);\n\t}\n\t\t\t/*\n\t\t\tAlert.show(firstIntersection.toString());\n\t\t\tAlert.show(lastIntersection.toString());*/\n\tif ((firstIntersection!=null)&&(lastIntersection!=null)){\n\t\tvar newLine /* of Point */ = [];\n\t\tnewLine[0]=firstIntersection.intersectionPoint;\n\t\tvar j  = 1;\n\t\tfor (var i = firstIntersectionLineIndex; i<=lastIntersectionLineIndex; i++){\n\t\t\tnewLine[j++] = line[i];\n\t\t}\n\t\tnewLine[newLine.length-1]=lastIntersection.intersectionPoint;\n\t\tif (\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint1))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint2))\n\t\t\t)||\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint2))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint1))\n\t\t\t\t)\n\t\t){\n\t\t\t\tvar poly1 = new gpcas.geometry.PolySimple();\n\t\t\t\tpoly1.add(newLine);\n\t\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\t\tvar finPoly2  = poly.xor(poly1);\n\t\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t} else {\n\t\t\tvar points1 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint1,firstIntersection.polygonPoint2, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints1=points1.concat(newLine.reverse());\n\t\t\tvar points2 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint2,firstIntersection.polygonPoint1, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints2=points2.concat(newLine);\n\t\t\tvar poly1  = new gpcas.geometry.PolySimple();\n\t\t\tpoly1.add(points1);\n\t\t\tvar poly2  = new gpcas.geometry.PolySimple();\n\t\t\tpoly2.add(points2);\n\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\tvar finPoly2  = poly.intersection(poly2);\n\n\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n}\ngpcas.geometry.LineIntersection.checkPoly = function(poly) {\n\tvar noHoles =0;\n\tfor (var i  = 0; i<poly.getNumInnerPoly(); i++){\n\t\tvar innerPoly  = poly.getInnerPoly(i);\n\t\tif (innerPoly.isHole()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\tnoHoles++;\n\t\t}\n\t\tif (noHoles>1) return false;\n\t}\n\treturn true;\n}\n\n\n///////////  LmtNode //////////////////////////\n\ngpcas.geometry.LmtNode = function(yvalue) {\n\tthis.y = yvalue;            /* Y coordinate at local minimum     */\n\tthis.first_bound;  /* Pointer to bound list             */\n\tthis.next;         /* Pointer to next local minimum     */\n};\nLmtNode = gpcas.geometry.LmtNode;\n\n////////////// LmtTable ///////////////\n\ngpcas.geometry.LmtTable = function(){\n\tthis.top_node;\n};\ngpcas.geometry.LmtTable.prototype.print = function() {\n    var n= 0;\n    var lmt= this.top_node ;\n    while( lmt != null )\n    {\n\t\t//console.log(\"lmt(\"+n+\")\");\n\t\tfor( var edge= lmt.first_bound ; (edge != null) ; edge = edge.next_bound )\n\t\t{\n\t\t   //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n\t\t}\n\t\tn++ ;\n\t\tlmt = lmt.next ;\n    }\n}\n\n/////////////   OperationType //////////////////////////////////\ngpcas.geometry.OperationType = function(type){\n\tthis.m_Type = type;\n}\ngpcas.geometry.OperationType.GPC_DIFF= new gpcas.geometry.OperationType( \"Difference\" );\ngpcas.geometry.OperationType.GPC_INT= new gpcas.geometry.OperationType( \"Intersection\" );\ngpcas.geometry.OperationType.GPC_XOR= new gpcas.geometry.OperationType( \"Exclusive or\" );\ngpcas.geometry.OperationType.GPC_UNION= new gpcas.geometry.OperationType( \"Union\" );\n\n//////////// Poly  /////////////////////\n// ---> an interface\n\n\n/////////////// PolyDefault  /////////////////////\n/**\n * <code>PolyDefault</code> is a default <code>Poly</code> implementation.\n * It provides support for both complex and simple polygons.  A <i>complex polygon</i>\n * is a polygon that consists of more than one polygon.  A <i>simple polygon</i> is a\n * more traditional polygon that contains of one inner polygon and is just a\n * collection of points.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty <code>PolyDefault</code>\n * object, it will create an inner polygon of type <code>PolySimple</code>.\n *\n * @see PolySimple\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolyDefault = function(isHole) {\n\tif(isHole == null) isHole = false;\n\n\t   /**\n    * Only applies to the first poly and can only be used with a poly that contains one poly\n    */\n\tthis.m_IsHole= isHole ;\n    this.m_List= new gpcas.util.ArrayList();\n}\n /**\n    * Return true if the given object is equal to this one.\n    */\ngpcas.geometry.PolyDefault.prototype.equals = function ( obj) {\n    if(!(obj instanceof PolyDefault)){\n\t\treturn false;\n    }\n    var that = obj;\n\n    if( this.m_IsHole != that.m_IsHole ) return false ;\n    if( !equals(this.m_List, that.m_List ) ) return false ;\n\n    return true ;\n}\n   /**\n    * Return the hashCode of the object.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    **/\ngpcas.geometry.PolyDefault.prototype.hashCode = function () {\n\tvar m_List = this.m_List;\n\n    var result= 17;\n    result = 37*result + m_List.hashCode();\n    return result;\n}\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.clear = function() {\n    this.m_List.clear();\n}\n\ngpcas.geometry.PolyDefault.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\tif (args.length==2){\n\t\tthis.addPointXY(args[0], args[1]);\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n   \t\t\tthis.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof gpcas.geometry.PolySimple){\n   \t\t\tthis.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n   \t\t\tvar arr  = args[0];\n   \t\t\tif ((arr.length==2)&&(arr[0] instanceof Number)&&(arr[1] instanceof Number)){\n   \t\t\t\tthis.add(arr[0] ,arr[1] )\n   \t\t\t} else {\n   \t\t\t\tfor(var i=0; i<args[0].length ; i++) {\n\t\t\t\t\tthis.add(args[0][i]);\n\t\t\t\t}\n   \t\t\t}\n   \t\t}\n   \t}\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPointXY = function(x, y) {\n    this.addPoint(new Point( x, y ));\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoint = function( p) {\n\n\n\tvar m_List = this.m_List;\n\n    if( m_List.size() == 0)\n    {\n        m_List.add(new gpcas.geometry.PolySimple());\n    }\n    (m_List.get(0)).addPoint(p);\n}\n /**\n    * Add an inner polygon to this polygon - assumes that adding polygon does not\n    * have any inner polygons.\n    *\n    * @throws IllegalStateException if the number of inner polygons is greater than\n    * zero and this polygon was designated a hole.  This would break the assumption\n    * that only simple polygons can be holes.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoly = function( p) {\n\n\tvar m_IsHole = this.m_IsHole;\n\tvar m_List = this.m_List;\n\n    if( (m_List.size() > 0) && m_IsHole )\n      {\n         alert(\"ERROR : Cannot add polys to something designated as a hole.\");\n      }\n    m_List.add( p );\n}\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolyDefault.prototype.isEmpty = function() {\n    return this.m_List.isEmpty();\n}\n /**\n    * Returns the bounding rectangle of this polygon.\n    * <strong>WARNING</strong> Not supported on complex polygons.\n    */\ngpcas.geometry.PolyDefault.prototype.getBounds = function () {\n\tvar m_List = this.m_List;\n    if( m_List.size() == 0)\n    {\n        return new Rectangle();\n    }\n    else if( m_List.size() == 1)\n    {\n         var ip= this.getInnerPoly(0);\n         return ip.getBounds();\n    }\n    else\n    {\n         console.log(\"getBounds not supported on complex poly.\");\n    }\n}\n   /**\n    * Returns the polygon at this index.\n    */\ngpcas.geometry.PolyDefault.prototype.getInnerPoly = function(polyIndex) {\n      return this.m_List.get(polyIndex);\n}\n   /**\n    * Returns the number of inner polygons - inner polygons are assumed to return one here.\n    */\ngpcas.geometry.PolyDefault.prototype.getNumInnerPoly = function() {\n\tvar m_List = this.m_List;\n      return m_List.size();\n}\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getNumPoints = function () {\n    return (this.m_List.get(0)).getNumPoints() ;\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getX = function(index) {\n      return (this.m_List.get(0)).getX(index) ;\n}\ngpcas.geometry.PolyDefault.prototype.getPoint = function(index){\n\t\treturn (this.m_List.get(0)).getPoint(index) ;\n}\n\ngpcas.geometry.PolyDefault.prototype.getPoints = function(){\n\treturn (this.m_List.get(0)).getPoints();\n}\n\n\ngpcas.geometry.PolyDefault.prototype.isPointInside = function (point) {\n\tvar m_List = this.m_List;\n   \tif (!(m_List.get(0)).isPointInside(point)) return false;\n\n\tfor (var i  = 0; i<m_List.size(); i++){\n   \t\tvar poly  = m_List.get(i);\n   \t\t\tif ((poly.isHole())&&(poly.isPointInside(point))) return false;\n   \t\t}\n   \t\treturn true;\n}\n     /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getY = function (index) {\n\tvar m_List = this.m_List;\n      return (m_List.get(0)).getY(index) ;\n}\n\n   /**\n    * Return true if this polygon is a hole.  Holes are assumed to be inner polygons of\n    * a more complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.isHole = function () {\n\tvar m_List = this.m_List;\n\tvar m_IsHole = this.m_IsHole;\n\n      if( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n      return m_IsHole ;\n}\n\n   /**\n    * Set whether or not this polygon is a hole.  Cannot be called on a complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.setIsHole = function(isHole) {\n    var m_List = this.m_List;\n\tif( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n    this.m_IsHole = isHole ;\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    */\ngpcas.geometry.PolyDefault.prototype.isContributing = function( polyIndex) {\n      var m_List = this.m_List;\n\t  return (m_List.get(polyIndex)).isContributing(0);\n}\n\n    /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if called on a complex polygon\n    */\ngpcas.geometry.PolyDefault.prototype.setContributing = function( polyIndex, contributes) {\n    var m_List = this.m_List;\n\tif( m_List.size() != 1)\n      {\n        alert( \"Only applies to polys of size 1\" );\n      }\n     (m_List.get(polyIndex)).setContributing( 0, contributes );\n}\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.union = function(p) {\n\treturn gpcas.geometry.Clip.union( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolyDefault\" );\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolyDefault.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolyDefault\");\n}\n\n   /**\n    * Return the area of the polygon in square units.\n    */\ngpcas.geometry.PolyDefault.prototype.getArea = function() {\n      var area= 0.0;\n      for( var i= 0; i < getNumInnerPoly() ; i++ )\n      {\n         var p= getInnerPoly(i);\n         var tarea = p.getArea() * (p.isHole() ? -1.0: 1.0);\n         area += tarea ;\n      }\n      return area ;\n}\n\n   // -----------------------\n   // --- Package Methods ---\n   // -----------------------\ngpcas.geometry.PolyDefault.prototype.toString = function() {\n    var res  = \"\";\n\tvar m_List = this.m_List;\n    for( var i= 0; i < m_List.size() ; i++ )\n    {\n         var p = this.getInnerPoly(i);\n         res+=(\"InnerPoly(\"+i+\").hole=\"+p.isHole());\n         var points = [];\n         for( var j= 0; j < p.getNumPoints() ; j++ )\n         {\n         \tpoints.push(new Point(p.getX(j),p.getY(j)));\n         }\n         points = ArrayHelper.sortPointsClockwise(points) ;\n\n\t\t for(var k =0 ; k< points.length ; k++) {\n\t\t\tres+=points[k].toString();\n\t\t }\n\n      }\n      return res;\n   }\n\n///////////////  Polygon   /////////////////////////////////\ngpcas.geometry.Polygon = function(){\n\tthis.maxTop ;\n\tthis.maxBottom ;\n\tthis.maxLeft ;\n\tthis.maxRight ;\n\tthis.vertices  /* of Point */;\n};\ngpcas.geometry.Polygon.prototype.fromArray = function(v) {\n\tthis.vertices = [];\n\n\tfor(var i=0 ; i<v.length ; i++) {\n\t\tvar pointArr = v[i];\n\t\tthis.vertices.push(new Point(pointArr[0],pointArr[1]));\n\t}\n}\n\n\t\t/*Normalize vertices in polygon to be ordered clockwise from most left point*/\ngpcas.geometry.Polygon.prototype.normalize = function() {\n\tvar maxLeftIndex ;\n\tvar vertices = this.vertices;\n\tvar newVertices = this.vertices;\n\n\tfor (var i  = 0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\n\t\tif ((maxTop==null)||(maxTop.y>vertex.y)||((maxTop.y==vertex.y)&&(vertex.x<maxTop.x))){\n\t\t\tmaxTop=vertex;\n\t\t}\n\t\tif ((maxBottom==null)||(maxBottom.y<vertex.y)||((maxBottom.y==vertex.y)&&(vertex.x>maxBottom.x))){\n\t\t\tmaxBottom=vertex;\n\t\t}\n \t\tif ((maxLeft==null)||(maxLeft.x>vertex.x)||((maxLeft.x==vertex.x)&&(vertex.y>maxLeft.y))){\n\t\t\tmaxLeft=vertex;\n\t\t\tmaxLeftIndex=i;\n\t\t}\n\t\tif ((maxRight==null)||(maxRight.x<vertex.x)||((maxRight.x==vertex.x)&&(vertex.y<maxRight.y))){\n\t\t\tmaxRight=vertex;\n\t\t}\n\t}\n\n\tif (maxLeftIndex>0){\n\t\tnewVertices = [];\n\t\tvar j = 0;\n\t\tfor (var i=maxLeftIndex; i<vertices.length;i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tfor (var i=0; i<maxLeftIndex; i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n\tvar reverse   = false;\n\tfor(var k=0; k<this.vertices.length ; k++) {\n\t\tvar vertex  =  this.vertices[k];\n\t    if (equals(vertex, maxBottom)){\n\t\t\treverse=true;\n\t\t\tbreak;\n\t\t} else if (equals(vertex, maxTop)){\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reverse){\n\t\tnewVertices= [];\n\t\tnewVertices[0]=vertices[0];\n\t\tvar j =1;\n\t\tfor (var i=vertices.length-1; i>0; i--){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n}\ngpcas.geometry.Polygon.prototype.getVertexIndex = function(vertex){\n\tfor (var i=0; i<this.vertices.length; i++){\n\t\tif (equals(vertices[i], vertex)){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\ngpcas.geometry.Polygon.prototype.insertVertex = function(vertex1,vertex2, newVertex){\n\tvar vertex1Index  = getVertexIndex(vertex1);\n\tvar vertex2Index  = getVertexIndex(vertex2);\n\tif ((vertex1Index==-1)||(vertex2Index==-1)){\n\t\treturn false;\n\t}\n\n\tif (vertex2Index<vertex1Index){\n\t\tvar i  = vertex1Index;\n\t\tvertex1Index=vertex2Index;\n\t\tvertex2Index=i;\n\t}\n\tif (vertex2Index==vertex1Index+1){\n\t\tvar newVertices  = [];\n\t\tfor (var i =0; i<=vertex1Index; i++){\n\t\t\tnewVertices[i]=this.vertices[i];\n\t\t}\n\t\tnewVertices[vertex2Index]=newVertex;\n\t\tfor (var i =vertex2Index; i<this.vertices.length; i++){\n\t\t\tnewVertices[i+1]=this.vertices[i];\n\t\t}\n\t\tthis.vertices=newVertices;\n\t} else if ((vertex2Index==vertices.length-1)&&(vertex1Index==0)){\n\t\tthis.vertices.push(newVertex);\n\t}\n\treturn true;\n}\ngpcas.geometry.Polygon.prototype.clone = function() {\n\tvar res = new gpcas.geometry.Polygon();\n\tres.vertices=vertices.slice(this.vertices.length-1);\n\treturn res;\n}\ngpcas.geometry.Polygon.prototype.toString = function() {\n\tvar vertices = this.vertices;\n\tvar res  = \"[\";\n\tfor (var i  =0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\t\tres+=(i>0?\",\":\"\")+\"[\"+vertex.x+\",\"+vertex.y+\"]\";\n\t}\n\tres+=\"]\";\n\treturn res;\n}\n\n\n////////////////////  PolygonNode ///////////////////////////\ngpcas.geometry.PolygonNode = function(next, x, y) {\n\n\n\tthis.active;                 /* Active flag / vertex count        */\n\tthis.hole;                /* Hole / external contour flag      */\n\tthis.v= [] ; /* Left and right vertex list ptrs   */\n\tthis.next;                   /* Pointer to next polygon contour   */\n\tthis.proxy;                  /* Pointer to actual structure used  */\n\n\t/* Make v[Clip.LEFT] and v[Clip.RIGHT] point to new vertex */\n\tvar vn= new VertexNode( x, y );\n\n\tthis.v[Clip.LEFT ] = vn ;\n\tthis.v[Clip.RIGHT] = vn ;\n\n\tthis.next = next ;\n\tthis.proxy = this ; /* Initialise proxy to point to p itself */\n\tthis.active = 1; //TRUE\n}\ngpcas.geometry.PolygonNode.prototype.add_right = function( x, y) {\n\tvar nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the right end of the polygon's vertex list */\n\t this.proxy.v[Clip.RIGHT].next= nv;\n\n\t /* Update proxy->v[Clip.RIGHT] to point to nv */\n\t this.proxy.v[Clip.RIGHT]= nv;\n}\ngpcas.geometry.PolygonNode.prototype.add_left = function( x, y) {\n\t var proxy = this.proxy;\n\n\t var nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the left end of the polygon's vertex list */\n\t nv.next= proxy.v[Clip.LEFT];\n\n\t /* Update proxy->[Clip.LEFT] to point to nv */\n\t proxy.v[Clip.LEFT]= nv;\n}\n\n\n//////////////////   PolySimple ////////////////\n\n/**\n * <code>PolySimple</code> is a simple polygon - contains only one inner polygon.\n * <p>\n * <strong>WARNING:</strong> This type of <code>Poly</code> cannot be used for an\n * inner polygon that is a hole.\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolySimple = function(){\n\t/**\n    * The list of Point objects in the polygon.\n    */\n   this.m_List= new gpcas.util.ArrayList();\n\n   /** Flag used by the Clip algorithm */\n   this.m_Contributes= true ;\n};\n\n   /**\n    * Return true if the given object is equal to this one.\n    * <p>\n    * <strong>WARNING:</strong> This method failse if the first point\n    * appears more than once in the list.\n    */\ngpcas.geometry.PolySimple.prototype.equals = function(obj) {\n  if( !(obj instanceof PolySimple) )\n  {\n\t return false;\n  }\n\n  var that= obj;\n\n  var this_num= this.m_List.size();\n  var that_num= that.m_List.size();\n  if( this_num != that_num ) return false ;\n\n\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING: This is not the greatest algorithm.  It fails if !!!\n  // !!! the first point in \"this\" poly appears more than once.    !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  if( this_num > 0)\n  {\n\t var this_x= this.getX(0);\n\t var this_y= this.getY(0);\n\t var that_first_index = -1;\n\t for( var that_index= 0; (that_first_index == -1) && (that_index < that_num) ; that_index++ )\n\t {\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\t\tif( (this_x == that_x) && (this_y == that_y) )\n\t\t{\n\t\t   that_first_index = that_index ;\n\t\t}\n\t }\n\t if( that_first_index == -1) return false ;\n\t var that_index= that_first_index ;\n\t for( var this_index= 0; this_index < this_num ; this_index++ )\n\t {\n\t\tthis_x = this.getX(this_index);\n\t\tthis_y = this.getY(this_index);\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\n\t\tif( (this_x != that_x) || (this_y != that_y) ) return false;\n\n\t\tthat_index++ ;\n\t\tif( that_index >= that_num )\n\t\t{\n\t\t   that_index = 0;\n\t\t}\n\t }\n  }\n  return true ;\n}\n\n   /**\n    * Return the hashCode of the object.\n    * <p>\n    * <strong>WARNING:</strong>Hash and Equals break contract.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    */\ngpcas.geometry.PolySimple.prototype.hashCode = function() {\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING:  This hash and equals break the contract. !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  var result= 17;\n  result = 37*result + this.m_List.hashCode();\n  return result;\n}\n\n   /**\n    * Return a string briefly describing the polygon.\n    */\ngpcas.geometry.PolySimple.prototype.toString = function() {\n    return \"PolySimple: num_points=\"+getNumPoints();\n}\n\n   // --------------------\n   // --- Poly Methods ---\n   // --------------------\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolySimple.prototype.clear = function() {\n      this.m_List.clear();\n}\n\n\ngpcas.geometry.PolySimple.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\n   \tif (args.length==2){\n\t\tthis.addPointXY(args[0] , args[1] );\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n               this.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof Poly){\n               this.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n\t\t\tfor(var k=0 ; k<args[0].length ; k++) {\n\t\t\t\tvar val = args[0][k];\n                this.add(val);\n\t\t\t}\n   \t\t}\n   \t}\n}\n\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPointXY = function(x, y) {\n    this.addPoint( new Point( x, y ) );\n}\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPoint = function(p) {\n      this.m_List.add( p );\n}\n\n   /**\n    * Throws IllegalStateexception if called\n    */\ngpcas.geometry.PolySimple.prototype.addPoly = function(p) {\n    alert(\"Cannot add poly to a simple poly.\");\n}\n\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolySimple.prototype.isEmpty = function() {\n      return this.m_List.isEmpty();\n}\n\n   /**\n    * Returns the bounding rectangle of this polygon.\n    */\ngpcas.geometry.PolySimple.prototype.getBounds = function() {\n\t  var xmin=  Number.MAX_VALUE ;\n\t  var ymin=  Number.MAX_VALUE ;\n\t  var xmax= -Number.MAX_VALUE ;\n\t  var ymax= -Number.MAX_VALUE ;\n\n      for( var i= 0; i < this.m_List.size() ; i++ )\n      {\n         var x= this.getX(i);\n         var y= this.getY(i);\n         if( x < xmin ) xmin = x;\n         if( x > xmax ) xmax = x;\n         if( y < ymin ) ymin = y;\n         if( y > ymax ) ymax = y;\n      }\n\n      return new Rectangle( xmin, ymin, (xmax-xmin), (ymax-ymin) );\n   }\n\n   /**\n    * Returns <code>this</code> if <code>polyIndex = 0</code>, else it throws\n    * IllegalStateException.\n    */\ngpcas.geometry.PolySimple.prototype.getInnerPoly = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this ;\n}\n\n   /**\n    * Always returns 1.\n    */\ngpcas.geometry.PolySimple.prototype.getNumInnerPoly = function() {\n    return 1;\n}\n\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getNumPoints = function() {\n      return this.m_List.size();\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getX = function(index) {\n    return (this.m_List.get(index)).x;\n}\n\n   /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getY = function(index) {\n    return (this.m_List.get(index)).y;\n}\n\ngpcas.geometry.PolySimple.prototype.getPoint = function(index){\n\treturn (this.m_List.get(index));\n}\n\ngpcas.geometry.PolySimple.prototype.getPoints = function() {\n\treturn this.m_List.toArray();\n}\n\ngpcas.geometry.PolySimple.prototype.isPointInside = function(point) {\n\t var points  = this.getPoints();\n\t var j  = points.length - 1;\n\t var oddNodes = false;\n\n\t for (var i  = 0; i < points.length; i++)\n\t {\n\t\t if (points[i].y < point.y && points[j].y >= point.y ||\n\t\t\t points[j].y < point.y && points[i].y >= point.y)\n\t\t {\n\t\t\t if (points[i].x +\n\t\t\t\t (point.y - points[i].y)/(points[j].y - points[i].y)*(points[j].x - points[i].x) < point.x)\n\t\t\t {\n\t\t\t\t oddNodes = !oddNodes;\n\t\t\t}\n\t\t }\n\t\t j = i;\n\t }\n\t return oddNodes;\n}\n\n\n   /**\n    * Always returns false since PolySimples cannot be holes.\n    */\ngpcas.geometry.PolySimple.prototype.isHole = function() {\n      return false ;\n}\n\n   /**\n    * Throws IllegalStateException if called.\n    */\ngpcas.geometry.PolySimple.prototype.setIsHole =function(isHole) {\n    alert(\"PolySimple cannot be a hole\");\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.isContributing = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this.m_Contributes ;\n}\n\n   /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.setContributing = function( polyIndex, contributes) {\n      if( polyIndex != 0)\n      {\n         alert(\"PolySimple only has one poly\");\n      }\n      this.m_Contributes = contributes ;\n   }\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( this, p,\"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.union = function(p) {\n      return gpcas.geometry.Clip.union( this, p, \"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolySimple\");\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolySimple.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolySimple\");\n}\n\n   /**\n    * Returns the area of the polygon.\n    * <p>\n    * The algorithm for the area of a complex polygon was take from\n    * code by Joseph O'Rourke author of \" Computational Geometry in C\".\n    */\ngpcas.geometry.PolySimple.prototype.getArea = function() {\n      if( this.getNumPoints() < 3)\n      {\n         return 0.0;\n      }\n      var ax= this.getX(0);\n      var ay= this.getY(0);\n\n      var area= 0.0;\n      for( var i= 1; i < (this.getNumPoints()-1) ; i++ )\n      {\n         var bx= this.getX(i);\n         var by= this.getY(i);\n         var cx= this.getX(i+1);\n         var cy= this.getY(i+1);\n         var tarea= ((cx - bx)*(ay - by)) - ((ax - bx)*(cy - by));\n         area += tarea ;\n      }\n      area = 0.5*Math.abs(area);\n      return area ;\n   }\n\n  /////////////////////// Rectangle  ///////////////////\ngpcas.geometry.Rectangle = function(_x, _y, _w, _h) {\n\tthis.x = _x;\n\tthis.y = _y;\n\tthis.w = _w;\n\tthis.h = _h;\n}\ngpcas.geometry.Rectangle.prototype.getMaxY = function(){\n\treturn this.y+this.h;\n}\ngpcas.geometry.Rectangle.prototype.getMinY = function(){\n\treturn this.y;\n}\ngpcas.geometry.Rectangle.prototype.getMaxX = function() {\n\treturn this.x+this.w;\n}\ngpcas.geometry.Rectangle.prototype.getMinX = function(){\n\treturn this.x;\n}\ngpcas.geometry.Rectangle.prototype.toString = function(){\n\treturn \"[\"+x.toString()+\" \"+y.toString()+\" \"+w.toString()+\" \"+h.toString()+\"]\";\n}\n\n/////////////////// ScanBeamTree //////////////////////\ngpcas.geometry.ScanBeamTree = function(yvalue) {\n\tthis.y = yvalue;         /* Scanbeam node y value             */\n\tthis.less;         /* Pointer to nodes with lower y     */\n\tthis.more;         /* Pointer to nodes with higher y    */\n}\n\n///////////////////////// ScanBeamTreeEntries /////////////////\ngpcas.geometry.ScanBeamTreeEntries = function(){\n\tthis.sbt_entries=0;\n\tthis.sb_tree;\n};\ngpcas.geometry.ScanBeamTreeEntries.prototype.build_sbt = function() {\n\tvar sbt= [];\n\n\tvar entries= 0;\n\tentries = this.inner_build_sbt( entries, sbt, this.sb_tree );\n\n\t//console.log(\"SBT = \"+this.sbt_entries);\n\n\tif( entries != this.sbt_entries )\n\t{\n\t//console.log(\"Something went wrong buildign sbt from tree.\");\n\t}\n\treturn sbt ;\n}\ngpcas.geometry.ScanBeamTreeEntries.prototype.inner_build_sbt = function( entries, sbt, sbt_node) {\n\tif( sbt_node.less != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.less);\n\t }\n\t sbt[entries]= sbt_node.y;\n\t entries++;\n\t if( sbt_node.more != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.more );\n\t }\n\t return entries ;\n}\n\n///////////////////////////  StNode\nStNode = gpcas.geometry.StNode = function( edge, prev) {\n\tthis.edge;         /* Pointer to AET edge               */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.prev;         /* Previous edge in sorted list      */\n\n\tthis.edge = edge ;\n\t this.xb = edge.xb ;\n\t this.xt = edge.xt ;\n\t this.dx = edge.dx ;\n\t this.prev = prev ;\n}\n\n/////////////////////   TopPolygonNode /////////////////\ngpcas.geometry.TopPolygonNode = function(){\n\tthis.top_node;\n};\nTopPolygonNode = gpcas.geometry.TopPolygonNode;\n\ngpcas.geometry.TopPolygonNode.prototype.add_local_min = function( x, y) {\n\t var existing_min= this.top_node;\n\t this.top_node = new gpcas.geometry.PolygonNode( existing_min, x, y );\n\t return this.top_node ;\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_left = function( p, q) {\n /* Label contour as a hole */\n q.proxy.hole = true ;\n var top_node = this.top_node;\n\n if (p.proxy != q.proxy) {\n\t/* Assign p's vertex list to the left end of q's list */\n\tp.proxy.v[Clip.RIGHT].next= q.proxy.v[Clip.LEFT];\n\tq.proxy.v[Clip.LEFT]= p.proxy.v[Clip.LEFT];\n\n\t/* Redirect any p.proxy references to q.proxy */\n\tvar target= p.proxy ;\n\tfor(var node= top_node; (node != null); node = node.next)\n\t{\n\t   if (node.proxy == target)\n\t   {\n\t\t  node.active= 0;\n\t\t  node.proxy= q.proxy;\n\t   }\n\t}\n }\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_right = function( p, q) {\n\t var top_node = this.top_node;\n\t /* Label contour as external */\n\t q.proxy.hole = false ;\n\n\t if (p.proxy != q.proxy)\n\t {\n\t\t/* Assign p's vertex list to the right end of q's list */\n\t\tq.proxy.v[Clip.RIGHT].next= p.proxy.v[Clip.LEFT];\n\t\tq.proxy.v[Clip.RIGHT]= p.proxy.v[Clip.RIGHT];\n\n\t\t/* Redirect any p->proxy references to q->proxy */\n\t\tvar target= p.proxy ;\n\t\tfor (var node = top_node ; (node != null ); node = node.next)\n\t\t{\n\t\t   if (node.proxy == target)\n\t\t   {\n\t\t\t  node.active = 0;\n\t\t\t  node.proxy= q.proxy;\n\t\t   }\n\t\t}\n\t }\n  }\ngpcas.geometry.TopPolygonNode.prototype.count_contours = function() {\nvar nc= 0;\n\nfor ( var polygon= this.top_node; (polygon != null) ; polygon = polygon.next)\n\t {\n\t\tif (polygon.active != 0)\n\t\t{\n\t\t   /* Count the vertices in the current contour */\n\t\t   var nv= 0;\n\t\t   for (var v= polygon.proxy.v[Clip.LEFT]; (v != null); v = v.next)\n\t\t   {\n\t\t\t  nv++;\n\t\t   }\n\n\t\t   /* Record valid vertex counts in the active field */\n\t\t   if (nv > 2)\n\t\t   {\n\t\t\t  polygon.active = nv;\n\t\t\t  nc++;\n\t\t   }\n\t\t   else\n\t\t   {\n\t\t\t  /* Invalid contour: just free the heap */\n//                  VertexNode nextv = null ;\n//                  for (VertexNode v= polygon.proxy.v[Clip.LEFT]; (v != null); v = nextv)\n//                  {\n//                     nextv= v.next;\n//                     v = null ;\n//                  }\n\t\t\t  polygon.active= 0;\n\t\t   }\n\t\t}\n\t }\n\t return nc;\n  }\ngpcas.geometry.TopPolygonNode.prototype.getResult = function(polyClass) {\n\nvar top_node = this.top_node;\nvar result= gpcas.geometry.Clip.createNewPoly( polyClass );\n//console.log(polyClass);\n\n\nvar num_contours = this.count_contours();\n\nif (num_contours > 0)\n\t {\n\t\tvar c= 0;\n\t\tvar npoly_node= null ;\n\t\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t\t{\n\t\t   npoly_node = poly_node.next;\n\t\t   if (poly_node.active != 0)\n\t\t   {\n\n\t\t\t  var poly = result ;\n\n\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t poly = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\t\t  }\n\t\t\t  if( poly_node.proxy.hole )\n\t\t\t  {\n\t\t\t\t poly.setIsHole( poly_node.proxy.hole );\n\t\t\t  }\n\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  // --- This algorithm puts the verticies into the poly in reverse order ---\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t\t  {\n\t\t\t\t poly.add( vtx.x, vtx.y );\n\t\t\t  }\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t result.addPoly( poly );\n\t\t\t  }\n\t\t\t  c++;\n\t\t   }\n\t\t}\n\n\t\t// -----------------------------------------\n\t\t// --- Sort holes to the end of the list ---\n\t\t// -----------------------------------------\n\t\tvar orig= result ;\n\t\tresult = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( !inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t }\n\t return result ;\n  }\ngpcas.geometry.TopPolygonNode.prototype.print = function() {\n    //console.log(\"---- out_poly ----\");\n\tvar top_node = this.top_node;\n    var c= 0;\n    var npoly_node= null ;\n\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t {\n\t\t//console.log(\"contour=\"+c+\"  active=\"+poly_node.active+\"  hole=\"+poly_node.proxy.hole);\n\t\tnpoly_node = poly_node.next;\n\t\tif (poly_node.active != 0)\n\t\t{\n\t\t   var v=0;\n\t\t   for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t   {\n\t\t\t  //console.log(\"v=\"+v+\"  vtx.x=\"+vtx.x+\"  vtx.y=\"+vtx.y);\n\t\t   }\n\t\t   c++;\n\t\t}\n\t }\n}\n\n  ///////////    VertexNode  ///////////////\ngpcas.geometry.VertexNode = function( x, y) {\n\tthis.x;    // X coordinate component\n\tthis.y;    // Y coordinate component\n\tthis.next; // Pointer to next vertex in list\n\n\tthis.x = x ;\n    this.y = y ;\n    this.next = null ;\n}\nVertexNode = gpcas.geometry.VertexNode;\n\n/////////////   VertexType   /////////////\ngpcas.geometry.VertexType = function(){};\ngpcas.geometry.VertexType.NUL=  0; /* Empty non-intersection            */\ngpcas.geometry.VertexType.EMX=  1; /* External maximum                  */\ngpcas.geometry.VertexType.ELI=  2; /* External left intermediate        */\ngpcas.geometry.VertexType.TED=  3; /* Top edge                          */\ngpcas.geometry.VertexType.ERI=  4; /* External right intermediate       */\ngpcas.geometry.VertexType.RED=  5; /* Right edge                        */\ngpcas.geometry.VertexType.IMM=  6; /* Internal maximum and minimum      */\ngpcas.geometry.VertexType.IMN=  7; /* Internal minimum                  */\ngpcas.geometry.VertexType.EMN=  8; /* External minimum                  */\ngpcas.geometry.VertexType.EMM=  9; /* External maximum and minimum      */\ngpcas.geometry.VertexType.LED= 10; /* Left edge                         */\ngpcas.geometry.VertexType.ILI= 11; /* Internal left intermediate        */\ngpcas.geometry.VertexType.BED= 12; /* Bottom edge                       */\ngpcas.geometry.VertexType.IRI= 13; /* Internal right intermediate       */\ngpcas.geometry.VertexType.IMX= 14; /* Internal maximum                  */\ngpcas.geometry.VertexType.FUL= 15; /* Full non-intersection             */\ngpcas.geometry.VertexType.getType = function( tr, tl ,br ,bl) {\n    return tr + (tl << 1) + (br << 2) + (bl << 3);\n}\n\nVertexType = gpcas.geometry.VertexType;\n\n////////////////// WeilerAtherton  /////////////\ngpcas.geometry.WeilerAtherton = function(){};\n\ngpcas.geometry.WeilerAtherton.prototype.merge = function(p1,p2) {\n\tp1=p1.clone();\n\tp2=p2.clone();\n}\n","'use strict';\n\n/*jshint -W072 */\nvar intersect = function (a10, a11, a20, a21, b10, b11, b20, b21) {\n    var ua_t = (b20 - b10) * (a11 - b11) - (b21 - b11) * (a10 - b10);\n    var ub_t = (a20 - a10) * (a11 - b11) - (a21 - a11) * (a10 - b10);\n    var u_b = (b21 - b11) * (a20 - a10) - (b20 - b10) * (a21 - a11);\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\nfunction Cell(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.items = [];\n}\n\nCell.prototype.insert = function(item) {\n    if (\n        (item.fromX >= this.x && item.fromY >= this.y && item.toX <= this.x + this.width && item.toY <= this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x+this.width, this.y) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x+this.width, this.y, this.x+this.width, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y+this.height, this.x+this.width, this.y+this.height)\n    ) {\n        this.items.push(item);\n    }\n};\n\nexports = module.exports = Cell;\n","'use strict';\n\nvar Cell = require('./cell');\nvar DoublyLinkedList = require('../../linkedlist/doublylinkedlist');\n\nfunction Grid(bounds, rows, cols) {\n    this.bounds = bounds;\n    this.rows = rows;\n    this.cols = cols;\n    this.cellX = this.bounds.width / this.cols;\n    this.cellY = this.bounds.height / this.rows;\n    this.cells = [];\n    this.out = new DoublyLinkedList();\n    for( var col = 0;col<this.cols;col++) {\n        this.cells[col] = [];\n        for ( var row=0;row<this.rows;row++) {\n            this.cells[col][row] = new Cell(col*this.cellX, row*this.cellY, this.cellX, this.cellY);\n        }\n    }\n}\n\nGrid.prototype.insert = function(item) {\n    if (item instanceof Array) {\n        var i = 0,\n            n = item.length;\n            while (i<n) {\n                this.insert(item);\n                i++;\n            }\n    } else {\n        for( var col = 0;col<this.cols;col++) {\n            for ( var row=0;row<this.rows;row++) {\n                this.cells[col][row].insert(item);\n            }\n        }\n    }\n};\n\nGrid.prototype.addOut = function(items) {\n    var i = 0,\n        n = items.length;\n    while (i<n) {\n        this.out.add(items[i]);\n        i++;\n    }\n};\n\nGrid.prototype.retrieve = function(item) {\n    // figure out cells\n    var nx = ((item.x%this.cellX) + item.width) > this.cellX ? true : false,\n        ny = ((item.y%this.cellY) + item.height) > this.cellY ? true : false,\n        x = Math.floor(item.x / this.cellX),\n        y = Math.floor(item.y / this.cellY);\n    this.out.clear();\n\n    this.addOut(this.cells[x][y].items);\n    if (nx) {\n        this.addOut(this.cells[x+1][y].items);\n    }\n    if (ny) {\n        this.addOut(this.cells[x][y+1].items);\n    }\n    if (nx && ny) {\n        this.addOut(this.cells[x+1][y+1].items);\n    }\n    return this.out;\n};\n\nexports = module.exports = Grid;\n","module.exports = {\n  Grid: require('./grid'),\n  Cell: require('./cell')\n};\n","module.exports = {\n  Vector2: require('./vector2'),\n  LineSegment2: require('./linesegment2'),\n  Triangle2: require('./triangle2'),\n  Polygon2: require('./polygon2'),\n  RegularPolygon2: require('./regularpolygon2'),\n  gpc: require('./gpc'),\n  VisibilityPolygon: require('./visibilitypolygon'),\n\n  Grid: require('./grid'),\n  QuadTree: require('./quadtree')\n};\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\n\nexports = module.exports = LineSegment2;\n\nvar cache = [];\nvar created = 0;\n\nfunction LineSegment2 (start, end) {\n\tif (!(this instanceof LineSegment2)) {\n\t\tvar l = cache.pop();\n\t\tif (!l) {\n\t\t\tl = new LineSegment2(start, end);\n\t\t\tcreated++;\n\t\t} else {\n\t\t\tl.start.free();\n\t\t\tl.end.free();\n\t\t\tl.set(start, end);\n\t\t}\n\t\treturn l;\n\t}\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n}\n\nLineSegment2.getStats = function() {\n\treturn [cache.length, created];\n};\n\nLineSegment2.prototype.set = function (start, end) {\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n\treturn this;\n};\n\nLineSegment2.prototype.free = function () {\n\tcache.push(this);\n};\n\nLineSegment2.prototype.lengthSq = function () {\n\treturn this.start.distanceSq(this.end);\n};\n\nLineSegment2.prototype.length = function() {\n\treturn this.start.distance(this.end);\n};\n\nLineSegment2.prototype.closestPoint = function (point, full) {\n\tvar l2 = this.lengthSq();\n\tif (l2 === 0) {\n\t\treturn this.start.clone();\n\t}\n\tvar t = ((point.x - this.start.x) * (this.end.x - this.start.x) + (point.y - this.start.y)*(this.end.y - this.start.y)) / l2;\n\tif (!full) {\n\t\tif (t < 0) {\n\t\t\treturn this.start.clone();\n\t\t}\n\t\tif (t > 1) {\n\t\t\treturn this.end.clone();\n\t\t}\n\t}\n\treturn Vector2(this.start.x + t * (this.end.x-this.start.x), this.start.y + t * (this.end.y - this.start.y));\n};\n\nLineSegment2.prototype.distanceSq = function (point, full) {\n\tvar c = this.closestPoint(point, full);\n\tvar d = point.distanceSq(c);\n\tc.free();\n\treturn d;\n};\n\nLineSegment2.prototype.distance = function (point, full) {\n\treturn Math.sqrt(this.distanceSq(point, full));\n};\n\nLineSegment2.prototype.intersect = function (l, full) {\n\tvar u_b = (l.end.y - l.start.y) * (this.end.x - this.start.x) - (l.end.x - l.start.x) * (this.end.y - this.start.y);\n\tif (u_b !== 0) {\n\t\tvar ua_t = (l.end.x - l.start.x) * (this.start.y - l.start.y) - (l.end.y - l.start.y) * (this.start.x - l.start.x);\n\t\tvar ub_t = (this.end.x - this.start.x) * (this.start.y - l.start.y) - (this.end.y - this.start.y) * (this.start.x - l.start.x);\n\t\tvar ua = ua_t / u_b;\n\t\tvar ub = ub_t / u_b;\n\t\tif (full || (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)) {\n\t\t\treturn Vector2(this.start.x - ua * (this.start.x - this.end.x), this.start.y - ua * (this.start.y - this.end.y));\n\t\t}\n\t} else {\n\t\treturn null; // perpendicular\n\t}\n\treturn false;\n};\n\nLineSegment2.prototype.intersectCircle = function (point, radius, full) {\n\tvar r2 = radius*radius;\n\tvar closest = this.closestPoint(point, full);\n\tvar dist_v = point.clone().subtract(closest);\n\tvar len2 = dist_v.distanceSq();\n\tdist_v.free();\n\tif (len2 < r2) {\n\t\treturn closest;\n\t} else {\n\t\tclosest.free();\n\t\treturn false;\n\t}\n};\n\nLineSegment2.prototype.equals = function(other) {\n\treturn (this.start === other.start && this.end === other.end);\n};\n\nLineSegment2.prototype.inverse = function() {\n\treturn LineSegment2(this.end.clone(), this.start.clone());\n};\n\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\nvar LineSegment2 = require('./linesegment2');\nvar epsilon = 0.0000001;\n\nexports = module.exports = Polygon2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Polygon2 (points) {\n    if (!(this instanceof Polygon2)) {\n        var p = cache.pop();\n        if (!p) {\n            p = new Polygon2(points);\n            created++;\n        } else {\n            p.freePoints();\n            p.set(points);\n        }\n        return p;\n    }\n    this.points = points || [];\n}\n\nPolygon2.fromArray = function (points)\n{\n    var p = Polygon2();\n    for (var i = 0;i<points.length; i++) {\n        p.add(Vector2.fromArray(points[i]));\n    }\n    return p;\n};\n\nPolygon2.getStats = function() {\n    return [cache.length, created];\n};\n\nPolygon2.prototype.free = function ()\n{\n    this.freePoints();\n    cache.push(this);\n};\n\nPolygon2.prototype.freePoints = function ()\n{\n    var p = this.points.pop();\n    while (p) {\n        p.free();\n        p = this.points.pop();\n    }\n    return this;\n};\n\nPolygon2.prototype.set = function (points)\n{\n    this.points = points || [];\n    return this;\n};\n\nPolygon2.prototype.add = function (point)\n{\n    this.points.push(point);\n    return this;\n};\n\nPolygon2.prototype.translate = function (vec)\n{\n    for ( var i = 0; i<this.points.length;i++) {\n        this.points[i].add(vec);\n    }\n    return this;\n};\n\nPolygon2.prototype.rotate = function (angle, origin)\n{\n    for (var i = 0; i<this.points.length;i++) {\n        this.points[i].rotate(angle, origin);\n    }\n    return this;\n};\n\nPolygon2.prototype.containsPoint = function (point)\n{\n    var inside = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n\n        var intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n\nPolygon2.prototype.intersectsLine = function (line, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    var intersect = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n        tempLine.start.set(xi, yi);\n        tempLine.end.set(xj, yj);\n        var is = tempLine.intersect(line);\n        if (is) {\n            if (ignorePoints && (this.points[i].isEqualEpsilon(is) || this.points[j].isEqualEpsilon(is) || line.start.isEqualEpsilon(is) || line.end.isEqualEpsilon(is) )) {\n                // special perpendicular test\n                var a = this.points[i].clone().subtract(this.points[j]).normalize();\n                var aa = a.angle();\n                a.copy(line.start).subtract(line.end).normalize();\n                var bb = a.angle();\n                a.free();\n                is.free();\n                if (Math.abs(aa - bb) < epsilon) {\n                    intersect = true;\n                    break;\n                }\n                continue;\n            }\n            is.free();\n            intersect = true;\n            break;\n        }\n    }\n    tempLine.free();\n    return intersect;\n};\n\n\nPolygon2.prototype.intersectsTriangle = function (triangle, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    tempLine.start.copy(triangle.v0);\n    tempLine.end.copy(triangle.v1);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v1);\n    tempLine.end.copy(triangle.v2);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v2);\n    tempLine.end.copy(triangle.v0);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n    return false;\n};\n\nPolygon2.prototype.AABB = function()\n{\n    var min = this.points[0].clone();\n    var max = this.points[0].clone();\n\n    for (var i = 1; i< this.points.length; i++) {\n        var p = this.points[i];\n        if ( p.x < min.x ) {\n            min.x = p.x;\n        } else if ( p.x > max.x ) {\n            max.x = p.x;\n        }\n        if ( p.y < min.y ) {\n            min.y = p.y;\n        } else if ( p.y > max.y ) {\n            max.y = p.y;\n        }\n    }\n    return [min, max];\n};\n\n// negative = CCW\nPolygon2.prototype.winding = function() {\n    return this.area() > 0;\n};\n\nPolygon2.prototype.rewind = function(cw) {\n    cw = !!cw;\n    var winding = this.winding();\n    if (winding !== cw) {\n        this.points.reverse();\n    }\n    return this;\n};\n\nPolygon2.prototype.area = function() {\n    var area = 0;\n    var first = this.points[0];\n    var p1 = Vector2();\n    var p2 = Vector2();\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        p1.copy(first).subtract(this.points[i]);\n        p2.copy(first).subtract(this.points[j]);\n        area += p1.cross(p2);\n    }\n    p1.free();\n    p2.free();\n    return area/2;\n};\n\nPolygon2.prototype.clean = function(distance)\n{\n    var p1 = Vector2();\n    var newpoints = [];\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var length = p1.copy(this.points[i]).subtract(this.points[j]).length();\n        if (length > distance) {\n            newpoints.push(this.points[i]);\n        } else {\n            this.points[i].free();\n        }\n    }\n    this.points = newpoints;\n};\n\nPolygon2.prototype.toArray = function ()\n{\n    var ret = [];\n    for (var i = 0; i< this.points.length; i++) {\n        ret.push(this.points[i].toArray());\n    }\n    return ret;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\nvar PointNode = require('./pointnode');\n\nfunction BoundsNode(bounds, depth, maxChildren, maxDepth) {\n    PointNode.call(this, bounds, depth, maxChildren, maxDepth);\n    this._stuckChildren = [];\n}\n\nBoundsNode.prototype = new PointNode();\nBoundsNode.prototype._classConstructor = BoundsNode;\nBoundsNode.prototype._stuckChildren = null;\n\n//we use this to collect and conctenate items being retrieved. This way\n//we dont have to continuously create new Array instances.\n//Note, when returned from QuadTree.retrieve, we then copy the array\nBoundsNode.prototype._out = [];\n\nBoundsNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        //todo: make _bounds bounds\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            this.nodes[index].insert(item);\n\n        } else {\n            this._stuckChildren.push(item);\n        }\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nBoundsNode.prototype.getChildren = function () {\n    return this.children.concat(this._stuckChildren);\n};\n\nBoundsNode.prototype.retrieve = function (item) {\n    var out = this._out;\n    out.length = 0;\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            out.push.apply(out, this.nodes[index].retrieve(item));\n        } else {\n            //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n            if (item.x <= this.nodes[PointNode.TOP_RIGHT]._bounds.x) {\n                if (item.y <= this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_LEFT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_LEFT].retrieve(item));\n                }\n            }\n\n            if (item.x + item.width > this.nodes[PointNode.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                if (item.y <= this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_RIGHT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_RIGHT].retrieve(item));\n                }\n            }\n        }\n    }\n\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n\n    return out;\n};\n\n//Returns all contents of node.\nBoundsNode.prototype.getAllContent = function () {\n    var out = this._out;\n    if (this.nodes.length) {\n\n        var i;\n        for (i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].getAllContent();\n        }\n    }\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n    return out;\n};\n\nBoundsNode.prototype.clear = function () {\n\n    this._stuckChildren.length = 0;\n\n    //array\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    if (!len) {\n        return;\n    }\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    //array\n    this.nodes.length = 0;\n\n    //we could call the super clear function but for now, im just going to inline it\n    //call the hidden super.clear, and make sure its called with this = this instance\n    //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n};\n\nexports = module.exports = BoundsNode;\n","module.exports = {\n  QuadTree: require('./quadtree'),\n  PointNode: require('./pointnode'),\n  BoundsNode: require('./boundsnode')  \n};\n","'use strict';\n\nfunction PointNode(bounds, depth, maxDepth, maxChildren) {\n    this._bounds = bounds;\n    this.children = [];\n    this.nodes = [];\n\n    if (maxChildren) {\n        this._maxChildren = maxChildren;\n    }\n\n    if (maxDepth) {\n        this._maxDepth = maxDepth;\n    }\n\n    if (depth) {\n        this._depth = depth;\n    }\n}\n\n//subnodes\nPointNode.prototype.nodes = null;\nPointNode.prototype._classConstructor = PointNode;\n\n//children contained directly in the node\nPointNode.prototype.children = null;\nPointNode.prototype._bounds = null;\n\n//read only\nPointNode.prototype._depth = 0;\n\nPointNode.prototype._maxChildren = 4;\nPointNode.prototype._maxDepth = 4;\n\nPointNode.TOP_LEFT = 0;\nPointNode.TOP_RIGHT = 1;\nPointNode.BOTTOM_LEFT = 2;\nPointNode.BOTTOM_RIGHT = 3;\n\n\nPointNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        this.nodes[index].insert(item);\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nPointNode.prototype.retrieve = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        return this.nodes[index].retrieve(item);\n    }\n\n    return this.children;\n};\n\nPointNode.prototype._findIndex = function (item) {\n    var b = this._bounds;\n    var left = (item.x > b.x + b.width / 2) ? false : true;\n    var top = (item.y > b.y + b.height / 2) ? false : true;\n\n    //top left\n    var index = PointNode.TOP_LEFT;\n    if (left) {\n        //left side\n        if (!top) {\n            //bottom left\n            index = PointNode.BOTTOM_LEFT;\n        }\n    } else {\n        //right side\n        if (top) {\n            //top right\n            index = PointNode.TOP_RIGHT;\n        } else {\n            //bottom right\n            index = PointNode.BOTTOM_RIGHT;\n        }\n    }\n\n    return index;\n};\n\n\nPointNode.prototype.subdivide = function () {\n    var depth = this._depth + 1;\n\n    var bx = this._bounds.x;\n    var by = this._bounds.y;\n\n    //floor the values\n    var b_w_h = (this._bounds.width / 2) | 0; //todo: Math.floor?\n    var b_h_h = (this._bounds.height / 2) | 0;\n    var bx_b_w_h = bx + b_w_h;\n    var by_b_h_h = by + b_h_h;\n\n    //top left\n    this.nodes[PointNode.TOP_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //top right\n    this.nodes[PointNode.TOP_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //bottom left\n    this.nodes[PointNode.BOTTOM_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n\n    //bottom right\n    this.nodes[PointNode.BOTTOM_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n};\n\nPointNode.prototype.clear = function () {\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    this.nodes.length = 0;\n};\n\n\nexports = module.exports = PointNode;\n","'use strict';\n\nvar PointNode = require('./pointnode'),\n    BoundsNode = require('./boundsnode');\n\n/**\n* QuadTree data structure.\n* @class QuadTree\n* @constructor\n* @param {Object} An object representing the bounds of the top level of the QuadTree. The object\n* should contain the following properties : x, y, width, height\n* @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds\n* (width / height)(false). Default value is false.\n* @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n* @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n**/\nfunction QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n    var node;\n    if (pointQuad) {\n        node = new PointNode(bounds, 0, maxDepth, maxChildren);\n    } else {\n        node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n    }\n\n    this.root = node;\n}\n\n/**\n* The root node of the QuadTree which covers the entire area being segmented.\n* @property root\n* @type Node\n**/\nQuadTree.prototype.root = null;\n\n\n/**\n* Inserts an item into the QuadTree.\n* @method insert\n* @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y\n* properties that represents its position in 2D space.\n**/\nQuadTree.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            len = item.length;\n        while (i<len) {\n            this.root.insert(item[i]);\n            i++;\n        }\n    } else {\n        this.root.insert(item);\n    }\n};\n\n/**\n* Clears all nodes and children from the QuadTree\n* @method clear\n**/\nQuadTree.prototype.clear = function () {\n    this.root.clear();\n};\n\n/**\n* Retrieves all items / points in the same node as the specified item / point. If the specified item\n* overlaps the bounds of a node, then all children in both nodes will be returned.\n* @method retrieve\n* @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n* with dimensions (x, y, width, height) properties.\n**/\nQuadTree.prototype.retrieve = function (item) {\n    //get a copy of the array of items\n    return this.root.retrieve(item);\n    // var out = this.root.retrieve(item).slice(0);\n    // return out;\n};\n\nexports = module.exports = QuadTree;\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2'),\n    Polygon2 = require('./polygon2');\n\nexports = module.exports = RegularPolygon2;\n\nfunction RegularPolygon2 (radius,sides, center)\n{\n    center = center || Vector2();\n\n    if (!sides || sides < 2) {\n        sides = 3;\n    }\n    if (!radius || radius <= 0) {\n        radius = 1;\n    }\n\n    var p = Polygon2();\n    for ( var i = 0; i < sides; i++) {\n        p.add(Vector2( center.x + radius * Math.cos( (i * 2 * Math.PI / sides) + 0.25*Math.PI), center.y + radius * Math.sin((i * 2 * Math.PI / sides) + 0.25*Math.PI)));\n    }\n    return p;\n}\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nexports = module.exports = Triangle2;\n\nvar epsilon = 0.0000001;\nvar cache = [];\nvar created = 0;\n\nfunction Triangle2 (v0, v1, v2) {\n    if (!(this instanceof Triangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Triangle2(v0, v1, v2);\n            created++;\n        } else {\n            v.set(v0, v1, v2);\n            //v.calcCircumcircle();\n        }\n        return v;\n    }\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    /*\n    this.center = Vector2();\n    this.radius = 0;\n    this.radius_squared = 0;\n\n    this.calcCircumcircle();\n    */\n}\n\nTriangle2.getStats = function() {\n    return [cache.length, created];\n};\n\nTriangle2.prototype.free = function ()\n{\n    cache.push(this);\n};\n\n\nTriangle2.prototype.set = function (v0, v1, v2)\n{\n    this.v0.free();\n    this.v1.free();\n    this.v2.free();\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    return this;\n};\n\nTriangle2.prototype.translate = function (vec)\n{\n    this.v0.add(vec);\n    this.v1.add(vec);\n    this.v2.add(vec);\n    return this;\n};\n\nTriangle2.prototype.calcCircumcircle = function() {\n    // From: http://www.exaflop.org/docs/cgafaq/cga1.html\n\n    var A = this.v1.x - this.v0.x;\n    var B = this.v1.y - this.v0.y;\n    var C = this.v2.x - this.v0.x;\n    var D = this.v2.y - this.v0.y;\n\n    var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);\n    var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);\n\n    var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));\n\n    var dx, dy;\n\n    if (Math.abs(G) < epsilon) {\n        // Collinear - find extremes and use the midpoint\n\n        var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);\n        var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);\n        var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);\n        var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);\n\n        this.center.set((minx + maxx) / 2, (miny + maxy) / 2);\n\n        dx = this.center.x - minx;\n        dy = this.center.y - miny;\n    } else {\n        var cx = (D * E - B * F) / G;\n        var cy = (A * F - C * E) / G;\n\n        this.center.set(cx, cy);\n\n        dx = this.center.x - this.v0.x;\n        dy = this.center.y - this.v0.y;\n    }\n\n    this.radius_squared = dx * dx + dy * dy;\n    this.radius = Math.sqrt(this.radius_squared);\n};\n\nTriangle2.prototype.inCircumcircle = function(v) {\n    var dx = this.center.x - v.x;\n    var dy = this.center.y - v.y;\n    var dist_squared = dx * dx + dy * dy;\n\n    return (dist_squared <= this.radius_squared);\n};\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\nexports = module.exports = Vector2;\n\nvar epsilon = 0.0000001;\nvar degrees = 180 / Math.PI;\n\nvar cache = [];\nvar created = 0;\n\nfunction Vector2 (x, y) {\n    if (!(this instanceof Vector2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Vector2(x || 0, y || 0);\n            created++;\n        } else {\n            v.set(x, y);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n}\n\nVector2.getStats = function() {\n    return [cache.length, created];\n};\n\nVector2.fromArray = function (arr) {\n    return Vector2(arr[0] || 0, arr[1] || 0);\n};\n\nVector2.fromObject = function (obj) {\n    return Vector2(obj.x || 0, obj.y || 0);\n};\n\nVector2.prototype.set = function (x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n};\n\nVector2.prototype.free = function () {\n    cache.push(this);\n};\n\nVector2.prototype.add = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nVector2.prototype.addScalar = function (scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    return this;\n};\n\n\nVector2.prototype.subtract = function (vec) {\n    this.x -= vec.x;\n    this.y -= vec.y;\n    return this;\n};\n\nVector2.prototype.subtractScalar = function (scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n};\n\n\nVector2.prototype.divide = function (vec) {\n    this.x /= vec.x;\n    this.y /= vec.y;\n    return this;\n};\n\nVector2.prototype.multiply = function (vec) {\n    this.x *= vec.x;\n    this.y *= vec.y;\n    return this;\n};\n\nVector2.prototype.multiplyScalar = function (scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n};\n\nVector2.prototype.normalize = function () {\n    var length = this.length();\n\n    if (length === 0) {\n        this.x = 0;\n        this.y = 0;\n    } else {\n        this.x /= length;\n        this.y /= length;\n    }\n    return this;\n};\n\nVector2.prototype.clone = function () {\n    return Vector2(this.x, this.y);\n};\n\nVector2.prototype.copy = function (vec) {\n    this.x = vec.x;\n    this.y = vec.y;\n    return this;\n};\n\nVector2.prototype.zero = function () {\n    this.x = this.y = 0;\n    return this;\n};\n\nVector2.prototype.dot = function (vec) {\n    return this.x * vec.x + this.y * vec.y;\n};\n\nVector2.prototype.cross = function (vec) {\n    return (this.x * vec.y ) - (this.y * vec.x );\n};\n\nVector2.prototype.projectOnto = function (vec) {\n    var coeff = ( (this.x * vec.x)+(this.y * vec.y) ) / ((vec.x*vec.x)+(vec.y*vec.y));\n    this.x = coeff * vec.x;\n    this.y = coeff * vec.y;\n    return this;\n};\n\n\nVector2.prototype.horizontalAngle = function () {\n    return Math.atan2(this.y, this.x);\n};\n\nVector2.prototype.horizontalAngleDeg = function () {\n    return radian2degrees(this.horizontalAngle());\n};\n\nVector2.prototype.verticalAngle = function () {\n    return Math.atan2(this.x, this.y);\n};\n\nVector2.prototype.verticalAngleDeg = function () {\n    return radian2degrees(this.verticalAngle());\n};\n\nVector2.prototype.angle = Vector2.prototype.horizontalAngle;\nVector2.prototype.angleDeg = Vector2.prototype.horizontalAngleDeg;\nVector2.prototype.direction = Vector2.prototype.horizontalAngle;\n\nVector2.prototype.rotate = function (angle, origin) {\n    var ox = 0,\n        oy = 0;\n    if (origin) {\n        ox = origin.x || 0;\n        oy = origin.y || 0;\n    }\n\n    var nx = ox + (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));\n    var ny = oy + (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));\n\n    this.x = nx;\n    this.y = ny;\n\n    return this;\n};\n\nVector2.prototype.rotateDeg = function (angle) {\n    angle = degrees2radian(angle);\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateBy = function (rotation) {\n    var angle = this.angle() + rotation;\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateByDeg = function (rotation) {\n    rotation = degrees2radian(rotation);\n    return this.rotateBy(rotation);\n};\n\nVector2.prototype.distance = function (vec) {\n    return Math.sqrt(this.distanceSq(vec));\n};\n\nVector2.prototype.distanceSq = function (vec) {\n    var dx = this.x - vec.x,\n    dy = this.y - vec.y;\n    return dx * dx + dy * dy;\n};\n\nVector2.prototype.length = function () {\n    return Math.sqrt(this.lengthSq());\n};\n\nVector2.prototype.lengthSq = function () {\n    return this.x * this.x + this.y * this.y;\n};\n\nVector2.prototype.magnitude = Vector2.prototype.length;\n\nVector2.prototype.isZero = function() {\n    return this.x === 0 && this.y === 0;\n};\nVector2.prototype.isEqualTo = function(vec) {\n    return this.x === vec.x && this.y === vec.y;\n};\n\nVector2.prototype.isEqualEpsilon = function(vec) {\n    return Math.abs(this.x - vec.x) < epsilon && Math.abs(this.y - vec.y) < epsilon;\n};\n\nVector2.prototype.toString = function () {\n    return 'x:' + this.x + ', y:' + this.y;\n};\n\nVector2.prototype.toArray = function () {\n    return [ this.x, this.y ];\n};\n\nVector2.prototype.toObject = function () {\n    return { x: this.x, y: this.y };\n};\n\nfunction radian2degrees (rad) {\n    return rad * degrees;\n}\n\nfunction degrees2radian (deg) {\n    return deg / degrees;\n}\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\n/*\n    Based upon https://code.google.com/p/visibility-polygon-js/\n    Made by Byron Knoll in 2013/2014.\n*/\n\nvar Polygon2 = require('./polygon2'),\n    Vector2 = require('./vector2'),\n    LineSegment2 = require('./linesegment2');\n\nvar PI = Math.PI;\nvar PI2 = PI*2;\nvar PImin = -1*PI;\nvar epsilon = 0.0000001;\n\nvar segmentIter = ['start', 'end'];\nfunction pointsorter(a,b) {\n    return a[2] - b[2];\n}\n\nfunction VisibilityPolygon(segments)\n{\n    this.polygon = Polygon2();\n    this.segments = segments;\n    this.heap = [];\n    this.map = new Array(this.segments.length);\n    this.points = new Array(this.segments.length * 2);\n    this.position = Vector2();\n}\n\nVisibilityPolygon.prototype.angle = function (p1, p2)\n{\n    var p = p2.clone().subtract(p1);\n    var a = p.angle();\n    p.free();\n    return a;\n};\n\nVisibilityPolygon.prototype.angle2 = function (a, b, c) {\n    var a1 = this.angle(a, b);\n    var a2 = this.angle(b, c);\n    var a3 = a1 - a2;\n    if (a3 < 0) { a3 += PI2; }\n    if (a3 > PI2) { a3 -= PI2; }\n    return a3;\n};\n\n\nVisibilityPolygon.prototype.compute = function (position)\n{\n    this.position.copy(position);\n    this.reset();\n    this.sortPoints();\n\n    var start = this.position.clone();\n    start.x +=1; // why?\n\n    var i = 0,\n        n = this.segments.length;\n    while (i < n) {\n        var a1 = this.angle(this.segments[i].start, this.position);\n        var a2 = this.angle(this.segments[i].end, this.position);\n        if (\n            ( a1 > PImin && a1 <= 0 && a2 <= PI && a2 >= 0 && a2 - a1 > PI) ||\n            (a2 > PImin && a2 <= 0 && a1 <= PI && a1 >= 0 && a1 - a2 > PI)\n        ) {\n            this.insert(i, start);\n        }\n        i += 1;\n    }\n    i = 0;\n    n = this.segments.length*2;\n    while (i < n) {\n        var extend = false;\n        var shorten = false;\n        var orig = i;\n        var vertex = this.segments[this.points[i][0]][this.points[i][1]];\n        var old_segment = this.heap[0];\n        do {\n            if (this.map[this.points[i][0]] !== -1) {\n                if (this.points[i][0] === old_segment) {\n                    extend = true;\n                    vertex = this.segments[this.points[i][0]][this.points[i][1]];\n                }\n                this.remove(this.map[this.points[i][0]], vertex);\n            } else {\n                this.insert(this.points[i][0], vertex);\n                if (this.heap[0] !== old_segment) {\n                    shorten = true;\n                }\n            }\n            ++i;\n            if (i === n) { break; }\n        } while (this.points[i][2] < this.points[orig][2] + epsilon);\n\n        var l = LineSegment2(position.clone(), vertex.clone());\n        if (extend) {\n            this.polygon.add(vertex.clone());\n            var cur = this.segments[this.heap[0]].intersect(l, true);\n            if (cur ) {\n                if (!cur.isEqualEpsilon(vertex)) {\n                    this.polygon.add(cur);\n                } else {\n                    cur.free();\n                }\n            }\n        } else if (shorten) {\n            this.polygon.add(this.segments[old_segment].intersect(l, true));\n            this.polygon.add(this.segments[this.heap[0]].intersect(l, true));\n        }\n    }\n    return this.polygon;\n};\n\n\nVisibilityPolygon.prototype.insert = function (index, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var intersect = this.segments[index].intersect(l, true);\n    if (intersect === false) {\n        l.free();\n        return;\n    }\n    intersect.free();\n\n    var cur = this.heap.length;\n    this.heap.push(index);\n    this.map[index] = cur;\n    while (cur > 0) {\n        var parent = this.parent(cur);\n        if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n            break;\n        }\n        this.map[this.heap[parent]] = cur;\n        this.map[this.heap[cur]] = parent;\n        var temp = this.heap[cur];\n        this.heap[cur] = this.heap[parent];\n        this.heap[parent] = temp;\n        cur = parent;\n    }\n};\n\nVisibilityPolygon.prototype.remove = function (index, destination) {\n    this.map[this.heap[index]] = -1;\n    if (index === this.heap.length - 1) {\n        this.heap.pop();\n        return;\n    }\n    this.heap[index] = this.heap.pop();\n    this.map[this.heap[index]] = index;\n    var cur = index;\n    var parent = this.parent(cur);\n    if (cur !== 0 && this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n        while (cur > 0) {\n            parent = this.parent(cur);\n            if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n                break;\n            }\n            this.swap(cur, parent);\n            cur = parent;\n        }\n    } else {\n        while (true) {\n            var left = this.child(cur);\n            var right = left + 1;\n            if (left < this.heap.length && this.lessThan(this.heap[left], this.heap[cur], destination) &&\n                (right === this.heap.length || this.lessThan(this.heap[left], this.heap[right], destination))) {\n                    this.swap(cur, left);\n                    cur = left;\n                } else if (right < this.heap.length && this.lessThan(this.heap[right], this.heap[cur], destination)) {\n                    this.swap(cur, right);\n                    cur = right;\n                } else {\n                    break;\n                }\n            }\n        }\n    };\n\n\n\nVisibilityPolygon.prototype.lessThan = function (index1, index2, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var inter1 = this.segments[index1].intersect(l, true);\n    var inter2 = this.segments[index2].intersect(l, true);\n    if (!inter1.isEqualEpsilon(inter2)) {\n        var d1 = inter1.distanceSq(this.position);\n        var d2 = inter2.distanceSq(this.position);\n        inter1.free();\n        inter2.free();\n        l.free();\n        return d1 < d2;\n    }\n    var end1 = this.segments[index1].start;\n    if (inter1.isEqualEpsilon(this.segments[index1].start)) {\n        end1 = this.segments[index1].end;\n    }\n    var end2 = this.segments[index2].start;\n    if (inter2.isEqualEpsiolon(this.segments[index2].start)) {\n        end2 = this.segments[index2].end;\n    }\n    var a1 = this.angle2(end1, inter1, this.position);\n    var a2 = this.angle2(end2, inter2, this.position);\n    inter1.free();\n    inter2.free();\n    if (a1 < PI) {\n        if (a2 > PI) {\n            return true;\n        }\n        return a2 < a1;\n    }\n    return a1 < a2;\n};\n\nVisibilityPolygon.prototype.parent = function (index) {\n    return Math.floor((index - 1) / 2);\n};\n\nVisibilityPolygon.prototype.child = function (index) {\n    return 2 * index + 1;\n};\n\nVisibilityPolygon.prototype.swap = function (c, l) {\n    this.map[this.heap[l]] = c;\n    this.map[this.heap[c]] = l;\n    var temp = this.heap[l];\n    this.heap[l] = this.heap[c];\n    this.heap[c] = temp;\n};\n\n\nVisibilityPolygon.prototype.sortPoints = function ()\n{\n    var i = 0,\n    n = this.segments.length,\n    p = null,\n    pp = Vector2();\n    while (i < n) {\n        for (var j = 0; j < 2; ++j) {\n            if (j === 0) {\n                p = this.segments[i][segmentIter[j]];\n            } else {\n                p = this.segments[i][segmentIter[j]];\n            }\n            pp.copy(this.position).subtract(p);\n            var nr = 2 * i + j;\n            if (this.points[nr]) {\n                this.points[nr][0] = i;\n                this.points[nr][1] = segmentIter[j];\n                this.points[nr][2] = pp.angle();\n            } else {\n                this.points[nr] = [i, segmentIter[j], pp.angle()];\n            }\n        }\n        i += 1;\n    }\n    pp.free();\n    this.points = this.points.sort(pointsorter);\n};\n\nVisibilityPolygon.prototype.reset = function ()\n{\n    this.polygon.freePoints();\n    var i = 0,\n    n = this.map.length;\n    while (i < n) {\n        this.map[i] = -1;\n        i += 1;\n    }\n    while (this.heap.length > 0) {\n        this.heap.pop();\n    }\n};\n/* jshint +W064 */\n","var core = {};\n\n\ncore.geometry = require('./geometry');\ncore.linkedlist = require('./linkedlist');\ncore.procedural = require('./procedural');\ncore.timer = require('./timer');\ncore.input = require('./input');\ncore.game = require('./game');\n\nmodule.exports = core;\n\nglobal.ULTRON = core;\n","module.exports = {\n  Unified: require('./unified')\n};\n","//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\n// taken from game-shell\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif ( window.addEventListener ) {\n  _addEventListener = \"addEventListener\";\n} else {\n  _addEventListener = \"attachEvent\";\n  prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\n  elem[ _addEventListener ]( prefix + eventName, support === \"wheel\" ? callback : function( originalEvent ) {\n    !originalEvent && ( originalEvent = window.event );\n\n    // create a normalized event object\n    var event = {\n      // keep a ref to the original event object\n      originalEvent: originalEvent,\n      target: originalEvent.target || originalEvent.srcElement,\n      type: \"wheel\",\n      deltaMode: originalEvent.type === \"MozMousePixelScroll\" ? 0 : 1,\n      deltaX: 0,\n      delatZ: 0,\n      preventDefault: function() {\n        originalEvent.preventDefault ?\n          originalEvent.preventDefault() :\n          originalEvent.returnValue = false;\n      }\n    };\n\n    // calculate deltaY (and deltaX) according to the event\n    if ( support === \"mousewheel\" ) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n      // Webkit also support wheelDeltaX\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n    } else {\n      event.deltaY = originalEvent.detail;\n    }\n\n    // it's time to fire the callback\n    return callback( event );\n  }, useCapture || false );\n}\n\nmodule.exports = function( elem, callback, useCapture ) {\n  _addWheelListener( elem, support, callback, useCapture );\n\n  // handle MozMousePixelScroll in older Firefox\n  if( support === \"DOMMouseScroll\" ) {\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\n  }\n};\n","'use strict';\n\n// taken from https://github.com/andyhall/game-inputs\n\nvar vkey = require('vkey');\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\nvar EventEmitter = require('eventemitter3');\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = require('./mousewheel-polyfill');\n\nmodule.exports = Inputs;\n\n// map button index to name\nvar gamepadButtonNames = [\n    'a',\n    'b',\n    'x',\n    'y',\n    'left-shoulder',\n    'right-shoulder',\n    'left-trigger',\n    'right-trigger',\n    'select',\n    'start',\n    'left-stick',\n    'right-stick',\n    'dpad-up',\n    'dpad-down',\n    'dpad-left',\n    'dpad-right'\n];\nvar gamepadAxesNames = [\n    'left-stick-x',\n    'left-stick-y',\n    'right-stick-x',\n    'right-stick-y'\n];\nvar hasGamepadEvents = 'GamepadEvent' in window;\n\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from)\n *        game-shell: https://github.com/mikolalysenko/game-shell\n *\n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *\n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n*/\n\n\nfunction Inputs(element, opts) {\n\n  // settings\n  this.element = element || document;\n  opts = opts || {};\n  this.preventDefaults = !!opts.preventDefaults;\n  this.stopPropagation = !!opts.stopPropagation;\n\n  // emitters\n  this.down = new EventEmitter();\n  this.up = new EventEmitter();\n  this.gamepadconnected = new EventEmitter();\n  this.gamepaddisconnected = new EventEmitter();\n\n  // state object to be queried\n  this.state = {\n    dx: 0, dy: 0,\n    scrollx: 0, scrolly: 0, scrollz: 0\n  };\n\n  // internal state\n  this._keybindmap = {};       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n  this._keyStates = {};        // { 'vkeycode' : boolean }\n  this._bindPressCounts = {};  // { 'binding' : int }\n  this._gamepads = {}; // { 'index' : gamepad }\n  this._gamepadButtonStates = {}; // { 'vcode' : int }\n\n  // raf handle\n  this._gamepadRaf = false;\n\n  // register for dom events\n  this.initEvents();\n}\n\n\n/*\n *\n *   PUBLIC API\n *\n*/\n\nInputs.prototype.initEvents = function() {\n  // keys\n  window.addEventListener( 'keydown', onKeyEvent.bind(undefined,this,true), false );\n  window.addEventListener( 'keyup', onKeyEvent.bind(undefined,this,false), false );\n  // mouse buttons\n  this.element.addEventListener('mousedown', onMouseEvent.bind(undefined,this,true), false);\n  this.element.addEventListener('mouseup', onMouseEvent.bind(undefined,this,false), false);\n  this.element.oncontextmenu = onContextMenu.bind(undefined,this);\n  // mouse other\n  this.element.addEventListener('mousemove', onMouseMove.bind(undefined,this), false);\n  addMouseWheel(this.element, onMouseWheel.bind(undefined,this), false);\n\n  // gamepads\n  if ( hasGamepadEvents ) {\n      window.addEventListener('gamepadconnected', onGamepadConnected.bind(undefined,this), false);\n      window.addEventListener('gamepaddisconnected', onGamepadDisconnected.bind(undefined,this), false);\n  } else {\n      window.setInterval(scanGamepads.bind(undefined, this), 500);\n  }\n};\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function(binding) {\n  for (var i=1; i<arguments.length; ++i) {\n    var vkeyCode = arguments[i];\n    var arr = this._keybindmap[vkeyCode] || [];\n    if (arr.indexOf(binding) === -1) {\n      arr.push(binding);\n    }\n    this._keybindmap[vkeyCode] = arr;\n  }\n  this.state[binding] = !!this.state[binding];\n};\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function(binding) {\n  for (var b in this._keybindmap) {\n    var arr = this._keybindmap[b];\n    var i = arr.indexOf(binding);\n    if (i>-1) { arr.splice(i,1); }\n  }\n};\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function() {\n  this.state['mouse-dx'] = this.state['mouse-dy'] = 0;\n  this.state['mouse-scrollx'] = this.state['mouse-scrolly'] = this.state['mouse-scrollz'] = 0;\n};\n\n\n\nInputs.prototype.getBoundKeys = function() {\n  var arr = [];\n  for (var b in this._keybindmap) { arr.push(b); }\n  return arr;\n};\n\n\n/*\n *   INTERNALS - DOM EVENT HANDLERS\n*/\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n  handleKeyEvent( ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev );\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n  // simulate a code out of range of vkey\n  var keycode = -1 - ev.button;\n  var vkeycode = '<mouse '+ (ev.button+1) +'>';\n  handleKeyEvent( keycode, vkeycode, wasDown, inputs, ev );\n  return false;\n}\n\nfunction onContextMenu(inputs) {\n  // cancel context menu if there's a binding for right mousebutton\n  var arr = inputs._keybindmap['<mouse 3>'];\n  if (arr) { return false; }\n}\n\nfunction onMouseMove(inputs, ev) {\n  // for now, just populate the state object with mouse movement\n  var dx = ev.movementX || ev.mozMovementX || ev.webkitMovementX || 0,\n      dy = ev.movementY || ev.mozMovementY || ev.webkitMovementY || 0;\n  inputs.state['mouse-dx'] += dx;\n  inputs.state['mouse-dy'] += dy;\n  // TODO: verify if this is working/useful during pointerlock?\n}\n\nfunction onMouseWheel(inputs, ev) {\n  // basically borrowed from game-shell\n  var scale = 1;\n  switch(ev.deltaMode) {\n    case 0: scale=1;   break;  // Pixel\n    case 1: scale=12;  break;  // Line\n    case 2:  // page\n      // TODO: investigagte when this happens, what correct handling is\n      scale = inputs.element.clientHeight || window.innerHeight;\n      break;\n  }\n  // accumulate state\n  inputs.state['mouse-scrollx'] += ev.deltaX * scale;\n  inputs.state['mouse-scrolly'] += ev.deltaY * scale;\n  inputs.state['mouse-scrollz'] += (ev.deltaZ * scale) || 0;\n  return false;\n}\n\n\n/*\n *   KEY BIND HANDLING\n*/\n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n  var arr = inputs._keybindmap[vcode];\n  // don't prevent defaults if there's no binding\n  if (!arr) { return; }\n  if (inputs.preventDefaults) { ev.preventDefault(); }\n  if (inputs.stopPropagation) { ev.stopPropagation(); }\n\n  // if the key's state has changed, handle an event for all bindings\n  var currstate = inputs._keyStates[keycode];\n  if ( XOR(currstate, wasDown) ) {\n    // for each binding: emit an event, and update cached state information\n    for (var i=0; i<arr.length; ++i) {\n      handleBindingEvent( arr[i], wasDown, inputs, ev );\n    }\n  }\n  inputs._keyStates[keycode] = wasDown;\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n  // keep count of presses mapped by binding\n  // (to handle two keys with the same binding pressed at once)\n  var ct = inputs._bindPressCounts[binding] || 0;\n  ct += wasDown ? 1 : -1;\n  if (ct<0) { ct = 0; } // shouldn't happen\n  inputs._bindPressCounts[binding] = ct;\n\n  // emit event if binding's state has changed\n  var currstate = inputs.state[binding];\n  if ( XOR(currstate, ct) ) {\n    var emitter = wasDown ? inputs.down : inputs.up;\n    emitter.emit(binding, binding, ev);\n  }\n  inputs.state[binding] = !!ct;\n}\n\n/**\nGamepad HANDLERS\n*/\n\nfunction handleGamePadButtonEvent(val, vcode, inputs) {\n    var arr = inputs._keybindmap[vcode];\n    if (!arr) { return; }\n\n    var pressed = val === 1.0;\n    var isPerc = false;\n    if (typeof(val) === 'object') {\n        pressed = val.pressed;\n        val = val.value;\n        isPerc = true;\n        inputs.state[vcode] = val;\n    } else {\n        var currstate = inputs._buttonStates[vcode];\n        if (XOR(currstate, val)) {\n            var i = 0;\n            for (i=0; i<arr.length; ++i) {\n                handleBindingEvent( arr[i], pressed, inputs, null); // pass null as fake event\n            }\n        }\n    }\n}\n\nfunction updateGamepads(inputs) {\n    var found = scanGamepads(inputs);\n    if (!found) {\n        if (inputs._gamepadRaf) {\n            cancel(inputs._gamepadRaf);\n            inputs._gamepadRaf = false;\n        }\n        return;\n    }\n\n    var vcode = '';\n    for (var j in inputs._gamepads) {\n        var gamepad = inputs._gamepads[j];\n\n        for (var i=0;i<gamepad.buttons.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadButtonNames[i] + '>';\n            handleGamePadButtonEvent(gamepad.buttons[i], vcode, inputs);\n        }\n\n        for (i=0;i<gamepad.axes.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadAxesNames[i] + '>';\n            inputs.state[vcode] = gamepad.axes[i];\n        }\n    }\n    inputs._gamepadRaf = request(updateGamepads);\n}\n\nfunction onGamepadConnected(inputs, ev) {\n    addGamepad(inputs, ev.gamepad);\n}\n\nfunction onGamepadDisconnected(inputs, ev) {\n    removeGamepad(inputs, ev.gamepad);\n}\n\n\nfunction addGamepad(inputs, gamepad) {\n    inputs._gamepads[gamepad.index] = gamepad;\n    inputs.gamepadconnected.emit(gamepad);\n    if (!inputs._gamepadRaf) {\n        inputs._gamepadRaf = request(updateGamepads);\n    }\n}\n\nfunction removeGamepad(inputs, gamepad) {\n    delete inputs._gamepads[gamepad.index];\n    inputs.gamepaddisconnected.emit(gamepad);\n    for (var j in inputs._gamepads) {\n        if (inputs._gamepads.hasOwnProperty(j)) {\n            return;\n        }\n    }\n    if (inputs._gamepadRaf) {\n        cancel(inputs._gamepadRaf);\n        inputs._gamepadRaf = false;\n    }\n}\n\n\nfunction scanGamepads(inputs) {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n    var found = false;\n    for (var i = 0; i < gamepads.length; i++) {\n        if (gamepads[i]) {\n            found = true;\n            if (!(gamepads[i].index in inputs._gamepads)) {\n                addGamepad(inputs, gamepads[i]);\n            } else {\n                inputs._gamepads[gamepads[i].index] = gamepads[i];\n            }\n        }\n    }\n    return found;\n}\n\n/*\n *    HELPERS\n *\n*/\n\n\n// how is this not part of Javascript?\nfunction XOR(a,b) {\n  return a ? !b : b;\n}\n","/*\n * Doubly Linked List implementation in JavaScript\n * Copyright (c) 2009 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n /*\n  * Optimizations and data reuse by Wouter Commandeur\n */\n\n'use strict';\n\n/**\n * A linked list implementation in JavaScript.\n * @class DoublyLinkedList\n * @constructor\n */\nfunction DoublyLinkedList() {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    this._head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    this._tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type int\n     * @private\n     */\n    this._length = 0;\n\n    this._nodeCache = [];\n\n}\n\nDoublyLinkedList.prototype = {\n\n    //restore constructor\n    constructor: DoublyLinkedList,\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {variant} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    add: function (data) {\n        //create a new item object, place data in\n        var node = this._allocate(data);\n\n        //special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n        } else {\n            //attach to the tail node\n            this._tail.next = node;\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        //don't forget to update the count\n        this._length++;\n\n    },\n\n\n    set: function(index, data) {\n        // update data at index\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            current.data = data;\n        }\n    },\n\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {int} index The zero-based index of the item whose value\n     *      should be returned.\n     * @return {variant} The value in the \"data\" portion of the given item\n     *      or null if the item doesn't exist.\n     * @method item\n     */\n    item: function(index){\n\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            return current.data;\n        } else {\n            return null;\n        }\n    },\n\n    pop: function() {\n        return this.remove(this._length -1);\n    },\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {variant} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    remove: function(index){\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n\n            var current = this._head,\n                i = 0;\n\n            //special case: removing first item\n            if (index === 0){\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head){\n                    this._tail = null;\n                } else {\n                    this._head.prev = null;\n                }\n\n            //special case: removing last item\n            } else if (index === this._length -1){\n                current = this._tail;\n                this._tail = current.prev;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while(i++ < index){\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.prev.next = current.next;\n            }\n\n            //decrement the length\n            this._length--;\n\n            // release into object pool\n            this._free(current);\n\n            //return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    },\n\n    clear: function() {\n        while (this._length > 0) {\n            this.remove(0);\n        }\n    },\n\n   /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    size: function(){\n        return this._length;\n    },\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    toArray: function(){\n        var result = [],\n            current = this._head;\n\n        while(current){\n            result.push(current.data);\n            current = current.next;\n        }\n\n        return result;\n    },\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    toString: function(){\n        return this.toArray().toString();\n    },\n\n    _free: function(node) {\n        this._nodeCache.push(node);\n    },\n\n    _allocate: function(data) {\n        var node = this._nodeCache.pop();\n        if (!node) {\n            node = {};\n        }\n        node.data = data;\n        node.prev = null;\n        node.next = null;\n        return node;\n    }\n};\n\nexports = module.exports = DoublyLinkedList;\n","module.exports = {\n  DoublyLinkedList: require('./doublylinkedlist')\n};\n","'use strict';\n\n/* jshint -W064 */\nvar RegularPolygon2 = require('../geometry/regularpolygon2');\nvar Polygon2 = require('../geometry/polygon2');\nvar Vector2 = require('../geometry/vector2');\nvar LineSegment2 = require('../geometry/linesegment2');\nvar gpc = require('../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('./graph');\n\nexports = module.exports = Building;\n\nvar createPoly = function(points) {\n\tvar res  = new gpc.geometry.PolyDefault();\n\tfor(var i=0 ; i < points.length ; i++) {\n\t\tres.addPoint(new gpc.geometry.Point(points[i][0],points[i][1]));\n\t}\n\treturn res;\n};\n\nvar getPolygonVertices = function(poly) {\n\tvar vertices=[];\n\tvar numPoints = poly.getNumPoints();\n\tvar i;\n\n\tfor(i=0;i<numPoints;i++) {\n\t\tvertices.push([poly.getX(i) , poly.getY(i)]);\n\t}\n\treturn vertices;\n};\n\nfunction Building( chance, iterations, minRadius, maxRadius, maxSides, noRotate)\n{\n\tvar end, l;\n\tthis.centers = [];\n\titerations = iterations || 1;\n//\tif ( iterations < 3 ) {\n//\t\titerations = 3;\n//\t}\n\tmaxSides = maxSides || 6;\n\tif ( maxSides < 4 ) {\n\t\tmaxSides = 4;\n\t}\n\tvar sidesChanceObj = { min: 4, max: maxSides };\n\tvar radiusChanceObj = { min: minRadius, max: maxRadius };\n\n\tvar sides = chance.integer(sidesChanceObj);\n\tvar polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\tvar gpcPoly = createPoly(polygon.toArray());\n\tpolygon.free();\n\tvar vec, gpcPoly2, num;\n\tthis.centers.push(Vector2());\n\n\tfor (var i = 1; i < iterations;i++) {\n\t\t// new random polygon\n\t\tsides = chance.integer(sidesChanceObj);\n\t\tpolygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\n\t\t// rotate random\n\t\tif (!noRotate) {\n\t\t\tpolygon.rotate(chance.floating({min: 0, max: 2 * Math.PI / sides}));\n\t\t}\n\n\t\t// random point on prev poly\n\t\tnum = chance.integer({min: 0, max:gpcPoly.getNumPoints()-1});\n\t\tvec = Vector2(gpcPoly.getX(num), gpcPoly.getY(num));\n\t\tthis.centers.push(vec);\n\n\t\t// center the polygon on a random point of the previous polygon\n\t\tpolygon.translate(vec);\n\t\tgpcPoly2 = createPoly(polygon.toArray());\n\t\tgpcPoly = gpcPoly.union(gpcPoly2);\n\n\t\t// free our stuff for reuse\n\t\tpolygon.free();\n\t}\n\tvar arr = getPolygonVertices(gpcPoly);\n\n\t// generate final polygon\n\tpolygon = Polygon2.fromArray(arr);\n\tthis.polygon = polygon;\n\n\t// this.polygon.clean(30);\n\n\t// add outer doors\n\tvar nrdoors = Math.ceil(iterations/2);\n\tthis.doors = [];\n\n\tvar nr;\n\tvar dooredges = {};\n\tfor ( i=0;i<nrdoors;i++) {\n\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\twhile (dooredges[nr]) {\n\t\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\t}\n\t\tdooredges[nr] = true;\n\t\tend = nr + 1;\n\t\tif (end === this.polygon.points.length) {\n\t\t\tend = 0;\n\t\t}\n\t\tl = LineSegment2(this.polygon.points[nr].clone(), this.polygon.points[end].clone());\n\t\tvar p2 = l.end.clone();\n\t\tvar p1 = l.start.clone();\n\t\tvar length = l.length(); // p2.subtract(l.start).length();\n\t\tp2.subtract(l.start).normalize().multiplyScalar(length/2);\n\t\tp1.add(p2);\n\t\t// this.centers.push(p1);\n\t\tthis.doors.push(p1);\n\t\tp2.free();\n\t\tl.free();\n\t}\n\n\n\n\tvar c = [];\n\tfor (i = 0; i < this.centers.length; i++) {\n\t\tc.push(this.centers[i].toArray());\n\t}\n\n\tthis.graph = new Graph();\n\tthis.delaunay_used = {};\n\n\t// delaunay the centers\n\tthis.delaunay = Delaunay.triangulate(c);\n\n\tfor (i = 0; i < this.delaunay.length; i += 1) {\n\t\tif (!this.delaunay_used[this.delaunay[i]]) {\n\t\t\tthis.graph.addNode(this.delaunay[i]);\n\t\t\tthis.delaunay_used[this.delaunay[i]] = true;\n\t\t}\n\t}\n\n\n\tthis.delaunay_exists = {};\n\n\tthis.delaunay_triangles = [];\n\tthis.delaunay_lines = [];\n\tfor (i = 0; i < this.delaunay.length; i += 3) {\n\t\t// line 1\n\t\tthis.addDelaunayLine(i, i+1);\n\t\tthis.addDelaunayLine(i+1, i+2);\n\t\tthis.addDelaunayLine(i+2, i);\n\t}\n\n\t// connect the doors;\n\tnr = this.centers.length;\n\tfor (i = 0; i < this.doors.length; i++) {\n\t\tthis.connectDoor(this.doors[i], nr);\n\t}\n\n\n\n\t// calculate the minimal spanning tree\n\tvar edges = this.graph.prim(); // Prim(this.graph);\n\t// console.log(edges);\n\tthis.mst_lines = [];\n\n\tfor (i = 0; i < edges.length; i ++) {\n\t\tvar start = edges[i].source;\n\t\tend = edges[i].sink;\n\t\tl = LineSegment2(this.centers[start].clone(), this.centers[end].clone());\n\t\tthis.mst_lines.push(l);\n\t\t//var l = LineSegment2()\n\t}\n\n\n\tthis.outside = this.polygon.AABB();\n\n\tthis.outside[0].subtractScalar(50);\n\tthis.outside[1].addScalar(50);\n\n}\n\nBuilding.prototype.connectDoor = function(door, nr)\n{\n\tvar min = 9999999;\n\tvar l,d;\n\tvar point = false;\n\tfor (var i= 0;i<nr;i++) {\n\t\tl = LineSegment2(this.centers[i].clone(), door.clone());\n\t\tif (!this.polygon.intersectsLine(l, true)) {\n\t\t\td = l.length();\n\t\t\tif ( d < min ) {\n\t\t\t\tmin = d;\n\t\t\t\tpoint = i;\n\t\t\t}\n\t\t}\n\t\tl.free();\n\t}\n\tif (point !== false) {\n\t\tthis.centers.push(door.clone());\n\t\tthis.graph.addNode(this.centers.length - 1);\n\t\tthis.graph.addEdge(point, this.centers.length - 1, min);\n\t\tthis.delaunay_lines.push(LineSegment2(this.centers[point].clone(), door.clone()));\n\t} else {\n\t\tl.free();\n\t}\n\n};\n\nBuilding.prototype.addDelaunayLine = function(start, end)\n{\n\tvar key1 = start + ':' + end;\n\tvar key2 = end + ':' + start;\n\tif (this.delaunay_exists[key1] || this.delaunay_exists[key2]) {\n\t\treturn;\n\t}\n\tthis.delaunay_exists[key1] = true;\n\tthis.delaunay_exists[key2] = true;\n\tvar l = LineSegment2(this.centers[this.delaunay[start]].clone(), this.centers[this.delaunay[end]].clone());\n\tif (this.polygon.intersectsLine(l)) {\n\t\tl.free();\n\t} else {\n\t\tthis.graph.addEdge(this.delaunay[start], this.delaunay[end], l.length());\n\t\tthis.delaunay_lines.push(l);\n\t}\n};\n\n\nBuilding.prototype.translate = function (vec)\n{\n\tthis.polygon.translate(vec);\n\tfor (var i=0;i<this.centers.length;i++) {\n\t\tthis.centers[i].add(vec);\n\t}\n\tfor (i =0;i<this.delaunay_triangles.length;i++) {\n\t\tthis.delaunay_triangles[i].translate(vec);\n\t}\n\treturn this;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\n\n\n// Represents an edge from source to sink with capacity\nvar Edge = function(source, sink, capacity) {\n    this.source = source;\n    this.sink = sink;\n    this.capacity = capacity;\n};\n\n// Main class to manage the network\nvar Graph = function() {\n    this.edges = {};\n    this.nodes = [];\n    this.nodeMap = {};\n\n    // Add a node to the graph\n    this.addNode = function(node) {\n        this.nodes.push(node);\n        this.nodeMap[node] = this.nodes.length-1;\n        this.edges[node] = [];\n    };\n\n    // Add an edge from source to sink with capacity\n    this.addEdge = function(source, sink, capacity) {\n        // Create the two edges = one being the reverse of the other\n        this.edges[source].push(new Edge(source, sink, capacity));\n        this.edges[sink].push(new Edge(sink, source, capacity));\n    };\n\n    // Does edge from source to sink exist?\n    this.edgeExists = function(source, sink) {\n        if(this.edges[source] !== undefined) {\n            for(var i=0;i<this.edges[source].length;i++) {\n                if(this.edges[source][i].sink === sink) {\n                    return this.edges[source][i];\n                }\n            }\n        }\n        return null;\n    };\n\n\n    this.prim = function() {\n        var result = [];\n        var resultEdges = [];\n        var usedNodes = {};\n\n        function findMin(g) {\n            var min = [999999,null];\n            for(var i=0;i<result.length;i++) {\n                for(var n=0;n<g.edges[result[i]].length;n++) {\n                    if(g.edges[result[i]][n].capacity < min[0] && usedNodes[g.edges[result[i]][n].sink] === undefined) {\n                        min = [g.edges[result[i]][n].capacity, g.edges[result[i]][n]];\n                    }\n                }\n            }\n            return min;\n        }\n\n        // Pick random start point\n        var node = this.nodes[Math.round(Math.random()*(this.nodes.length-1))];\n        result.push(node);\n        usedNodes[node] = true;\n\n        var min = findMin(this);\n        while(min[1] !== null) {\n            resultEdges.push(min[1]);\n            result.push(min[1].sink);\n            usedNodes[min[1].sink] = true;\n            min = findMin(this);\n        }\n\n        return resultEdges;\n    };\n\n};\n\nmodule.exports = Graph;\n","module.exports = {\n  Graph: require('./graph'),\n  Building: require('./building')\n};\n","'use strict';\n\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\n\nvar NOOP = function(){};\n\nexports = module.exports = GameLoop;\n\nfunction GameLoop () {\n  this.simulationTimestep = 1000 / 60;\n  this.frameDelta = 0;\n  this.lastFrameTimeMs = 0;\n  this.fps = 60;\n  this.lastFpsUpdate = 0;\n  this.framesThisSecond = 0;\n  this.numUpdateSteps = 0;\n  this.minFrameDelay = 0;\n  this.running = false;\n  this.started = false;\n  this.panic = false;\n  this.rafHandle = false;\n  this.boundAnimate = this.animate.bind(this);\n}\n\nGameLoop.prototype.begin = NOOP;\nGameLoop.prototype.update = NOOP;\nGameLoop.prototype.render = NOOP;\nGameLoop.prototype.end = NOOP;\n\nGameLoop.prototype.getSimulationTimestep = function() {\n  return this.simulationTimestep;\n};\n\nGameLoop.prototype.setSimulationTimestep = function(timestep) {\n  this.simulationTimestep = timestep;\n  return this;\n};\n\nGameLoop.prototype.getFPS = function () {\n  return this.fps;\n};\n\nGameLoop.prototype.getMaxAllowedFPS = function() {\n  return 1000 / this.minFrameDelay;\n};\n\nGameLoop.prototype.setMaxAllowedFPS =  function(fps) {\n  if (typeof fps === 'undefined') {\n    fps = Infinity;\n  }\n  if (fps === 0) {\n    this.stop();\n  }\n  else {\n    // Dividing by Infinity returns zero.\n    this.minFrameDelay = 1000 / fps;\n  }\n  return this;\n};\n\nGameLoop.prototype.resetFrameDelta = function() {\n  var oldFrameDelta = this.frameDelta;\n  this.frameDelta = 0;\n  return oldFrameDelta;\n};\n\nGameLoop.prototype.setBegin = function(fun) {\n  this.begin = fun || this.begin;\n  return this;\n};\n\nGameLoop.prototype.setUpdate = function(fun) {\n  this.update = fun || this.update;\n  return this;\n};\n\nGameLoop.prototype.setRender = function(fun) {\n  this.render = fun || this.render;\n  return this;\n};\n\nGameLoop.prototype.setEnd = function(fun) {\n  this.end = fun || this.end;\n  return this;\n};\n\nGameLoop.prototype.start = function() {\n  if (!this.started) {\n    this.started = true;\n    var self = this;\n    this.rafHandle = request(function(timestamp) {\n      self.render(1);\n      self.running = true;\n      self.lastFrameTimeMs = timestamp;\n      self.lastFpsUpdate = timestamp;\n      self.framesThisSecond = 0;\n      self.rafHandle = request(self.boundAnimate);\n    });\n  }\n  return this;\n};\n\nGameLoop.prototype.stop = function() {\n  this.running = false;\n  this.started = false;\n  cancel(this.rafHandle);\n  return this;\n};\n\nGameLoop.prototype.isRunning = function() {\n  return this.running;\n};\n\nGameLoop.prototype.animate = function animate(timestamp) {\n\n    if (timestamp < this.lastFrameTimeMs + this.minFrameDelay) {\n        this.rafHandle = request(this.boundAnimate);\n        return;\n    }\n\n    this.frameDelta += timestamp - this.lastFrameTimeMs;\n    this.lastFrameTimeMs = timestamp;\n\n    this.begin(timestamp, this.frameDelta);\n\n    if (timestamp > this.lastFpsUpdate + 1000) {\n        this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;\n        this.lastFpsUpdate = timestamp;\n        this.framesThisSecond = 0;\n    }\n    this.framesThisSecond++;\n\n     /* - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    this.numUpdateSteps = 0;\n    while (this.frameDelta >= this.simulationTimestep) {\n        this.update(this.simulationTimestep);\n        this.frameDelta -= this.simulationTimestep;\n\n        if (++this.numUpdateSteps >= 240) {\n            this.panic = true;\n            break;\n        }\n    }\n\n    this.render(this.frameDelta / this.simulationTimestep);\n\n    this.end(this.fps, this.panic);\n\n    this.panic = false;\n\n    this.rafHandle = request(this.boundAnimate);\n};\n","module.exports = {\n  GameLoop: require('./gameloop')\n};\n"]}