{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/delaunay-fast/delaunay.js","ultron.min.js","node_modules/eventemitter3/index.js","node_modules/request-frame/dist/request-frame.js","node_modules/vkey/index.js","src/game/game.js","src/game/index.js","src/game/state.js","src/game/statelist.js","src/game/statestack.js","src/geometry/gpc.js","src/geometry/grid/cell.js","src/geometry/grid/grid.js","src/geometry/grid/index.js","src/geometry/index.js","src/geometry/linesegment2.js","src/geometry/polygon2.js","src/geometry/quadtree/boundsnode.js","src/geometry/quadtree/index.js","src/geometry/quadtree/pointnode.js","src/geometry/quadtree/quadtree.js","src/geometry/regularpolygon2.js","src/geometry/triangle2.js","src/geometry/vector2.js","src/geometry/visibilitypolygon.js","src/src/index.js","src/input/index.js","src/input/mousewheel-polyfill.js","src/input/unified.js","src/linkedlist/doublylinkedlist.js","src/linkedlist/index.js","src/procedural/building.js","src/procedural/graph.js","src/procedural/index.js","src/timer/gameloop.js","src/timer/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","ULTRON","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"Delaunay","supertriangle","vertices","dx","dy","dmax","xmid","ymid","xmin","Number","POSITIVE_INFINITY","ymin","xmax","NEGATIVE_INFINITY","ymax","Math","max","circumcircle","j","k","xc","yc","m1","m2","mx1","mx2","my1","my2","x1","y1","x2","y2","x3","y3","fabsy1y2","abs","fabsy2y3","EPSILON","x","y","dedup","edges","b","m","splice","triangulate","key","indices","st","open","closed","c","slice","Array","sort","push","contains","tri","p","d","v",2,"EE","fn","context","once","EventEmitter","prefix","Object","create","prototype","_events","undefined","listeners","event","exists","evt","available","ee","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","apply","on","listener","events","removeAllListeners","off","addListener","setMaxListeners","prefixed",3,"requestFrame","type","hasIOS6RequestAnimationFrameBug","bugCheckresults","timingFnA","timingFnB","notice","console","warn","displayResults","hasIOS6Bug","webkitRAF","rAF","iOS6Notice","webkitRequestAnimationFrame","requestAnimationFrame","hasMobileDeviceWidth","screen","width","requiresWebkitprefix","hasNoNavigationTiming","performance","clearTimeoutWithId","id","clearTimeout","setTimeoutWithTimestamp","callback","immediateTime","Date","now","lapsedTime","previousTime","setTimeout","queryRequestAnimationFrame","filter","assignedRequestAnimationFrame","aF","vendors","vendor","rqAF","queryCancelAnimationFrame","prefixedCancelAnimationFrame","prefixedNames","cancellationFunction","cancellationNames","map","cancellationNamePrefix","assignedCancelAnimationFrame","getRequestFn","hasMozMismatch","getCancelFn","setNativeFn","cancelAnimationFrame","func","mozRAF","mozRequestAnimationFrame","mozCAF","mozCancelAnimationFrame","getTime",4,"ua","navigator","userAgent","isOSX","test","isOpera","maybeFirefox","output",0,5,6,8,9,12,13,16,17,18,19,20,21,23,24,25,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,91,92,93,95,106,107,108,109,110,111,144,145,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,186,187,188,189,190,191,192,219,220,221,222,223,224,226,229,231,246,247,248,249,250,251,252,253,254,"String","fromCharCode","Game","states","statestack","StateStack","gameloop","GameLoop","setBegin","timestamp","frameDelta","begin","setUpdate","simulationTimestep","update","setRender","percentageTimestepRemaining","render","setEnd","fps","panic","end","NOOP","start","stop","addState","state","game","name","startState","stateName","stopState","pop","../timer/gameloop","./statestack","State","StateList","./game","./state","./statelist",7,"onEnter","onExit","top","depth",10,"equals","toString","gpcas","util","geometry","Clip","BundleState","LmtNode","TopPolygonNode","AetTree","HState","VertexType","VertexNode","ItNodeTable","StNode","Point","ArrayHelper","gpcstatic","create2DArray","valueEqual","obj1","obj2","sortPointsClockwise","isArrayList","ArrayList","toArray","maxLeftIndex","maxTop","maxBottom","maxLeft","maxRight","newVertices","vertex","reverse","arr","_array","add","value","get","index","size","clear","list","hashCode","isEmpty","DEBUG","GPC_EPSILON","GPC_VERSION","LEFT","RIGHT","ABOVE","BELOW","CLIP","SUBJ","intersection","p1","p2","polyClass","clip","OperationType","GPC_INT","union","GPC_UNION","xor","GPC_XOR","difference","GPC_DIFF","createNewPoly","PolySimple","PolyDefault","op","subj","result","minimax_test","lmt_table","LmtTable","sbte","ScanBeamTreeEntries","s_heap","c_heap","build_lmt","print","top_node","sbt","build_sbt","parity","local_min","out_poly","aet","scanbeam","yb","yt","edge","first_bound","next_bound","add_edge_to_aet","next","px","MAX_VALUE","e0","e1","bundle","bstate","UNBUNDLED","next_edge","ne_type","ne_type_opp","EQ","xb","BUNDLE_HEAD","BUNDLE_TAIL","horiz","NH","cf","bside","contributing","br","bl","tr","tl","next_h_state","vclass","getType","EMN","IMN","outp","add_local_min","ERI","add_right","ELI","add_left","EMX","merge_right","ILI","IRI","IMX","merge_left","IMM","EMM","LED","bot","RED","prev_edge","prev","xt","sbt_entries","it_table","build_intersection_table","intersect","ie","q","ix","point","iy","in_clip","in_subj","search","succ_edge","succ","getResult","PREV_INDEX","NEXT_INDEX","OPTIMAL","getY","getNumPoints","create_contour_bboxes","box","getNumInnerPoly","inner_poly","getInnerPoly","getBounds","s_bbox","c_bbox","subj_num_poly","clip_num_poly","o_table","getMaxX","getMinX","getMaxY","getMinY","overlap","setContributing","bound_list","node","done","existing_node","insert_bound","lmt_node","prev_bound","current_bound","current_edge","add_to_sbtree","sb_tree","ScanBeamTree","tree_node","less","more","edge_table","EdgeTable","ip","isContributing","num_vertices","e_index","getX","addNode","min","FWD_MIN","num_edges","NOT_FMAX","getNode","ei","ev","pred","REV_MIN","NOT_RMAX","add_st_edge","it","den","add_intersection","it_node","edge0","edge1","ItNode","m_State","EdgeNode","m_List","ith","BH","TH","IntersectionPoint","p3","polygonPoint1","polygonPoint2","intersectionPoint","Line","LineHelper","equalPoint","equalVertex","s1","s2","e2","distancePoints","sqrt","clonePoint","cloneLine","line","res","addLineToLine","line1","line2","roundPoint","round","lineIntersectLine","A","B","E","F","as_seg","b1","b2","c1","c2","denom","pow","LineIntersection","iteratePoints","points","direction","pl","s1Ind","indexOf","s2Ind","newPoints","intersectPoly","poly","p4","numPoints","firstIntersection","lastIntersection","firstIntersectionLineIndex","lastIntersectionLineIndex","firstFound","maxDist","minDist","dist","getPoint","distance","newLine","poly1","finPoly1","finPoly2","checkPoly","points1","getPoints","concat","points2","poly2","noHoles","innerPoly","isHole","yvalue","lmt","m_Type","m_IsHole","obj","that","arg0","arg1","addPointXY","addPoint","addPoly","alert","Rectangle","log","polyIndex","isPointInside","setIsHole","contributes","getArea","area","tarea","Polygon","fromArray","pointArr","normalize","getVertexIndex","insertVertex","vertex1","vertex2","newVertex","vertex1Index","vertex2Index","clone","PolygonNode","active","hole","proxy","vn","nv","m_Contributes","this_num","that_num","this_x","this_y","that_first_index","that_index","that_x","that_y","this_index","Poly","val","oddNodes","ax","ay","bx","by","cx","cy","_x","_y","_w","_h","w","h","entries","inner_build_sbt","sbt_node","existing_min","target","count_contours","nc","polygon","num_contours","npoly_node","poly_node","vtx","orig","inner","NUL","TED","BED","FUL","WeilerAtherton","merge",11,"Cell","height","items","a10","a11","a20","a21","b10","b11","b20","b21","ua_t","ub_t","u_b","ub","insert","item","fromX","fromY","toX","toY","Grid","bounds","rows","cols","cellX","cellY","cells","out","DoublyLinkedList","col","row","addOut","retrieve","nx","ny","floor","../../linkedlist/doublylinkedlist","./cell","./grid",14,"Vector2","LineSegment2","Triangle2","Polygon2","RegularPolygon2","gpc","VisibilityPolygon","QuadTree","./gpc","./linesegment2","./polygon2","./quadtree","./regularpolygon2","./triangle2","./vector2","./visibilitypolygon",15,"cache","free","set","created","getStats","lengthSq","distanceSq","closestPoint","full","l2","intersectCircle","radius","r2","closest","dist_v","subtract","len2","other","inverse","freePoints","epsilon","translate","vec","rotate","angle","origin","containsPoint","inside","xi","yi","xj","yj","intersectsLine","ignorePoints","tempLine","is","isEqualEpsilon","aa","copy","bb","intersectsTriangle","triangle","v0","v1","v2","AABB","winding","rewind","cw","first","cross","clean","newpoints","ret","BoundsNode","maxChildren","maxDepth","PointNode","_stuckChildren","_classConstructor","_out","nodes","_findIndex","_bounds","children","_depth","_maxDepth","_maxChildren","subdivide","getChildren","TOP_RIGHT","BOTTOM_LEFT","TOP_LEFT","BOTTOM_RIGHT","getAllContent","./pointnode","./boundsnode","left","b_w_h","b_h_h","bx_b_w_h","by_b_h_h","pointQuad","root","sides","center","cos","PI","sin",22,"calcCircumcircle","C","D","G","minx","miny","maxx","maxy","radius_squared","inCircumcircle","dist_squared","radian2degrees","rad","degrees","degrees2radian","deg","fromObject","addScalar","scalar","subtractScalar","divide","multiply","multiplyScalar","zero","dot","projectOnto","coeff","horizontalAngle","atan2","horizontalAngleDeg","verticalAngle","verticalAngleDeg","angleDeg","ox","oy","rotateDeg","rotateBy","rotation","rotateByDeg","magnitude","isZero","isEqualTo","toObject","pointsorter","segments","heap","position","PI2","PImin","segmentIter","angle2","compute","reset","sortPoints","extend","shorten","old_segment","remove","cur","destination","parent","lessThan","temp","swap","child","right","index1","index2","inter1","inter2","d1","d2","end1","end2","isEqualEpsiolon","pp","nr","core","linkedlist","procedural","timer","input","./geometry","./input","./linkedlist","./procedural","./timer",26,"Unified","./unified","_addWheelListener","elem","eventName","useCapture","_addEventListener","support","originalEvent","srcElement","deltaMode","deltaX","delatZ","preventDefault","returnValue","deltaY","wheelDelta","wheelDeltaX","detail","addEventListener","document","createElement","onmousewheel","Inputs","element","opts","preventDefaults","stopPropagation","down","up","gamepadconnected","gamepaddisconnected","scrollx","scrolly","scrollz","_keybindmap","_keyStates","_bindPressCounts","_gamepads","_gamepadButtonStates","_gamepadRaf","initEvents","onKeyEvent","inputs","wasDown","handleKeyEvent","keyCode","vkey","onMouseEvent","keycode","button","vkeycode","onContextMenu","onMouseMove","movementX","mozMovementX","webkitMovementX","movementY","mozMovementY","webkitMovementY","onMouseWheel","scale","clientHeight","innerHeight","deltaZ","vcode","currstate","XOR","handleBindingEvent","binding","ct","emitter","handleGamePadButtonEvent","pressed","isPerc","_buttonStates","updateGamepads","found","scanGamepads","cancel","gamepad","buttons","gamepadButtonNames","axes","gamepadAxesNames","request","onGamepadConnected","addGamepad","onGamepadDisconnected","removeGamepad","hasOwnProperty","gamepads","getGamepads","webkitGetGamepads","addMouseWheel","hasGamepadEvents","bind","oncontextmenu","setInterval","vkeyCode","unbind","tick","getBoundKeys","./mousewheel-polyfill","eventemitter3","request-frame","_head","_tail","_length","_nodeCache","constructor","data","_allocate","current","_free","./doublylinkedlist","Building","chance","iterations","minRadius","maxRadius","maxSides","noRotate","centers","sidesChanceObj","radiusChanceObj","integer","floating","gpcPoly","createPoly","gpcPoly2","num","getPolygonVertices","nrdoors","ceil","doors","dooredges","graph","Graph","delaunay_used","delaunay","delaunay_exists","delaunay_triangles","delaunay_lines","addDelaunayLine","connectDoor","prim","mst_lines","source","sink","outside","door","addEdge","key1","key2","../geometry/gpc","../geometry/linesegment2","../geometry/polygon2","../geometry/regularpolygon2","../geometry/vector2","./graph","delaunay-fast","Edge","capacity","nodeMap","edgeExists","findMin","usedNodes","resultEdges","random","./building","lastFrameTimeMs","lastFpsUpdate","framesThisSecond","numUpdateSteps","minFrameDelay","running","started","rafHandle","boundAnimate","animate","getSimulationTimestep","setSimulationTimestep","timestep","getFPS","getMaxAllowedFPS","setMaxAllowedFPS","Infinity","resetFrameDelta","oldFrameDelta","fun","isRunning","./gameloop"],"mappings":"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","file":"ultron.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var Delaunay;\n\n(function() {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i, dx, dy, dmax, xmid, ymid;\n\n    for(i = vertices.length; i--; ) {\n      if(vertices[i][0] < xmin) xmin = vertices[i][0];\n      if(vertices[i][0] > xmax) xmax = vertices[i][0];\n      if(vertices[i][1] < ymin) ymin = vertices[i][1];\n      if(vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n\n    return [\n      [xmid - 20 * dmax, ymid -      dmax],\n      [xmid            , ymid + 20 * dmax],\n      [xmid + 20 * dmax, ymid -      dmax]\n    ];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;\n\n    /* Check for coincident points */\n    if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)\n      throw new Error(\"Eek! Coincident points!\");\n\n    if(fabsy1y2 < EPSILON) {\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (x2 + x1) / 2.0;\n      yc  = m2 * (xc - mx2) + my2;\n    }\n\n    else if(fabsy2y3 < EPSILON) {\n      m1  = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc  = (x3 + x2) / 2.0;\n      yc  = m1 * (xc - mx1) + my1;\n    }\n\n    else {\n      m1  = -((x2 - x1) / (y2 - y1));\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc  = (fabsy1y2 > fabsy2y3) ?\n        m1 * (xc - mx1) + my1 :\n        m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for(j = edges.length; j; ) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for(i = j; i; ) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if((a === m && b === n) || (a === n && b === m)) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function(vertices, key) {\n      var n = vertices.length,\n          i, j, indices, st, open, closed, edges, dx, dy, a, b, c;\n\n      /* Bail if there aren't enough vertices to form any triangles. */\n      if(n < 3)\n        return [];\n\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n      vertices = vertices.slice(0);\n\n      if(key)\n        for(i = n; i--; )\n          vertices[i] = vertices[i][key];\n\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n      indices = new Array(n);\n\n      for(i = n; i--; )\n        indices[i] = i;\n\n      indices.sort(function(i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      \n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n      open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges  = [];\n\n      /* Incrementally add each vertex to the mesh. */\n      for(i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n        for(j = open.length; j--; ) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n          if(dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n\n          /* If we're outside the circumcircle, skip this triangle. */\n          dy = vertices[c][1] - open[j].y;\n          if(dx * dx + dy * dy - open[j].r > EPSILON)\n            continue;\n\n          /* Remove the triangle and add it's edges to the edge list. */\n          edges.push(\n            open[j].i, open[j].j,\n            open[j].j, open[j].k,\n            open[j].k, open[j].i\n          );\n          open.splice(j, 1);\n        }\n\n        /* Remove any doubled edges. */\n        dedup(edges);\n\n        /* Add a new triangle for each edge. */\n        for(j = edges.length; j; ) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n      for(i = open.length; i--; )\n        closed.push(open[i]);\n      open.length = 0;\n\n      for(i = closed.length; i--; )\n        if(closed[i].i < n && closed[i].j < n && closed[i].k < n)\n          open.push(closed[i].i, closed[i].j, closed[i].k);\n\n      /* Yay, we're done! */\n      return open;\n    },\n    contains: function(tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||\n         (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||\n         (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||\n         (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))\n        return null;\n\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n\n      /* Degenerate tri. */\n      if(i === 0.0)\n        return null;\n\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n\n      /* If we're outside the tri, fail. */\n      if(u < 0.0 || v < 0.0 || (u + v) > 1.0)\n        return null;\n\n      return [u, v];\n    }\n  };\n\n  if(typeof module !== \"undefined\")\n    module.exports = Delaunay;\n})();\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.ULTRON = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar Delaunay;\n\n(function() {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i, dx, dy, dmax, xmid, ymid;\n\n    for(i = vertices.length; i--; ) {\n      if(vertices[i][0] < xmin) xmin = vertices[i][0];\n      if(vertices[i][0] > xmax) xmax = vertices[i][0];\n      if(vertices[i][1] < ymin) ymin = vertices[i][1];\n      if(vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n\n    return [\n      [xmid - 20 * dmax, ymid -      dmax],\n      [xmid            , ymid + 20 * dmax],\n      [xmid + 20 * dmax, ymid -      dmax]\n    ];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;\n\n    /* Check for coincident points */\n    if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)\n      throw new Error(\"Eek! Coincident points!\");\n\n    if(fabsy1y2 < EPSILON) {\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (x2 + x1) / 2.0;\n      yc  = m2 * (xc - mx2) + my2;\n    }\n\n    else if(fabsy2y3 < EPSILON) {\n      m1  = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc  = (x3 + x2) / 2.0;\n      yc  = m1 * (xc - mx1) + my1;\n    }\n\n    else {\n      m1  = -((x2 - x1) / (y2 - y1));\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc  = (fabsy1y2 > fabsy2y3) ?\n        m1 * (xc - mx1) + my1 :\n        m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for(j = edges.length; j; ) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for(i = j; i; ) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if((a === m && b === n) || (a === n && b === m)) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function(vertices, key) {\n      var n = vertices.length,\n          i, j, indices, st, open, closed, edges, dx, dy, a, b, c;\n\n      /* Bail if there aren't enough vertices to form any triangles. */\n      if(n < 3)\n        return [];\n\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n      vertices = vertices.slice(0);\n\n      if(key)\n        for(i = n; i--; )\n          vertices[i] = vertices[i][key];\n\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n      indices = new Array(n);\n\n      for(i = n; i--; )\n        indices[i] = i;\n\n      indices.sort(function(i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      \n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n      open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges  = [];\n\n      /* Incrementally add each vertex to the mesh. */\n      for(i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n        for(j = open.length; j--; ) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n          if(dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n\n          /* If we're outside the circumcircle, skip this triangle. */\n          dy = vertices[c][1] - open[j].y;\n          if(dx * dx + dy * dy - open[j].r > EPSILON)\n            continue;\n\n          /* Remove the triangle and add it's edges to the edge list. */\n          edges.push(\n            open[j].i, open[j].j,\n            open[j].j, open[j].k,\n            open[j].k, open[j].i\n          );\n          open.splice(j, 1);\n        }\n\n        /* Remove any doubled edges. */\n        dedup(edges);\n\n        /* Add a new triangle for each edge. */\n        for(j = edges.length; j; ) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n      for(i = open.length; i--; )\n        closed.push(open[i]);\n      open.length = 0;\n\n      for(i = closed.length; i--; )\n        if(closed[i].i < n && closed[i].j < n && closed[i].k < n)\n          open.push(closed[i].i, closed[i].j, closed[i].k);\n\n      /* Yay, we're done! */\n      return open;\n    },\n    contains: function(tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||\n         (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||\n         (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||\n         (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))\n        return null;\n\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n\n      /* Degenerate tri. */\n      if(i === 0.0)\n        return null;\n\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n\n      /* If we're outside the tri, fail. */\n      if(u < 0.0 || v < 0.0 || (u + v) > 1.0)\n        return null;\n\n      return [u, v];\n    }\n  };\n\n  if(typeof module !== \"undefined\")\n    module.exports = Delaunay;\n})();\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n},{}],3:[function(require,module,exports){\n/**\n *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for\n *   optimal cross-browser development.\n *    Version:  v1.4.0\n *     License:  MIT\n *      Copyright Julien Etienne 2015 All Rights Reserved.\n *        github:  https://github.com/julienetie/request-frame\n *\n */\n(function (window) {\n\n/**\n * @param  {String} type - request | cancel | native.\n * @return {Function} Timing function.\n */\nfunction requestFrame(type) {\n    // The only vendor prefixes required.\n    var vendors = ['moz', 'webkit'],\n\n        // Disassembled timing function abbreviations.\n        aF = 'AnimationFrame',\n        rqAF = 'Request' + aF,\n\n        // Final assigned functions.\n        assignedRequestAnimationFrame,\n        assignedCancelAnimationFrame,\n\n        // Initial time of the timing lapse.\n        previousTime = 0,\n\n        mozRAF = window.mozRequestAnimationFrame,\n        mozCAF = window.mozCancelAnimationFrame,\n\n        // Checks for firefox 4 - 10 function pair mismatch.\n        hasMozMismatch = mozRAF && !mozCAF,\n\n        func;\n\n    // Date.now polyfill, mainly for legacy IE versions.\n    if (!Date.now) {\n        Date.now = function() {\n            return new Date().getTime();\n        };\n    }\n\n    /**\n     * hasIOS6RequestAnimationFrameBug.\n     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}\n     * - for Commentary.\n     * @Copyright 2015 - Julien Etienne. \n     * @License: MIT.\n     */\n    function hasIOS6RequestAnimationFrameBug() {\n        var webkitRAF = window.webkitRequestAnimationFrame,\n            rAF = window.requestAnimationFrame,\n\n            // CSS/ Device with max for iOS6 Devices.\n            hasMobileDeviceWidth = screen.width <= 768 ? true : false,\n\n            // Only supports webkit prefixed requestAnimtionFrane.\n            requiresWebkitprefix = !(webkitRAF && rAF),\n\n            // iOS6 webkit browsers don't support performance now.\n            hasNoNavigationTiming = window.performance ? false : true,\n\n            iOS6Notice = 'setTimeout is being used as a substitiue for' +\n            'requestAnimationFrame due to a bug within iOS 6 builds',\n\n            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&\n            hasNoNavigationTiming;\n\n        function bugCheckresults(timingFnA, timingFnB, notice) {\n            if (timingFnA || timingFnB) {\n                console.warn(notice);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function displayResults() {\n            if (hasIOS6Bug) {\n                return bugCheckresults(webkitRAF, rAF, iOS6Notice);\n            } else {\n                return false;\n            }\n        }\n\n        return displayResults();\n    }\n\n    /**\n     * Native clearTimeout function.\n     * @return {Function}\n     */\n    function clearTimeoutWithId(id) {\n        clearTimeout(id);\n    }\n\n    /**\n     * Based on a polyfill by Erik, introduced by Paul Irish & \n     * further improved by Darius Bacon.\n     * @see  {@link http://www.paulirish.com/2011/\n     * requestanimationframe-for-smart-animating}\n     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/\n     * master/requestAnimationFrame.js}\n     * @callback {Number} Timestamp.\n     * @return {Function} setTimeout Function.\n     */\n    function setTimeoutWithTimestamp(callback) {\n        var immediateTime = Date.now(),\n            lapsedTime = Math.max(previousTime + 16, immediateTime);\n        return setTimeout(function() {\n                callback(previousTime = lapsedTime);\n            },\n            lapsedTime - immediateTime);\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the setTimeoutWithTimestamp function.\n     * @return {Function}\n     */\n    function queryRequestAnimationFrame() {\n        if (Array.prototype.filter) {\n            assignedRequestAnimationFrame = window['request' + aF] ||\n                window[vendors.filter(function(vendor) {\n                    if (window[vendor + rqAF] !== undefined)\n                        return vendor;\n                }) + rqAF] || setTimeoutWithTimestamp;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedRequestAnimationFrame;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the clearTimeoutWithId function.\n     * @return {Function}\n     */\n    function queryCancelAnimationFrame() {\n        var cancellationNames = [];\n        if (Array.prototype.map) {\n            vendors.map(function(vendor) {\n                return ['Cancel', 'CancelRequest'].map(\n                    function(cancellationNamePrefix) {\n                        cancellationNames.push(vendor +\n                            cancellationNamePrefix + aF);\n                    });\n            });\n        } else {\n            return clearTimeoutWithId;\n        }\n\n        /**\n         * Checks for the prefixed cancelAnimationFrame implementation.\n         * @param  {Array} prefixedNames - An array of the prefixed names. \n         * @param  {Number} i - Iteration start point.\n         * @return {Function} prefixed cancelAnimationFrame function.\n         */\n        function prefixedCancelAnimationFrame(prefixedNames, i) {\n            var cancellationFunction;\n            for (; i < prefixedNames.length; i++) {\n                if (window[prefixedNames[i]]) {\n                    cancellationFunction = window[prefixedNames[i]];\n                    break;\n                }\n            }\n            return cancellationFunction;\n        }\n\n        // Use truthly function\n        assignedCancelAnimationFrame = window['cancel' + aF] ||\n            prefixedCancelAnimationFrame(cancellationNames, 0) ||\n            clearTimeoutWithId;\n\n        // Check for iOS 6 bug\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedCancelAnimationFrame;\n        } else {\n            return clearTimeoutWithId;\n        }\n    }\n\n    function getRequestFn() {\n        if (hasMozMismatch) {\n            return setTimeoutWithTimestamp;\n        } else {\n            return queryRequestAnimationFrame();\n        }\n    }\n\n    function getCancelFn() {\n        return queryCancelAnimationFrame();\n    }\n\n    function setNativeFn() {\n        if (hasMozMismatch) {\n            window.requestAnimationFrame = setTimeoutWithTimestamp;\n            window.cancelAnimationFrame = clearTimeoutWithId;\n        } else {\n            window.requestAnimationFrame = queryRequestAnimationFrame();\n            window.cancelAnimationFrame = queryCancelAnimationFrame();\n        }\n    }\n\n    /**\n     * The type value \"request\" singles out firefox 4 - 10 and \n     * assigns the setTimeout function if plausible.\n     */\n\n    switch (type) {\n        case 'request':\n        case '':\n            func = getRequestFn();\n            break;\n\n        case 'cancel':\n            func = getCancelFn();\n            break;\n\n        case 'native':\n            setNativeFn();\n            break;\n        default:\n            throw new Error('RequestFrame parameter is not a type.');\n    }\n    return func;\n}\n\n\n// Node.js/ CommonJS\nif (typeof module === 'object' && typeof module.exports === 'object') {\nmodule.exports = exports = requestFrame;\n}\n\n// AMD\nelse if (typeof define === 'function' && define.amd) {\ndefine(function() {\n  return requestFrame;\n});\n}\n\n// Default to window as global\nelse if (typeof window === 'object') {\nwindow.requestFrame = requestFrame;\n}\n/* global -module, -exports, -define */\n\n}((typeof window === \"undefined\" ? {} : window)));\n\n},{}],4:[function(require,module,exports){\nvar ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nvar StateStack = require('./statestack');\nvar GameLoop = require('../timer/gameloop');\nvar NOOP = function() {};\n\nexports = module.exports = Game;\n\nfunction Game () {\n  this.states = {};\n  this.statestack = new StateStack();\n  this.gameloop = new GameLoop();\n\n  var self = this;\n\n  this.gameloop.setBegin(\n    function(timestamp, frameDelta) {\n      self.begin(timestamp, frameDelta);\n      self.statestack.begin(timestamp, frameDelta);\n    }\n  );\n\n  this.gameloop.setUpdate(\n    function(simulationTimestep) {\n      self.update(simulationTimestep);\n      self.statestack.update(simulationTimestep);\n    }\n  );\n\n  this.gameloop.setRender(\n    function(percentageTimestepRemaining) {\n      // render -> game is last.\n      self.statestack.render(percentageTimestepRemaining);\n      self.render(percentageTimestepRemaining);\n    }\n  );\n\n  this.gameloop.setEnd(\n    function(fps, panic) {\n      self.end(fps. panic);\n      self.statestack.end(fps, panic);\n    }\n  );\n\n}\n\n/* GAMELOOP HANDLING */\n\nGame.prototype.start = function() {\n  return this.gameloop.start();\n};\n\nGame.prototype.stop = function() {\n  return this.gameloop.stop();\n};\n\nGame.prototype.begin = NOOP;\nGame.prototype.end = NOOP;\nGame.prototype.update = NOOP;\nGame.prototype.render = NOOP;\n\n\n\n/* STATE HANDLING */\n\nGame.prototype.addState = function(state) {\n  state.game = this;\n  this.states[state.name] = state;\n  state.create();\n  return this;\n};\n\nGame.prototype.startState = function (stateName) {\n  var state = this.states[stateName];\n  if (!state) {\n    return;\n  }\n  return this.statestack.push(this.states[stateName]);\n};\n\nGame.prototype.stopState = function (stateName) {\n  var state = this.states[stateName];\n  if (!state) {\n    return;\n  }\n  return this.statestack.pop(state);\n};\n\n},{\"../timer/gameloop\":34,\"./statestack\":9}],6:[function(require,module,exports){\nmodule.exports = {\n  Game: require('./game'),\n  State: require('./state'),\n  StateList: require('./statelist'),\n  StateStack: require('./statestack')\n};\n\n},{\"./game\":5,\"./state\":7,\"./statelist\":8,\"./statestack\":9}],7:[function(require,module,exports){\n'use strict';\n\nexports = module.exports = State;\n\nvar NOOP = function() {};\n\nfunction State ( name ) {\n    this.name = name;\n}\n\nState.prototype.create = NOOP;\nState.prototype.begin = NOOP;\nState.prototype.update = NOOP;\nState.prototype.render = NOOP;\nState.prototype.end = NOOP;\nState.prototype.onEnter = NOOP;\nState.prototype.onExit = NOOP;\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nexports = module.exports = StateList;\n\nfunction StateList() {\n    this.states = [];\n}\n\nStateList.prototype.pop = function () {\n    return this.states.pop();\n};\n\nStateList.prototype.push = function ( state ) {\n    return this.states.push(state);\n};\n\nStateList.prototype.top = function (depth) {\n    depth = depth || 0;\n    return this.states[this.states.length-(depth+1)];\n};\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar StateList = require('./statelist');\n\nexports = module.exports = StateStack;\n\nfunction StateStack() {\n    this.states = new StateList();\n}\n\nStateStack.prototype.begin = function (timestamp, frameDelta) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.begin(timestamp, frameDelta) ) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.update = function (simulationTimestep) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.update(simulationTimestep)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.render = function (percentageTimestepRemaining) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.render(percentageTimestepRemaining)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.end = function (fps, panic) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.end(fps, panic)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.pop = function () {\n    var state = this.states.pop();\n    state.onExit();\n    return state;\n};\n\nStateStack.prototype.push = function (state) {\n    this.states.push(state);\n    return state.onEnter();\n};\n\n},{\"./statelist\":8}],10:[function(require,module,exports){\n'use strict';\n\nvar gpcas = gpcas || {};\ngpcas.util = {};\ngpcas.geometry = {};\n\nexports = module.exports = gpcas;\n\n//////////\nvar Clip, BundleState, LmtNode, TopPolygonNode, AetTree, HState, VertexType, VertexNode, ItNodeTable, StNode;\n\n//Object.prototype.equals = function(x) {\nfunction equals(x1, x) {\n\n    var p;\n    for(p in x1) {\n        if(typeof(x[p])==='undefined') {return false;}\n    }\n\n    for(p in x1) {\n        if (x1[p]) {\n            switch(typeof(x1[p])) {\n                case 'object':\n                    if (!equals(x1[p], x[p])) { return false; } break;\n                case 'function':\n                    if (typeof(x[p])==='undefined' ||\n                        (p !== 'equals' && x1[p].toString() !== x[p].toString()))\n                        return false;\n                    break;\n                default:\n                    if (x1[p] !== x[p]) { return false; }\n            }\n        } else {\n            if (x[p])\n                return false;\n        }\n    }\n\n    for(p in x) {\n        if(typeof(x1[p])==='undefined') {return false;}\n    }\n\n    return true;\n}\n///point\nvar Point = function(x,y) {\n    this.x = x;\n    this.y = y;\n};\ngpcas.geometry.Point = Point;\n\n////////////// CLASS ArrayHelper ////////////////////////////////////\ngpcas.util.ArrayHelper = function() {};\nvar gpcstatic = gpcas.util.ArrayHelper;\n\ngpcstatic.create2DArray = function(x,y){\n    var a = [];\n    for (var i=0; i<x; i++){\n        a[i]= [];\n    }\n    return a;\n};\ngpcstatic.valueEqual = function(obj1, obj2) {\n    if (obj1===obj2) return true;\n    if(equals(obj1, obj2)) return true;\n\n    return false;\n}\ngpcstatic.sortPointsClockwise = function(vertices) {\n    var isArrayList  = false;\n\n    if (vertices instanceof gpcas.util.ArrayList){\n        vertices= vertices.toArray();\n        isArrayList=true;\n    }\n\n    //point\n    var maxTop   = null;\n    var maxBottom  = null;\n    var maxLeft   = null;\n    var maxRight  = null;\n\n\n    var maxLeftIndex;\n    var newVertices = vertices;\n\n\n\n    for (var i  = 0; i<vertices.length; i++){\n        var vertex  = vertices[i] ;\n\n        if ((maxTop===null)||(maxTop.y>vertex.y)||((maxTop.y===vertex.y)&&(vertex.x<maxTop.x))){\n            maxTop=vertex;\n        }\n        if ((maxBottom===null)||(maxBottom.y<vertex.y)||((maxBottom.y===vertex.y)&&(vertex.x>maxBottom.x))){\n            maxBottom=vertex;\n        }\n        if ((maxLeft===null)||(maxLeft.x>vertex.x)||((maxLeft.x===vertex.x)&&(vertex.y>maxLeft.y))){\n            maxLeft=vertex;\n            maxLeftIndex=i;\n        }\n        if ((maxRight===null)||(maxRight.x<vertex.x)||((maxRight.x===vertex.x)&&(vertex.y<maxRight.y))){\n            maxRight=vertex;\n        }\n    }\n\n    if (maxLeftIndex>0){\n        newVertices = []\n        var j = 0;\n        for (var i=maxLeftIndex; i<vertices.length;i++){\n            newVertices[j++]=vertices[i];\n        }\n        for (var i=0; i<maxLeftIndex; i++){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n\n    var reverse  = false;\n    for(var i=0 ; i<vertices.length;i++) {\n        var vertex = vertices[i];\n        if (equals(vertex, maxBottom)){\n            reverse=true;\n            break;\n        } else if (equals(vertex, maxTop)){\n            break;\n        }\n    }\n    if (reverse){\n        newVertices=[]\n        newVertices[0]=vertices[0];\n        var j =1;\n        for (var i=vertices.length-1; i>0; i--){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n    return (isArrayList?(new gpcas.util.ArrayList(vertices)):(vertices));\n}\n\n/////////////// END ArrayHelper  ////////////////////////////////////////////////\n\nvar ArrayHelper = gpcas.util.ArrayHelper;\n////////////////// CLASS ArrayList  /////////////////////////\n\ngpcas.util.ArrayList = function(arr) {\n\tthis._array = [];\n\tif(arr != null) {\n\t\tthis._array=arr;\n\t}\n\n};\nvar p = gpcas.util.ArrayList.prototype;\n\np.add = function(value) {\n    this._array.push(value);\n};\np.get = function(index) {\n    return this._array[index];\n};\np.size = function() {\n\treturn this._array.length;\n};\np.clear = function() {\n    this._array  = [];\n\n};\np.equals = function(list) {\n    if (this._array.length != list.size()) return false;\n\n    for (var i = 0; i<this._array.length ; i++){\n        var obj1  = this._array[i];\n        var obj2  = list.get(i);\n\n        if (!ArrayHelper.valueEqual(obj1,obj2)){\n            return false;\n        }\n    }\n    return true;\n}\np.hashCode = function(){\n    return 0;\n};\np.isEmpty = function() {\n    return (this._array.length == 0);\n}\np.toArray = function(){\n    return this._array;\n}\n///////////////// END ArrayList ////////////////////////\n\n\n\n\n\n\ngpcas.geometry.Clip = function(){};\ngpcas.geometry.Clip.DEBUG = false;\ngpcas.geometry.Clip.GPC_EPSILON = 2.2204460492503131e-016;\ngpcas.geometry.Clip.GPC_VERSION = \"2.31\";\ngpcas.geometry.Clip.LEFT = 0;\ngpcas.geometry.Clip.RIGHT = 1;\ngpcas.geometry.Clip.ABOVE = 0;\ngpcas.geometry.Clip.BELOW = 1;\ngpcas.geometry.Clip.CLIP = 0;\ngpcas.geometry.Clip.SUBJ = 1;\nClip = gpcas.geometry.Clip;\n\n\n\nvar p = gpcas.geometry.Clip.prototype;\nvar gpcstatic = gpcas.geometry.Clip;\n\n// ----------------------\n// --- gpcstatic Methods ---\n// ----------------------\n\n/**\n * Return the intersection of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he intersection with\n * @param p2        One of the polygons to performt he intersection with\n * @param polyClass The type of <code>Poly</code> to return\n */\n\ngpcstatic.intersection = function(p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_INT, p1, p2, polyClass );\n};\n\n\n\n/**\n * Return the union of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he union with\n * @param p2        One of the polygons to performt he union with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.union = function(p1, p2, polyClass) {\n\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n\n\treturn gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_UNION, p1, p2, polyClass );\n};\n\n\n/**\n * Return the xor of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he xor with\n * @param p2        One of the polygons to performt he xor with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.xor = function( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_XOR, p1, p2, polyClass );\n};\n\n\n/**\n * Return the difference of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        Polygon from which second polygon will be substracted\n * @param p2        Second polygon\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.difference = function ( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_DIFF, p2, p1, polyClass );\n}\ngpcstatic.intersection = function( p1, p2) {\n\treturn gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, \"PolyDefault.class\" );\n}\n\n\n// -----------------------\n// --- Private Methods ---\n// -----------------------\n\n/**\n * Create a new <code>Poly</code> type object using <code>polyClass</code>.\n */\ngpcstatic.createNewPoly = function ( polyClass) {\n    /* TODO :\n     try\n     {\n     return (Poly)polyClass.newInstance();\n     }\n     catch( var e:Exception)\n     {\n     throw new RuntimeException(e);\n     }*/\n    if (polyClass==\"PolySimple\"){\n        return new gpcas.geometry.PolySimple();\n    }\n    if (polyClass==\"PolyDefault\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\tif (polyClass==\"PolyDefault.class\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\n    return null;\n}\n\n/**\n * <code>clip()</code> is the main method of the clipper algorithm.\n * This is where the conversion from really begins.\n */\ngpcstatic.clip = function ( op, subj, clip, polyClass) {\n    var result = gpcas.geometry.Clip.createNewPoly( polyClass ) ;\n\n    /* Test for trivial NULL result cases */\n    if( (subj.isEmpty() && clip.isEmpty()) ||\n        (subj.isEmpty() && ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF))) ||\n        (clip.isEmpty() &&  (op == gpcas.geometry.OperationType.GPC_INT)) )\n    {\n        return result ;\n    }\n\n\n\n    /* Identify potentialy contributing contours */\n    if( ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF)) &&\n        !subj.isEmpty() && !clip.isEmpty() )\n    {\n        gpcas.geometry.Clip.minimax_test(subj, clip, op);\n    }\n\n\t//console.log(\"SUBJ \" + subj);\n    //console.log(\"CLIP \" + clip);\n\n\n\n    /* Build LMT */\n    var lmt_table = new gpcas.geometry.LmtTable();\n    var sbte = new gpcas.geometry.ScanBeamTreeEntries();\n    var s_heap= null ;\n    var c_heap= null ;\n\n\n\n    if (!subj.isEmpty())\n    {\n        s_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, subj, gpcas.geometry.Clip.SUBJ, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for subj ---------\");\n        lmt_table.print();\n    }\n    if (!clip.isEmpty())\n    {\n        c_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, clip, gpcas.geometry.Clip.CLIP, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for clip ---------\");\n        lmt_table.print();\n    }\n\n    /* Return a NULL result if no contours contribute */\n    if (lmt_table.top_node == null)\n    {\n        return result;\n    }\n\n    /* Build scanbeam table from scanbeam tree */\n    var sbt = sbte.build_sbt();\n\n\n\n    var parity= [];\n    parity[0] = gpcas.geometry.Clip.LEFT ;\n    parity[1] = gpcas.geometry.Clip.LEFT ;\n\n    /* Invert clip polygon for difference operation */\n    if (op == gpcas.geometry.OperationType.GPC_DIFF)\n    {\n        parity[Clip.CLIP]= gpcas.geometry.Clip.RIGHT;\n    }\n\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(sbt);\n    }\n\n    var local_min = lmt_table.top_node ;\n\n    var out_poly = new TopPolygonNode(); // used to create resulting Poly\n\n    var aet = new AetTree();\n    var scanbeam = 0;\n\n\n\n    /* Process each scanbeam */\n    while( scanbeam < sbt.length )\n    {\n        /* Set yb and yt to the bottom and top of the scanbeam */\n        var yb = sbt[scanbeam++];\n        var yt = 0.0;\n        var dy = 0.0;\n        if( scanbeam < sbt.length )\n        {\n            yt = sbt[scanbeam];\n            dy = yt - yb;\n        }\n\n\n\n        /* === SCANBEAM BOUNDARY PROCESSING ================================ */\n\n        /* If LMT node corresponding to yb exists */\n        if (local_min != null )\n        {\n            if (local_min.y == yb)\n            {\n                /* Add edges starting at this local minimum to the AET */\n                for( var edge= local_min.first_bound; (edge != null) ; edge= edge.next_bound)\n                {\n                    gpcas.geometry.Clip.add_edge_to_aet( aet, edge );\n                }\n\n                local_min = local_min.next;\n            }\n        }\n\n        if( gpcas.geometry.Clip.DEBUG )\n        {\n            aet.print();\n        }\n        /* Set dummy previous x value */\n        var px = -Number.MAX_VALUE;\n\n        /* Create bundles within AET */\n        var e0 = aet.top_node ;\n        var e1 = aet.top_node ;\n\n\n\n        /* Set up bundle fields of first edge */\n        aet.top_node.bundle[Clip.ABOVE][ aet.top_node.type ] = (aet.top_node.top.y != yb) ? 1: 0;\n        aet.top_node.bundle[Clip.ABOVE][ ((aet.top_node.type==0) ? 1: 0) ] = 0;\n        aet.top_node.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n        for (var next_edge= aet.top_node.next ; (next_edge != null); next_edge = next_edge.next)\n        {\n            var ne_type= next_edge.type ;\n            var ne_type_opp= ((next_edge.type==0) ? 1: 0); //next edge type opposite\n\n            /* Set up bundle fields of next edge */\n            next_edge.bundle[Clip.ABOVE][ ne_type     ]= (next_edge.top.y != yb) ? 1: 0;\n            next_edge.bundle[Clip.ABOVE][ ne_type_opp ] = 0;\n            next_edge.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n            /* Bundle edges above the scanbeam boundary if they coincide */\n            if ( next_edge.bundle[Clip.ABOVE][ne_type] == 1)\n            {\n                if (Clip.EQ(e0.xb, next_edge.xb) && gpcas.geometry.Clip.EQ(e0.dx, next_edge.dx) && (e0.top.y != yb))\n                {\n                    next_edge.bundle[Clip.ABOVE][ ne_type     ] ^= e0.bundle[Clip.ABOVE][ ne_type     ];\n                    next_edge.bundle[Clip.ABOVE][ ne_type_opp ]  = e0.bundle[Clip.ABOVE][ ne_type_opp ];\n                    next_edge.bstate[Clip.ABOVE] = BundleState.BUNDLE_HEAD;\n                    e0.bundle[Clip.ABOVE][Clip.CLIP] = 0;\n                    e0.bundle[Clip.ABOVE][Clip.SUBJ] = 0;\n                    e0.bstate[Clip.ABOVE] = BundleState.BUNDLE_TAIL;\n                }\n                e0 = next_edge;\n\n            }\n        }\n\n        var horiz= [] ;\n        horiz[Clip.CLIP]= HState.NH;\n        horiz[Clip.SUBJ]= HState.NH;\n\n        var exists= [] ;\n        exists[Clip.CLIP] = 0;\n        exists[Clip.SUBJ] = 0;\n\n        var cf= null ;\n\n        /* Process each edge at this scanbeam boundary */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next )\n        {\n            exists[Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP] + (edge.bundle[Clip.BELOW][Clip.CLIP] << 1);\n            exists[Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ] + (edge.bundle[Clip.BELOW][Clip.SUBJ] << 1);\n\n            if( (exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0) )\n            {\n                /* Set bundle side */\n                edge.bside[Clip.CLIP] = parity[Clip.CLIP];\n                edge.bside[Clip.SUBJ] = parity[Clip.SUBJ];\n\n                var contributing= false ;\n                var br=0;\n                var bl=0;\n                var tr=0;\n                var tl=0;\n                /* Determine contributing status and quadrant occupancies */\n                if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && ((parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && ((parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP]!=0) && (parity[Clip.SUBJ]!=0)) ? 1: 0;\n                    bl = ( ((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1: 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) !=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0)) !=0) ) ? 1: 0;\n                    tl = (((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0))?1:0;\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                {\n                    contributing= (exists[Clip.CLIP]!=0) || (exists[Clip.SUBJ]!=0);\n                    br= (parity[Clip.CLIP]) ^ (parity[Clip.SUBJ]);\n                    bl= (parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) ^ (parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    tr= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0));\n                    tl= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])\n                        ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]);\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && (!(parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && (!(parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br= ((parity[Clip.CLIP]!=0) || (parity[Clip.SUBJ]!=0))?1:0;\n                    bl= (((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                    tr= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0))!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0))!=0) ) ?1:0;\n                    tl= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0) ) ? 1:0;\n                }\n                else\n                {\n                    //console.log(\"ERROR : Unknown op\");\n                }\n\n                /* Update parity */\n                parity[Clip.CLIP] ^= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                parity[Clip.SUBJ] ^= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n\n                /* Update horizontal state */\n                if (exists[Clip.CLIP]!=0)\n                {\n                    horiz[Clip.CLIP] = HState.next_h_state[horiz[Clip.CLIP]][((exists[Clip.CLIP] - 1) << 1) + parity[Clip.CLIP]];\n                }\n                if( exists[Clip.SUBJ]!=0)\n                {\n                    horiz[Clip.SUBJ] = HState.next_h_state[horiz[Clip.SUBJ]][((exists[Clip.SUBJ] - 1) << 1) + parity[Clip.SUBJ]];\n                }\n\n                if (contributing)\n                {\n                    var xb= edge.xb;\n\n\n\n                    var vclass= VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                        case VertexType.IMN:\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.ELI:\n                            edge.outp[Clip.BELOW].add_left( xb, yb);\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            break;\n                        case VertexType.EMX:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            break;\n                        case VertexType.ILI:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.IRI:\n                            edge.outp[Clip.BELOW].add_right( xb, yb );\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMX:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb );\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMM:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.EMM:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.LED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_left( xb, yb);\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        case VertexType.RED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_right( xb, yb );\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing conditional */\n            } /* End of edge exists conditional */\n            if( gpcas.geometry.Clip.DEBUG )\n            {\n                out_poly.print();\n            }\n\t\t\tout_poly.print();\n        } /* End of AET loop */\n\n\n\n        /* Delete terminating edges from the AET, otherwise compute xt */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n        {\n            if (edge.top.y == yb)\n            {\n                var prev_edge= edge.prev;\n                var next_edge= edge.next;\n\n                if (prev_edge != null)\n                    prev_edge.next = next_edge;\n                else\n                    aet.top_node = next_edge;\n\n                if (next_edge != null )\n                    next_edge.prev = prev_edge;\n\n                /* Copy bundle head state to the adjacent tail edge if required */\n                if ((edge.bstate[Clip.BELOW] == BundleState.BUNDLE_HEAD) && (prev_edge!=null))\n                {\n                    if (prev_edge.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                    {\n                        prev_edge.outp[Clip.BELOW]= edge.outp[Clip.BELOW];\n                        prev_edge.bstate[Clip.BELOW]= BundleState.UNBUNDLED;\n                        if ( prev_edge.prev != null)\n                        {\n                            if (prev_edge.prev.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                            {\n                                prev_edge.bstate[Clip.BELOW] = BundleState.BUNDLE_HEAD;\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if (edge.top.y == yt)\n                    edge.xt= edge.top.x;\n                else\n                    edge.xt= edge.bot.x + edge.dx * (yt - edge.bot.y);\n            }\n        }\n\n        if (scanbeam < sbte.sbt_entries )\n        {\n            /* === SCANBEAM INTERIOR PROCESSING ============================== */\n\n            /* Build intersection table for the current scanbeam */\n            var it_table= new ItNodeTable();\n            it_table.build_intersection_table(aet, dy);\n\n\n\n            /* Process each node in the intersection table */\n\n            for (var intersect= it_table.top_node ; (intersect != null); intersect = intersect.next)\n            {\n\n\n\t\t\t\te0= intersect.ie[0];\n\t\t\t\te1= intersect.ie[1];\n\n                /* Only generate output for contributing intersections */\n\n                if ( ((e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)) &&\n                    ((e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)))\n                {\n                    var p= e0.outp[Clip.ABOVE];\n                    var q= e1.outp[Clip.ABOVE];\n                    var ix= intersect.point.x;\n                    var iy= intersect.point.y + yb;\n\n                    var in_clip= ( ( (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e0.bside[Clip.CLIP]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&  (e1.bside[Clip.CLIP]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&\n                        (e0.bside[Clip.CLIP]!=0) && (e1.bside[Clip.CLIP]!=0) ) ) ? 1: 0;\n\n                    var in_subj= ( ( (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e0.bside[Clip.SUBJ]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&  (e1.bside[Clip.SUBJ]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&\n                        (e0.bside[Clip.SUBJ]!=0) && (e1.bside[Clip.SUBJ]!=0) ) ) ? 1: 0;\n\n                    var tr=0\n                    var tl=0;\n                    var br=0;\n                    var bl=0;\n                    /* Determine quadrant occupancies */\n                    if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                    {\n                        tr= ((in_clip!=0) && (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1:0;\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                    {\n                        tr= in_clip^ in_subj;\n                        tl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        br= (in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        bl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])\n                            ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                    {\n                        tr= ((in_clip!=0) || (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) ||\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                    }\n                    else\n                    {\n                        //console.log(\"ERROR : Unknown op type, \"+op);\n                    }\n\n                    var vclass = VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (p != null)\n                            {\n                                p.add_right(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.ELI:\n                            if (q != null)\n                            {\n                                q.add_left(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.EMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left( ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ILI:\n                            if (p != null)\n                            {\n                                p.add_left(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IRI:\n                            if (q!=null)\n                            {\n                                q.add_right(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        case VertexType.EMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing intersection conditional */\n\n                /* Swap bundle sides in response to edge crossing */\n                if (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e1.bside[Clip.CLIP] = (e1.bside[Clip.CLIP]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e0.bside[Clip.CLIP]= (e0.bside[Clip.CLIP]==0)?1:0;\n                if (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e1.bside[Clip.SUBJ]= (e1.bside[Clip.SUBJ]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e0.bside[Clip.SUBJ]= (e0.bside[Clip.SUBJ]==0)?1:0;\n\n                /* Swap e0 and e1 bundles in the AET */\n                var prev_edge= e0.prev;\n                var next_edge= e1.next;\n                if (next_edge != null)\n                {\n                    next_edge.prev = e0;\n                }\n\n                if (e0.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD)\n                {\n                    var search= true;\n                    while (search)\n                    {\n                        prev_edge= prev_edge.prev;\n                        if (prev_edge != null)\n                        {\n                            if (prev_edge.bstate[Clip.ABOVE] != BundleState.BUNDLE_TAIL)\n                            {\n                                search= false;\n                            }\n                        }\n                        else\n                        {\n                            search= false;\n                        }\n                    }\n                }\n                if (prev_edge == null)\n                {\n                    aet.top_node.prev = e1;\n                    e1.next           = aet.top_node;\n                    aet.top_node      = e0.next;\n                }\n                else\n                {\n                    prev_edge.next.prev = e1;\n                    e1.next             = prev_edge.next;\n                    prev_edge.next      = e0.next;\n                }\n                e0.next.prev = prev_edge;\n                e1.next.prev = e1;\n                e0.next      = next_edge;\n                if( gpcas.geometry.Clip.DEBUG )\n                {\n                    out_poly.print();\n                }\n            } /* End of IT loop*/\n\n            /* Prepare for next scanbeam */\n            for ( var edge= aet.top_node; (edge != null); edge = edge.next)\n            {\n                var next_edge= edge.next;\n                var succ_edge= edge.succ;\n                if ((edge.top.y == yt) && (succ_edge!=null))\n                {\n                    /* Replace AET edge by its successor */\n                    succ_edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    succ_edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    succ_edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    succ_edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    var prev_edge= edge.prev;\n                    if ( prev_edge != null )\n                        prev_edge.next = succ_edge;\n                    else\n                        aet.top_node = succ_edge;\n                    if (next_edge != null)\n                        next_edge.prev= succ_edge;\n                    succ_edge.prev = prev_edge;\n                    succ_edge.next = next_edge;\n                }\n                else\n                {\n                    /* Update this edge */\n                    edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    edge.xb= edge.xt;\n                }\n                edge.outp[Clip.ABOVE]= null;\n            }\n        }\n    } /* === END OF SCANBEAM PROCESSING ================================== */\n\n    /* Generate result polygon from out_poly */\n    result = out_poly.getResult(polyClass);\n\t//console.log(\"result = \"+result);\n\n    return result ;\n}\n\ngpcstatic.EQ = function(a, b) {\n    return (Math.abs(a - b) <= gpcas.geometry.Clip.GPC_EPSILON);\n}\n\ngpcstatic.PREV_INDEX = function( i, n) {\n    return ((i - 1+ n) % n);\n}\n\ngpcstatic.NEXT_INDEX = function(i, n) {\n    return ((i + 1) % n);\n}\n\ngpcstatic.OPTIMAL = function ( p, i) {\n    return (p.getY(gpcas.geometry.Clip.PREV_INDEX (i, p.getNumPoints())) != p.getY(i)) ||\n        (p.getY(gpcas.geometry.Clip.NEXT_INDEX(i, p.getNumPoints())) != p.getY(i)) ;\n}\n\ngpcstatic.create_contour_bboxes = function (p)\n{\n    var box= [] ;\n\n    /* Construct contour bounding boxes */\n    for ( var c= 0; c < p.getNumInnerPoly(); c++)\n    {\n        var inner_poly= p.getInnerPoly(c);\n        box[c] = inner_poly.getBounds();\n    }\n    return box;\n}\n\ngpcstatic.minimax_test = function ( subj, clip, op){\n    var s_bbox= gpcas.geometry.Clip.create_contour_bboxes(subj);\n\tvar c_bbox= gpcas.geometry.Clip.create_contour_bboxes(clip);\n\n\tvar subj_num_poly= subj.getNumInnerPoly();\n\tvar clip_num_poly= clip.getNumInnerPoly();\n\tvar o_table = ArrayHelper.create2DArray(subj_num_poly,clip_num_poly);\n\n\t/* Check all subject contour bounding boxes against clip boxes */\n\tfor( var s= 0; s < subj_num_poly; s++ )\n\t{\n\t    for( var c= 0; c < clip_num_poly ; c++ )\n\t    {\n\t        o_table[s][c] =\n\t            (!((s_bbox[s].getMaxX() < c_bbox[c].getMinX()) ||\n\t                (s_bbox[s].getMinX() > c_bbox[c].getMaxX()))) &&\n\t                (!((s_bbox[s].getMaxY() < c_bbox[c].getMinY()) ||\n\t                    (s_bbox[s].getMinY() > c_bbox[c].getMaxY())));\n\t    }\n\t}\n\n\t/* For each clip contour, search for any subject contour overlaps */\n\tfor( var c= 0; c < clip_num_poly; c++ )\n\t{\n\t    var overlap= false;\n\t    for( var s= 0; !overlap && (s < subj_num_poly) ; s++)\n\t    {\n\t        overlap = o_table[s][c];\n\t    }\n\t    if (!overlap)\n\t    {\n\t        clip.setContributing( c, false ); // Flag non contributing status\n\t    }\n\t}\n\n\tif (op == gpcas.geometry.OperationType.GPC_INT)\n\t{\n\t    /* For each subject contour, search for any clip contour overlaps */\n\t    for ( var s= 0; s < subj_num_poly; s++)\n\t    {\n\t        var overlap= false;\n\t        for ( var c= 0; !overlap && (c < clip_num_poly); c++)\n\t        {\n\t            overlap = o_table[s][c];\n\t        }\n\t        if (!overlap)\n\t        {\n\t            subj.setContributing( s, false ); // Flag non contributing status\n\t        }\n\t    }\n\t}\n}\n\ngpcstatic.bound_list = function( lmt_table, y) {\n    if( lmt_table.top_node == null )\n    {\n        lmt_table.top_node = new LmtNode(y);\n        return lmt_table.top_node ;\n    }\n    else\n    {\n        var prev= null ;\n        var node= lmt_table.top_node ;\n        var done= false ;\n        while( !done )\n        {\n            if( y < node.y )\n            {\n                /* Insert a new LMT node before the current node */\n                var existing_node= node ;\n                node = new LmtNode(y);\n                node.next = existing_node ;\n                if( prev == null )\n                {\n                    lmt_table.top_node = node ;\n                }\n                else\n                {\n                    prev.next = node ;\n                }\n                //               if( existing_node == lmt_table.top_node )\n                //               {\n                //                  lmt_table.top_node = node ;\n                //               }\n                done = true ;\n            }\n            else if ( y > node.y )\n            {\n                /* Head further up the LMT */\n                if( node.next == null )\n                {\n                    node.next = new LmtNode(y);\n                    node = node.next ;\n                    done = true ;\n                }\n                else\n                {\n                    prev = node ;\n                    node = node.next ;\n                }\n            }\n            else\n            {\n                /* Use this existing LMT node */\n                done = true ;\n            }\n        }\n        return node ;\n    }\n}\n\ngpcstatic.insert_bound = function ( lmt_node, e) {\n    if( lmt_node.first_bound == null )\n{\n    /* Link node e to the tail of the list */\n    lmt_node.first_bound = e ;\n}\nelse\n{\n    var done= false ;\n    var prev_bound= null ;\n    var current_bound= lmt_node.first_bound ;\n    while( !done )\n    {\n        /* Do primary sort on the x field */\n        if (e.bot.x <  current_bound.bot.x)\n        {\n            /* Insert a new node mid-list */\n            if( prev_bound == null )\n            {\n                lmt_node.first_bound = e ;\n            }\n            else\n            {\n                prev_bound.next_bound = e ;\n            }\n            e.next_bound = current_bound ;\n\n            //               EdgeNode existing_bound = current_bound ;\n            //               current_bound = e ;\n            //               current_bound.next_bound = existing_bound ;\n            //               if( lmt_node.first_bound == existing_bound )\n            //               {\n            //                  lmt_node.first_bound = current_bound ;\n            //               }\n            done = true ;\n        }\n        else if (e.bot.x == current_bound.bot.x)\n        {\n            /* Do secondary sort on the dx field */\n            if (e.dx < current_bound.dx)\n            {\n                /* Insert a new node mid-list */\n                if( prev_bound == null )\n                {\n                    lmt_node.first_bound = e ;\n                }\n                else\n                {\n                    prev_bound.next_bound = e ;\n                }\n                e.next_bound = current_bound ;\n                //                  EdgeNode existing_bound = current_bound ;\n                //                  current_bound = e ;\n                //                  current_bound.next_bound = existing_bound ;\n                //                  if( lmt_node.first_bound == existing_bound )\n                //                  {\n                //                     lmt_node.first_bound = current_bound ;\n                //                  }\n                done = true ;\n            }\n            else\n            {\n                /* Head further down the list */\n                if( current_bound.next_bound == null )\n                {\n                    current_bound.next_bound = e ;\n                    done = true ;\n                }\n                else\n                {\n                    prev_bound = current_bound ;\n                    current_bound = current_bound.next_bound ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further down the list */\n            if( current_bound.next_bound == null )\n            {\n                current_bound.next_bound = e ;\n                done = true ;\n            }\n            else\n            {\n                prev_bound = current_bound ;\n                current_bound = current_bound.next_bound ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_edge_to_aet = function ( aet, edge) {\n    if ( aet.top_node == null )\n{\n    /* Append edge onto the tail end of the AET */\n    aet.top_node = edge;\n    edge.prev = null ;\n    edge.next= null;\n}\nelse\n{\n    var current_edge= aet.top_node ;\n    var prev= null ;\n    var done= false ;\n    while( !done )\n    {\n        /* Do primary sort on the xb field */\n        if (edge.xb < current_edge.xb)\n        {\n            /* Insert edge here (before the AET edge) */\n            edge.prev= prev;\n            edge.next= current_edge ;\n            current_edge.prev = edge ;\n            if( prev == null )\n            {\n                aet.top_node = edge ;\n            }\n            else\n            {\n                prev.next = edge ;\n            }\n            //               if( current_edge == aet.top_node )\n            //               {\n            //                  aet.top_node = edge ;\n            //               }\n            //               current_edge = edge ;\n            done = true;\n        }\n        else if (edge.xb == current_edge.xb)\n        {\n            /* Do secondary sort on the dx field */\n            if (edge.dx < current_edge.dx)\n            {\n                /* Insert edge here (before the AET edge) */\n                edge.prev= prev;\n                edge.next= current_edge ;\n                current_edge.prev = edge ;\n                if( prev == null )\n                {\n                    aet.top_node = edge ;\n                }\n                else\n                {\n                    prev.next = edge ;\n                }\n                //                  if( current_edge == aet.top_node )\n                //                  {\n                //                     aet.top_node = edge ;\n                //                  }\n                //                  current_edge = edge ;\n                done = true;\n            }\n            else\n            {\n                /* Head further into the AET */\n                prev = current_edge ;\n                if( current_edge.next == null )\n                {\n                    current_edge.next = edge ;\n                    edge.prev = current_edge ;\n                    edge.next = null ;\n                    done = true ;\n                }\n                else\n                {\n                    current_edge = current_edge.next ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further into the AET */\n            prev = current_edge ;\n            if( current_edge.next == null )\n            {\n                current_edge.next = edge ;\n                edge.prev = current_edge ;\n                edge.next = null ;\n                done = true ;\n            }\n            else\n            {\n                current_edge = current_edge.next ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_to_sbtree = function ( sbte, y) {\n    if( sbte.sb_tree == null )\n\t\t{\n\t\t    /* Add a new tree node here */\n\t\t    sbte.sb_tree = new gpcas.geometry.ScanBeamTree( y );\n\t\t    sbte.sbt_entries++ ;\n\t\t    return ;\n\t\t}\n\tvar tree_node= sbte.sb_tree ;\n\tvar done= false ;\n\twhile( !done )\n\t{\n\t    if ( tree_node.y > y)\n\t    {\n\t        if( tree_node.less == null )\n\t        {\n\t            tree_node.less = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.less ;\n\t        }\n\t    }\n\t    else if ( tree_node.y < y)\n\t    {\n\t        if( tree_node.more == null )\n\t        {\n\t            tree_node.more = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.more ;\n\t        }\n\t    }\n\t    else\n\t    {\n\t        done = true ;\n\t    }\n\t}\n}\n\n\ngpcstatic.build_lmt = function( lmt_table,\n\t\t\t\t\t\t\tsbte,\n\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\ttype, //poly type SUBJ/Clip.CLIP\n\t\t\t\t\t\t\top) {\n\t\t\t/* Create the entire input polygon edge table in one go */\n\t\t\tvar edge_table= new gpcas.geometry.EdgeTable();\n\n\t\t\tfor ( var c= 0; c < p.getNumInnerPoly(); c++)\n\t\t\t{\n\t\t\t\tvar ip= p.getInnerPoly(c);\n\t\t\t\tif( !ip.isContributing(0) )\n\t\t\t\t{\n\t\t\t\t\t/* Ignore the non-contributing contour */\n\t\t\t\t\tip.setContributing(0, true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\n\t\t\t\t\t/* Perform contour optimisation */\n\t\t\t\t\tvar num_vertices= 0;\n\t\t\t\t\tvar e_index= 0;\n\t\t\t\t\tedge_table = new gpcas.geometry.EdgeTable();\n\t\t\t\t\tfor ( var i= 0; i < ip.getNumPoints(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( gpcas.geometry.Clip.OPTIMAL(ip, i) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x= ip.getX(i);\n\t\t\t\t\t\t\tvar y= ip.getY(i);\n\t\t\t\t\t\t\tedge_table.addNode( x, y );\n\n\t\t\t\t\t\t\t/* Record vertex in the scanbeam table */\n                            gpcas.geometry.Clip.add_to_sbtree( sbte, ip.getY(i) );\n\n\t\t\t\t\t\t\tnum_vertices++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour forward pass */\n\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a forward local minimum... */\n\t\t\t\t\t\tif( edge_table.FWD_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the next local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.NEXT_INDEX( min, num_vertices );\n\t\t\t\t\t\t\twhile( edge_table.NOT_FMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.NEXT_INDEX( max, num_vertices );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the next edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = gpcas.geometry.BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor ( var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv = gpcas.geometry.Clip.NEXT_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x= ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y= ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx= (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null ;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"fwd\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index += num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour reverse pass */\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a reverse local minimum... */\n\t\t\t\t\t\tif ( edge_table.REV_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the previous local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.PREV_INDEX(min, num_vertices);\n\t\t\t\t\t\t\twhile( edge_table.NOT_RMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.PREV_INDEX(max, num_vertices);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the previous edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor (var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv= gpcas.geometry.Clip.PREV_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y = ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null ;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"rev\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index+= num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn edge_table;\n\t\t}\n\n\ngpcstatic.add_st_edge = function( st, it, edge, dy) {\n    if (st == null)\n    {\n        /* Append edge onto the tail end of the ST */\n        st = new gpcas.geometry.StNode( edge, null );\n    }\n    else\n    {\n        var den= (st.xt - st.xb) - (edge.xt - edge.xb);\n\n        /* If new edge and ST edge don't cross */\n        if( (edge.xt >= st.xt) || (edge.dx == st.dx) || (Math.abs(den) <= gpcas.geometry.Clip.GPC_EPSILON))\n        {\n            /* No intersection - insert edge here (before the ST edge) */\n            var existing_node= st;\n            st = new StNode( edge, existing_node );\n        }\n        else\n        {\n            /* Compute intersection between new edge and ST edge */\n            var r= (edge.xb - st.xb) / den;\n            var x= st.xb + r * (st.xt - st.xb);\n            var y= r * dy;\n\n            /* Insert the edge pointers and the intersection point in the IT */\n            it.top_node = gpcas.geometry.Clip.add_intersection(it.top_node, st.edge, edge, x, y);\n\n            /* Head further into the ST */\n            st.prev = gpcas.geometry.Clip.add_st_edge(st.prev, it, edge, dy);\n        }\n    }\n    return st ;\n}\n\n\n\ngpcstatic.add_intersection = function ( it_node,\n    edge0,\n    edge1,\n    x,\n    y) {\n    if (it_node == null)\n    {\n        /* Append a new node to the tail of the list */\n        it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, null );\n    }\n    else\n    {\n        if ( it_node.point.y > y)\n        {\n            /* Insert a new node mid-list */\n            var existing_node= it_node ;\n            it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, existing_node );\n        }\n        else\n        {\n            /* Head further down the list */\n            it_node.next = gpcas.geometry.Clip.add_intersection( it_node.next, edge0, edge1, x, y);\n        }\n    }\n    return it_node ;\n}\n\n\n/////////// AetTree ////////////////////////////////////\ngpcas.geometry.AetTree = function(){\n    this.top_node = null; //EdgeNode\n};\nAetTree = gpcas.geometry.AetTree;\ngpcas.geometry.AetTree.prototype.print = function() {\n    //console.log(\"aet\");\n    for( var edge= this.top_node ; (edge != null) ; edge = edge.next ) {\n        //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n    }\n}\n\n\n///////////////  BundleState  //////////////////////////////\ngpcas.geometry.BundleState = function(state){\n    this.m_State = state ; //String\n};\ngpcas.geometry.BundleState.UNBUNDLED = new gpcas.geometry.BundleState(\"UNBUNDLED\");\ngpcas.geometry.BundleState.BUNDLE_HEAD = new gpcas.geometry.BundleState(\"BUNDLE_HEAD\");\ngpcas.geometry.BundleState.BUNDLE_TAIL = new gpcas.geometry.BundleState(\"BUNDLE_TAIL\");\ngpcas.geometry.BundleState.prototype.toString = function() {\n    return this.m_State;\n};\nBundleState = gpcas.geometry.BundleState;\n\n/////////////// EdgeNode ////////////////////////////\ngpcas.geometry.EdgeNode = function(){\n\tthis.vertex= new Point(); /* Piggy-backed contour vertex data  */\n\tthis.bot= new Point(); /* Edge lower (x, y) coordinate      */\n\tthis.top= new Point(); /* Edge upper (x, y) coordinate      */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.type;         /* Clip / subject edge flag          */\n\tthis.bundle = ArrayHelper.create2DArray(2,2);      /* Bundle edge flags                 */\n\tthis.bside= [];         /* Bundle left / right indicators    */\n\tthis.bstate= []; /* Edge bundle state                 */\n\tthis.outp= []; /* Output polygon / tristrip pointer */\n\tthis.prev;         /* Previous edge in the AET          */\n\tthis.next;         /* Next edge in the AET              */\n\tthis.pred;         /* Edge connected at the lower end   */\n\tthis.succ;         /* Edge connected at the upper end   */\n\tthis.next_bound;   /* Pointer to next bound in LMT      */\n};\n\n\n\n////////////////   EdgeTable /////////////////////////////////////////\n\n\ngpcas.geometry.EdgeTable = function() {\n\tthis.m_List = new gpcas.util.ArrayList();\n};\ngpcas.geometry.EdgeTable.prototype.addNode = function(x,y){\n\tvar node= new gpcas.geometry.EdgeNode();\n    node.vertex.x = x ;\n    node.vertex.y = y ;\n    this.m_List.add( node );\n\n}\ngpcas.geometry.EdgeTable.prototype.getNode = function (index) {\n\treturn this.m_List.get(index);\n}\ngpcas.geometry.EdgeTable.prototype.FWD_MIN = function(i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n\n    return ((prev.vertex.y >= ith.vertex.y) &&\n                 (next.vertex.y >  ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_FMAX = function ( i) {\n\tvar m_List = this.m_List;\n\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return(next.vertex.y > ith.vertex.y);\n}\ngpcas.geometry.EdgeTable.prototype.REV_MIN = function ( i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return ((prev.vertex.y >  ith.vertex.y) && (next.vertex.y >= ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_RMAX = function (i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return (prev.vertex.y > ith.vertex.y) ;\n}\n\n\n/////////////////////   HState   //////////////////////////////////////\ngpcas.geometry.HState = function(){};\ngpcas.geometry.HState.NH = 0; /* No horizontal edge                */\ngpcas.geometry.HState.BH = 1; /* Bottom horizontal edge            */\ngpcas.geometry.HState.TH = 2; /* Top horizontal edge               */\n\nHState = gpcas.geometry.HState;\n\nvar NH = gpcas.geometry.HState.NH;\nvar BH = gpcas.geometry.HState.BH;\nvar TH = gpcas.geometry.HState.TH;\n\n/* Horizontal edge state transitions within scanbeam boundary */\ngpcas.geometry.HState.next_h_state =\n      [\n      /*        ABOVE     BELOW     CROSS */\n      /*        L   R     L   R     L   R */\n      /* NH */ [BH, TH,   TH, BH,   NH, NH],\n      /* BH */ [NH, NH,   NH, NH,   TH, TH],\n      /* TH */ [NH, NH,   NH, NH,   BH, BH]\n      ];\n\n\n\n///////////////////////    \t  IntersectionPoint /////////////////////////////\ngpcas.geometry.IntersectionPoint = function(p1,p2,p3){\n\tthis.polygonPoint1 = p1; /* of Point */;\n\tthis.polygonPoint2 = p2;  /* of Point */;\n\tthis.intersectionPoint = p3 ;\n};\ngpcas.geometry.IntersectionPoint.prototype.toString = function (){\n\treturn \"P1 :\"+polygonPoint1.toString()+\" P2:\"+polygonPoint2.toString()+\" IP:\"+intersectionPoint.toString();\n}\n\n\n///////////////////////////    ItNode   ///////////////\ngpcas.geometry.ItNode = function(edge0, edge1, x, y, next){\n\tthis.ie= [];     /* Intersecting edge (bundle) pair   */\n\tthis.point= new Point(x,y); /* Point of intersection             */\n\tthis.next=next;                         /* The next intersection table node  */\n\n\tthis.ie[0] = edge0 ;\n    this.ie[1] = edge1 ;\n\n};\n\n\n///////////////////////////    ItNodeTable   ///////////////\ngpcas.geometry.ItNodeTable = function(){\n\tthis.top_node;\n}\nItNodeTable = gpcas.geometry.ItNodeTable;\n\ngpcas.geometry.ItNodeTable.prototype.build_intersection_table = function (aet, dy) {\n    var st= null ;\n\n    /* Process each AET edge */\n    for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n    {\n        if( (edge.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) ||\n                (edge.bundle[Clip.ABOVE][Clip.CLIP] != 0) ||\n                (edge.bundle[Clip.ABOVE][Clip.SUBJ] != 0) )\n        {\n            st = gpcas.geometry.Clip.add_st_edge(st, this, edge, dy);\n        }\n\n\n    }\n}\n\n////////////// Line //////////////////////////\ngpcas.geometry.Line = function(){\n\tthis.start;\n\tthis.end;\n}\n\n////////////   LineHelper /////////////////////\n\ngpcas.geometry.LineHelper = function(){};\ngpcas.geometry.LineHelper.equalPoint = function (p1,p2){\n\treturn ((p1[0]==p2[0])&&(p1[1]==p2[1]));\n}\ngpcas.geometry.LineHelper.equalVertex = function(s1,e1,s2,e2) {\n\treturn (\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,s2))&&(gpcas.geometry.LineHelper.equalPoint(e1,e2)))\n\t\t||\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,e2))&&(gpcas.geometry.LineHelper.equalPoint(e1,s2)))\n\t\t);\n}\ngpcas.geometry.LineHelper.distancePoints = function(p1, p2){\n\treturn Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\n}\ngpcas.geometry.LineHelper.clonePoint = function(p){\n\treturn [p[0],p[1]];\n}\ngpcas.geometry.LineHelper.cloneLine = function(line){\n\tvar res  = [];\n\tfor (var i = 0; i<line.length; i++){\n\t\tres[i]=[line[i][0],line[i][1]];\n\t}\n\treturn res;\n}\ngpcas.geometry.LineHelper.addLineToLine = function(line1,line2) {\n\tfor (var i = 0; i<line2.length; i++){\n\t\tline1.push(clonePoint(line2[i]));\n\t}\n}\ngpcas.geometry.LineHelper.roundPoint = function(p) {\n\tp[0]=Math.round(p[0]);\n\tp[1]=Math.round(p[1]);\n}\n//---------------------------------------------------------------\n//Checks for intersection of Segment if as_seg is true.\n//Checks for intersection of Line if as_seg is false.\n//Return intersection of Segment \"AB\" and Segment \"EF\" as a Point\n//Return null if there is no intersection\n//---------------------------------------------------------------\ngpcas.geometry.LineHelper.lineIntersectLine = function(A,B,E,F,as_seg)\n{\n\tif(as_seg == null) as_seg = true;\n\tvar ip;\n\tvar a1;\n\tvar a2;\n\tvar b1;\n\tvar b2;\n\tvar c1;\n\tvar c2;\n\n\ta1= B.y-A.y;\n\tb1= A.x-B.x;\n\tc1= B.x*A.y - A.x*B.y;\n\ta2= F.y-E.y;\n\tb2= E.x-F.x;\n\tc2= F.x*E.y - E.x*F.y;\n\n\tvar denom=a1*b2 - a2*b1;\n\tif(denom == 0){\n\t\treturn null;\n\t}\n\tip=new Point();\n\tip.x=(b1*c2 - b2*c1)/denom;\n\tip.y=(a2*c1 - a1*c2)/denom;\n\n\t//---------------------------------------------------\n\t//Do checks to see if intersection to endpoints\n\t//distance is longer than actual Segments.\n\t//Return null if it is with any.\n\t//---------------------------------------------------\n\tif(as_seg){\n\t\tif(Math.pow((ip.x - B.x) + (ip.y - B.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - A.x) + (ip.y - A.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\n\t\tif(Math.pow((ip.x - F.x) + (ip.y - F.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - E.x) + (ip.y - E.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn new Point(Math.round(ip.x),Math.round(ip.y));\n}\n\n\n//////////////  LineIntersection  ///////////////////////\ngpcas.geometry.LineIntersection = function(){};\ngpcas.geometry.LineIntersection.iteratePoints = function(points, s1, s2,e1,e2) {\n\tvar direction=true;\n\tvar pl = points.length;\n\tvar s1Ind = points.indexOf(s1);\n\tvar s2Ind = points.indexOf(s2);\n\tvar start = s1Ind;\n\n\tif (s2Ind>s1Ind) direction=false;\n\tvar newPoints  = [];\n\tvar point  ;\n\n\tif (direction){\n\t\tfor (var i =0; i<pl; i++){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var i =pl; i>=0; i--){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newPoints;\n}\n\ngpcas.geometry.LineIntersection.intersectPoly = function(poly, line /* of Points */){\n\tvar res = [];\n\tvar numPoints = poly.getNumPoints();\n\n\t//points\n\tvar ip ;\n\tvar p1 ;\n\tvar p2 ;\n\tvar p3 ;\n\tvar p4 ;\n\tvar firstIntersection  = null;\n\tvar lastIntersection   = null;\n\tvar firstIntersectionLineIndex=-1;\n\tvar lastIntersectionLineIndex=-1;\n\tvar firstFound  = false;\n\n\tfor (var i  = 1; i<line.length; i++){\n\t\tp1=line[i-1];\n\t\tp2=line[i];\n\t\tvar maxDist  = 0;\n\t\tvar minDist\t = Number.MAX_VALUE;\n\t\tvar dist  = -1;\n\t\tfor (var j  = 0; j<numPoints; j++){\n\t\t\tp3=poly.getPoint(j==0?numPoints-1:j-1);\n\t\t\tp4=poly.getPoint(j);\n\t\t\tif ((ip=LineHelper.lineIntersectLine(p1,p2,p3,p4))!=null){\n\t\t\t\tdist=Point.distance(ip,p2);\n\n\t\t\t\tif ((dist>maxDist)&&(!firstFound)){\n\t\t\t\t\tmaxDist=dist;\n\t\t\t\t\tfirstIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tfirstIntersectionLineIndex=i;\n\t\t\t\t}\n\t\t\t\tif (dist<minDist){\n\t\t\t\t\tminDist=dist;\n\t\t\t\t\tlastIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tlastIntersectionLineIndex=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfirstFound=(firstIntersection!=null);\n\t}\n\t\t\t/*\n\t\t\tAlert.show(firstIntersection.toString());\n\t\t\tAlert.show(lastIntersection.toString());*/\n\tif ((firstIntersection!=null)&&(lastIntersection!=null)){\n\t\tvar newLine /* of Point */ = [];\n\t\tnewLine[0]=firstIntersection.intersectionPoint;\n\t\tvar j  = 1;\n\t\tfor (var i = firstIntersectionLineIndex; i<=lastIntersectionLineIndex; i++){\n\t\t\tnewLine[j++] = line[i];\n\t\t}\n\t\tnewLine[newLine.length-1]=lastIntersection.intersectionPoint;\n\t\tif (\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint1))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint2))\n\t\t\t)||\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint2))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint1))\n\t\t\t\t)\n\t\t){\n\t\t\t\tvar poly1 = new gpcas.geometry.PolySimple();\n\t\t\t\tpoly1.add(newLine);\n\t\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\t\tvar finPoly2  = poly.xor(poly1);\n\t\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t} else {\n\t\t\tvar points1 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint1,firstIntersection.polygonPoint2, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints1=points1.concat(newLine.reverse());\n\t\t\tvar points2 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint2,firstIntersection.polygonPoint1, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints2=points2.concat(newLine);\n\t\t\tvar poly1  = new gpcas.geometry.PolySimple();\n\t\t\tpoly1.add(points1);\n\t\t\tvar poly2  = new gpcas.geometry.PolySimple();\n\t\t\tpoly2.add(points2);\n\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\tvar finPoly2  = poly.intersection(poly2);\n\n\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n}\ngpcas.geometry.LineIntersection.checkPoly = function(poly) {\n\tvar noHoles =0;\n\tfor (var i  = 0; i<poly.getNumInnerPoly(); i++){\n\t\tvar innerPoly  = poly.getInnerPoly(i);\n\t\tif (innerPoly.isHole()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\tnoHoles++;\n\t\t}\n\t\tif (noHoles>1) return false;\n\t}\n\treturn true;\n}\n\n\n///////////  LmtNode //////////////////////////\n\ngpcas.geometry.LmtNode = function(yvalue) {\n\tthis.y = yvalue;            /* Y coordinate at local minimum     */\n\tthis.first_bound;  /* Pointer to bound list             */\n\tthis.next;         /* Pointer to next local minimum     */\n};\nLmtNode = gpcas.geometry.LmtNode;\n\n////////////// LmtTable ///////////////\n\ngpcas.geometry.LmtTable = function(){\n\tthis.top_node;\n};\ngpcas.geometry.LmtTable.prototype.print = function() {\n    var n= 0;\n    var lmt= this.top_node ;\n    while( lmt != null )\n    {\n\t\t//console.log(\"lmt(\"+n+\")\");\n\t\tfor( var edge= lmt.first_bound ; (edge != null) ; edge = edge.next_bound )\n\t\t{\n\t\t   //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n\t\t}\n\t\tn++ ;\n\t\tlmt = lmt.next ;\n    }\n}\n\n/////////////   OperationType //////////////////////////////////\ngpcas.geometry.OperationType = function(type){\n\tthis.m_Type = type;\n}\ngpcas.geometry.OperationType.GPC_DIFF= new gpcas.geometry.OperationType( \"Difference\" );\ngpcas.geometry.OperationType.GPC_INT= new gpcas.geometry.OperationType( \"Intersection\" );\ngpcas.geometry.OperationType.GPC_XOR= new gpcas.geometry.OperationType( \"Exclusive or\" );\ngpcas.geometry.OperationType.GPC_UNION= new gpcas.geometry.OperationType( \"Union\" );\n\n//////////// Poly  /////////////////////\n// ---> an interface\n\n\n/////////////// PolyDefault  /////////////////////\n/**\n * <code>PolyDefault</code> is a default <code>Poly</code> implementation.\n * It provides support for both complex and simple polygons.  A <i>complex polygon</i>\n * is a polygon that consists of more than one polygon.  A <i>simple polygon</i> is a\n * more traditional polygon that contains of one inner polygon and is just a\n * collection of points.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty <code>PolyDefault</code>\n * object, it will create an inner polygon of type <code>PolySimple</code>.\n *\n * @see PolySimple\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolyDefault = function(isHole) {\n\tif(isHole == null) isHole = false;\n\n\t   /**\n    * Only applies to the first poly and can only be used with a poly that contains one poly\n    */\n\tthis.m_IsHole= isHole ;\n    this.m_List= new gpcas.util.ArrayList();\n}\n /**\n    * Return true if the given object is equal to this one.\n    */\ngpcas.geometry.PolyDefault.prototype.equals = function ( obj) {\n    if(!(obj instanceof PolyDefault)){\n\t\treturn false;\n    }\n    var that = obj;\n\n    if( this.m_IsHole != that.m_IsHole ) return false ;\n    if( !equals(this.m_List, that.m_List ) ) return false ;\n\n    return true ;\n}\n   /**\n    * Return the hashCode of the object.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    **/\ngpcas.geometry.PolyDefault.prototype.hashCode = function () {\n\tvar m_List = this.m_List;\n\n    var result= 17;\n    result = 37*result + m_List.hashCode();\n    return result;\n}\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.clear = function() {\n    this.m_List.clear();\n}\n\ngpcas.geometry.PolyDefault.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\tif (args.length==2){\n\t\tthis.addPointXY(args[0], args[1]);\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n   \t\t\tthis.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof gpcas.geometry.PolySimple){\n   \t\t\tthis.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n   \t\t\tvar arr  = args[0];\n   \t\t\tif ((arr.length==2)&&(arr[0] instanceof Number)&&(arr[1] instanceof Number)){\n   \t\t\t\tthis.add(arr[0] ,arr[1] )\n   \t\t\t} else {\n   \t\t\t\tfor(var i=0; i<args[0].length ; i++) {\n\t\t\t\t\tthis.add(args[0][i]);\n\t\t\t\t}\n   \t\t\t}\n   \t\t}\n   \t}\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPointXY = function(x, y) {\n    this.addPoint(new Point( x, y ));\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoint = function( p) {\n\n\n\tvar m_List = this.m_List;\n\n    if( m_List.size() == 0)\n    {\n        m_List.add(new gpcas.geometry.PolySimple());\n    }\n    (m_List.get(0)).addPoint(p);\n}\n /**\n    * Add an inner polygon to this polygon - assumes that adding polygon does not\n    * have any inner polygons.\n    *\n    * @throws IllegalStateException if the number of inner polygons is greater than\n    * zero and this polygon was designated a hole.  This would break the assumption\n    * that only simple polygons can be holes.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoly = function( p) {\n\n\tvar m_IsHole = this.m_IsHole;\n\tvar m_List = this.m_List;\n\n    if( (m_List.size() > 0) && m_IsHole )\n      {\n         alert(\"ERROR : Cannot add polys to something designated as a hole.\");\n      }\n    m_List.add( p );\n}\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolyDefault.prototype.isEmpty = function() {\n    return this.m_List.isEmpty();\n}\n /**\n    * Returns the bounding rectangle of this polygon.\n    * <strong>WARNING</strong> Not supported on complex polygons.\n    */\ngpcas.geometry.PolyDefault.prototype.getBounds = function () {\n\tvar m_List = this.m_List;\n    if( m_List.size() == 0)\n    {\n        return new Rectangle();\n    }\n    else if( m_List.size() == 1)\n    {\n         var ip= this.getInnerPoly(0);\n         return ip.getBounds();\n    }\n    else\n    {\n         console.log(\"getBounds not supported on complex poly.\");\n    }\n}\n   /**\n    * Returns the polygon at this index.\n    */\ngpcas.geometry.PolyDefault.prototype.getInnerPoly = function(polyIndex) {\n      return this.m_List.get(polyIndex);\n}\n   /**\n    * Returns the number of inner polygons - inner polygons are assumed to return one here.\n    */\ngpcas.geometry.PolyDefault.prototype.getNumInnerPoly = function() {\n\tvar m_List = this.m_List;\n      return m_List.size();\n}\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getNumPoints = function () {\n    return (this.m_List.get(0)).getNumPoints() ;\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getX = function(index) {\n      return (this.m_List.get(0)).getX(index) ;\n}\ngpcas.geometry.PolyDefault.prototype.getPoint = function(index){\n\t\treturn (this.m_List.get(0)).getPoint(index) ;\n}\n\ngpcas.geometry.PolyDefault.prototype.getPoints = function(){\n\treturn (this.m_List.get(0)).getPoints();\n}\n\n\ngpcas.geometry.PolyDefault.prototype.isPointInside = function (point) {\n\tvar m_List = this.m_List;\n   \tif (!(m_List.get(0)).isPointInside(point)) return false;\n\n\tfor (var i  = 0; i<m_List.size(); i++){\n   \t\tvar poly  = m_List.get(i);\n   \t\t\tif ((poly.isHole())&&(poly.isPointInside(point))) return false;\n   \t\t}\n   \t\treturn true;\n}\n     /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getY = function (index) {\n\tvar m_List = this.m_List;\n      return (m_List.get(0)).getY(index) ;\n}\n\n   /**\n    * Return true if this polygon is a hole.  Holes are assumed to be inner polygons of\n    * a more complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.isHole = function () {\n\tvar m_List = this.m_List;\n\tvar m_IsHole = this.m_IsHole;\n\n      if( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n      return m_IsHole ;\n}\n\n   /**\n    * Set whether or not this polygon is a hole.  Cannot be called on a complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.setIsHole = function(isHole) {\n    var m_List = this.m_List;\n\tif( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n    this.m_IsHole = isHole ;\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    */\ngpcas.geometry.PolyDefault.prototype.isContributing = function( polyIndex) {\n      var m_List = this.m_List;\n\t  return (m_List.get(polyIndex)).isContributing(0);\n}\n\n    /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if called on a complex polygon\n    */\ngpcas.geometry.PolyDefault.prototype.setContributing = function( polyIndex, contributes) {\n    var m_List = this.m_List;\n\tif( m_List.size() != 1)\n      {\n        alert( \"Only applies to polys of size 1\" );\n      }\n     (m_List.get(polyIndex)).setContributing( 0, contributes );\n}\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.union = function(p) {\n\treturn gpcas.geometry.Clip.union( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolyDefault\" );\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolyDefault.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolyDefault\");\n}\n\n   /**\n    * Return the area of the polygon in square units.\n    */\ngpcas.geometry.PolyDefault.prototype.getArea = function() {\n      var area= 0.0;\n      for( var i= 0; i < getNumInnerPoly() ; i++ )\n      {\n         var p= getInnerPoly(i);\n         var tarea = p.getArea() * (p.isHole() ? -1.0: 1.0);\n         area += tarea ;\n      }\n      return area ;\n}\n\n   // -----------------------\n   // --- Package Methods ---\n   // -----------------------\ngpcas.geometry.PolyDefault.prototype.toString = function() {\n    var res  = \"\";\n\tvar m_List = this.m_List;\n    for( var i= 0; i < m_List.size() ; i++ )\n    {\n         var p = this.getInnerPoly(i);\n         res+=(\"InnerPoly(\"+i+\").hole=\"+p.isHole());\n         var points = [];\n         for( var j= 0; j < p.getNumPoints() ; j++ )\n         {\n         \tpoints.push(new Point(p.getX(j),p.getY(j)));\n         }\n         points = ArrayHelper.sortPointsClockwise(points) ;\n\n\t\t for(var k =0 ; k< points.length ; k++) {\n\t\t\tres+=points[k].toString();\n\t\t }\n\n      }\n      return res;\n   }\n\n///////////////  Polygon   /////////////////////////////////\ngpcas.geometry.Polygon = function(){\n\tthis.maxTop ;\n\tthis.maxBottom ;\n\tthis.maxLeft ;\n\tthis.maxRight ;\n\tthis.vertices  /* of Point */;\n};\ngpcas.geometry.Polygon.prototype.fromArray = function(v) {\n\tthis.vertices = [];\n\n\tfor(var i=0 ; i<v.length ; i++) {\n\t\tvar pointArr = v[i];\n\t\tthis.vertices.push(new Point(pointArr[0],pointArr[1]));\n\t}\n}\n\n\t\t/*Normalize vertices in polygon to be ordered clockwise from most left point*/\ngpcas.geometry.Polygon.prototype.normalize = function() {\n\tvar maxLeftIndex ;\n\tvar vertices = this.vertices;\n\tvar newVertices = this.vertices;\n\n\tfor (var i  = 0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\n\t\tif ((maxTop==null)||(maxTop.y>vertex.y)||((maxTop.y==vertex.y)&&(vertex.x<maxTop.x))){\n\t\t\tmaxTop=vertex;\n\t\t}\n\t\tif ((maxBottom==null)||(maxBottom.y<vertex.y)||((maxBottom.y==vertex.y)&&(vertex.x>maxBottom.x))){\n\t\t\tmaxBottom=vertex;\n\t\t}\n \t\tif ((maxLeft==null)||(maxLeft.x>vertex.x)||((maxLeft.x==vertex.x)&&(vertex.y>maxLeft.y))){\n\t\t\tmaxLeft=vertex;\n\t\t\tmaxLeftIndex=i;\n\t\t}\n\t\tif ((maxRight==null)||(maxRight.x<vertex.x)||((maxRight.x==vertex.x)&&(vertex.y<maxRight.y))){\n\t\t\tmaxRight=vertex;\n\t\t}\n\t}\n\n\tif (maxLeftIndex>0){\n\t\tnewVertices = [];\n\t\tvar j = 0;\n\t\tfor (var i=maxLeftIndex; i<vertices.length;i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tfor (var i=0; i<maxLeftIndex; i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n\tvar reverse   = false;\n\tfor(var k=0; k<this.vertices.length ; k++) {\n\t\tvar vertex  =  this.vertices[k];\n\t    if (equals(vertex, maxBottom)){\n\t\t\treverse=true;\n\t\t\tbreak;\n\t\t} else if (equals(vertex, maxTop)){\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reverse){\n\t\tnewVertices= [];\n\t\tnewVertices[0]=vertices[0];\n\t\tvar j =1;\n\t\tfor (var i=vertices.length-1; i>0; i--){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n}\ngpcas.geometry.Polygon.prototype.getVertexIndex = function(vertex){\n\tfor (var i=0; i<this.vertices.length; i++){\n\t\tif (equals(vertices[i], vertex)){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\ngpcas.geometry.Polygon.prototype.insertVertex = function(vertex1,vertex2, newVertex){\n\tvar vertex1Index  = getVertexIndex(vertex1);\n\tvar vertex2Index  = getVertexIndex(vertex2);\n\tif ((vertex1Index==-1)||(vertex2Index==-1)){\n\t\treturn false;\n\t}\n\n\tif (vertex2Index<vertex1Index){\n\t\tvar i  = vertex1Index;\n\t\tvertex1Index=vertex2Index;\n\t\tvertex2Index=i;\n\t}\n\tif (vertex2Index==vertex1Index+1){\n\t\tvar newVertices  = [];\n\t\tfor (var i =0; i<=vertex1Index; i++){\n\t\t\tnewVertices[i]=this.vertices[i];\n\t\t}\n\t\tnewVertices[vertex2Index]=newVertex;\n\t\tfor (var i =vertex2Index; i<this.vertices.length; i++){\n\t\t\tnewVertices[i+1]=this.vertices[i];\n\t\t}\n\t\tthis.vertices=newVertices;\n\t} else if ((vertex2Index==vertices.length-1)&&(vertex1Index==0)){\n\t\tthis.vertices.push(newVertex);\n\t}\n\treturn true;\n}\ngpcas.geometry.Polygon.prototype.clone = function() {\n\tvar res = new gpcas.geometry.Polygon();\n\tres.vertices=vertices.slice(this.vertices.length-1);\n\treturn res;\n}\ngpcas.geometry.Polygon.prototype.toString = function() {\n\tvar vertices = this.vertices;\n\tvar res  = \"[\";\n\tfor (var i  =0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\t\tres+=(i>0?\",\":\"\")+\"[\"+vertex.x+\",\"+vertex.y+\"]\";\n\t}\n\tres+=\"]\";\n\treturn res;\n}\n\n\n////////////////////  PolygonNode ///////////////////////////\ngpcas.geometry.PolygonNode = function(next, x, y) {\n\n\n\tthis.active;                 /* Active flag / vertex count        */\n\tthis.hole;                /* Hole / external contour flag      */\n\tthis.v= [] ; /* Left and right vertex list ptrs   */\n\tthis.next;                   /* Pointer to next polygon contour   */\n\tthis.proxy;                  /* Pointer to actual structure used  */\n\n\t/* Make v[Clip.LEFT] and v[Clip.RIGHT] point to new vertex */\n\tvar vn= new VertexNode( x, y );\n\n\tthis.v[Clip.LEFT ] = vn ;\n\tthis.v[Clip.RIGHT] = vn ;\n\n\tthis.next = next ;\n\tthis.proxy = this ; /* Initialise proxy to point to p itself */\n\tthis.active = 1; //TRUE\n}\ngpcas.geometry.PolygonNode.prototype.add_right = function( x, y) {\n\tvar nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the right end of the polygon's vertex list */\n\t this.proxy.v[Clip.RIGHT].next= nv;\n\n\t /* Update proxy->v[Clip.RIGHT] to point to nv */\n\t this.proxy.v[Clip.RIGHT]= nv;\n}\ngpcas.geometry.PolygonNode.prototype.add_left = function( x, y) {\n\t var proxy = this.proxy;\n\n\t var nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the left end of the polygon's vertex list */\n\t nv.next= proxy.v[Clip.LEFT];\n\n\t /* Update proxy->[Clip.LEFT] to point to nv */\n\t proxy.v[Clip.LEFT]= nv;\n}\n\n\n//////////////////   PolySimple ////////////////\n\n/**\n * <code>PolySimple</code> is a simple polygon - contains only one inner polygon.\n * <p>\n * <strong>WARNING:</strong> This type of <code>Poly</code> cannot be used for an\n * inner polygon that is a hole.\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolySimple = function(){\n\t/**\n    * The list of Point objects in the polygon.\n    */\n   this.m_List= new gpcas.util.ArrayList();\n\n   /** Flag used by the Clip algorithm */\n   this.m_Contributes= true ;\n};\n\n   /**\n    * Return true if the given object is equal to this one.\n    * <p>\n    * <strong>WARNING:</strong> This method failse if the first point\n    * appears more than once in the list.\n    */\ngpcas.geometry.PolySimple.prototype.equals = function(obj) {\n  if( !(obj instanceof PolySimple) )\n  {\n\t return false;\n  }\n\n  var that= obj;\n\n  var this_num= this.m_List.size();\n  var that_num= that.m_List.size();\n  if( this_num != that_num ) return false ;\n\n\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING: This is not the greatest algorithm.  It fails if !!!\n  // !!! the first point in \"this\" poly appears more than once.    !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  if( this_num > 0)\n  {\n\t var this_x= this.getX(0);\n\t var this_y= this.getY(0);\n\t var that_first_index = -1;\n\t for( var that_index= 0; (that_first_index == -1) && (that_index < that_num) ; that_index++ )\n\t {\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\t\tif( (this_x == that_x) && (this_y == that_y) )\n\t\t{\n\t\t   that_first_index = that_index ;\n\t\t}\n\t }\n\t if( that_first_index == -1) return false ;\n\t var that_index= that_first_index ;\n\t for( var this_index= 0; this_index < this_num ; this_index++ )\n\t {\n\t\tthis_x = this.getX(this_index);\n\t\tthis_y = this.getY(this_index);\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\n\t\tif( (this_x != that_x) || (this_y != that_y) ) return false;\n\n\t\tthat_index++ ;\n\t\tif( that_index >= that_num )\n\t\t{\n\t\t   that_index = 0;\n\t\t}\n\t }\n  }\n  return true ;\n}\n\n   /**\n    * Return the hashCode of the object.\n    * <p>\n    * <strong>WARNING:</strong>Hash and Equals break contract.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    */\ngpcas.geometry.PolySimple.prototype.hashCode = function() {\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING:  This hash and equals break the contract. !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  var result= 17;\n  result = 37*result + this.m_List.hashCode();\n  return result;\n}\n\n   /**\n    * Return a string briefly describing the polygon.\n    */\ngpcas.geometry.PolySimple.prototype.toString = function() {\n    return \"PolySimple: num_points=\"+getNumPoints();\n}\n\n   // --------------------\n   // --- Poly Methods ---\n   // --------------------\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolySimple.prototype.clear = function() {\n      this.m_List.clear();\n}\n\n\ngpcas.geometry.PolySimple.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\n   \tif (args.length==2){\n\t\tthis.addPointXY(args[0] , args[1] );\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n               this.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof Poly){\n               this.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n\t\t\tfor(var k=0 ; k<args[0].length ; k++) {\n\t\t\t\tvar val = args[0][k];\n                this.add(val);\n\t\t\t}\n   \t\t}\n   \t}\n}\n\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPointXY = function(x, y) {\n    this.addPoint( new Point( x, y ) );\n}\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPoint = function(p) {\n      this.m_List.add( p );\n}\n\n   /**\n    * Throws IllegalStateexception if called\n    */\ngpcas.geometry.PolySimple.prototype.addPoly = function(p) {\n    alert(\"Cannot add poly to a simple poly.\");\n}\n\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolySimple.prototype.isEmpty = function() {\n      return this.m_List.isEmpty();\n}\n\n   /**\n    * Returns the bounding rectangle of this polygon.\n    */\ngpcas.geometry.PolySimple.prototype.getBounds = function() {\n\t  var xmin=  Number.MAX_VALUE ;\n\t  var ymin=  Number.MAX_VALUE ;\n\t  var xmax= -Number.MAX_VALUE ;\n\t  var ymax= -Number.MAX_VALUE ;\n\n      for( var i= 0; i < this.m_List.size() ; i++ )\n      {\n         var x= this.getX(i);\n         var y= this.getY(i);\n         if( x < xmin ) xmin = x;\n         if( x > xmax ) xmax = x;\n         if( y < ymin ) ymin = y;\n         if( y > ymax ) ymax = y;\n      }\n\n      return new Rectangle( xmin, ymin, (xmax-xmin), (ymax-ymin) );\n   }\n\n   /**\n    * Returns <code>this</code> if <code>polyIndex = 0</code>, else it throws\n    * IllegalStateException.\n    */\ngpcas.geometry.PolySimple.prototype.getInnerPoly = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this ;\n}\n\n   /**\n    * Always returns 1.\n    */\ngpcas.geometry.PolySimple.prototype.getNumInnerPoly = function() {\n    return 1;\n}\n\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getNumPoints = function() {\n      return this.m_List.size();\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getX = function(index) {\n    return (this.m_List.get(index)).x;\n}\n\n   /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getY = function(index) {\n    return (this.m_List.get(index)).y;\n}\n\ngpcas.geometry.PolySimple.prototype.getPoint = function(index){\n\treturn (this.m_List.get(index));\n}\n\ngpcas.geometry.PolySimple.prototype.getPoints = function() {\n\treturn this.m_List.toArray();\n}\n\ngpcas.geometry.PolySimple.prototype.isPointInside = function(point) {\n\t var points  = this.getPoints();\n\t var j  = points.length - 1;\n\t var oddNodes = false;\n\n\t for (var i  = 0; i < points.length; i++)\n\t {\n\t\t if (points[i].y < point.y && points[j].y >= point.y ||\n\t\t\t points[j].y < point.y && points[i].y >= point.y)\n\t\t {\n\t\t\t if (points[i].x +\n\t\t\t\t (point.y - points[i].y)/(points[j].y - points[i].y)*(points[j].x - points[i].x) < point.x)\n\t\t\t {\n\t\t\t\t oddNodes = !oddNodes;\n\t\t\t}\n\t\t }\n\t\t j = i;\n\t }\n\t return oddNodes;\n}\n\n\n   /**\n    * Always returns false since PolySimples cannot be holes.\n    */\ngpcas.geometry.PolySimple.prototype.isHole = function() {\n      return false ;\n}\n\n   /**\n    * Throws IllegalStateException if called.\n    */\ngpcas.geometry.PolySimple.prototype.setIsHole =function(isHole) {\n    alert(\"PolySimple cannot be a hole\");\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.isContributing = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this.m_Contributes ;\n}\n\n   /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.setContributing = function( polyIndex, contributes) {\n      if( polyIndex != 0)\n      {\n         alert(\"PolySimple only has one poly\");\n      }\n      this.m_Contributes = contributes ;\n   }\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( this, p,\"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.union = function(p) {\n      return gpcas.geometry.Clip.union( this, p, \"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolySimple\");\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolySimple.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolySimple\");\n}\n\n   /**\n    * Returns the area of the polygon.\n    * <p>\n    * The algorithm for the area of a complex polygon was take from\n    * code by Joseph O'Rourke author of \" Computational Geometry in C\".\n    */\ngpcas.geometry.PolySimple.prototype.getArea = function() {\n      if( this.getNumPoints() < 3)\n      {\n         return 0.0;\n      }\n      var ax= this.getX(0);\n      var ay= this.getY(0);\n\n      var area= 0.0;\n      for( var i= 1; i < (this.getNumPoints()-1) ; i++ )\n      {\n         var bx= this.getX(i);\n         var by= this.getY(i);\n         var cx= this.getX(i+1);\n         var cy= this.getY(i+1);\n         var tarea= ((cx - bx)*(ay - by)) - ((ax - bx)*(cy - by));\n         area += tarea ;\n      }\n      area = 0.5*Math.abs(area);\n      return area ;\n   }\n\n  /////////////////////// Rectangle  ///////////////////\ngpcas.geometry.Rectangle = function(_x, _y, _w, _h) {\n\tthis.x = _x;\n\tthis.y = _y;\n\tthis.w = _w;\n\tthis.h = _h;\n}\ngpcas.geometry.Rectangle.prototype.getMaxY = function(){\n\treturn this.y+this.h;\n}\ngpcas.geometry.Rectangle.prototype.getMinY = function(){\n\treturn this.y;\n}\ngpcas.geometry.Rectangle.prototype.getMaxX = function() {\n\treturn this.x+this.w;\n}\ngpcas.geometry.Rectangle.prototype.getMinX = function(){\n\treturn this.x;\n}\ngpcas.geometry.Rectangle.prototype.toString = function(){\n\treturn \"[\"+x.toString()+\" \"+y.toString()+\" \"+w.toString()+\" \"+h.toString()+\"]\";\n}\n\n/////////////////// ScanBeamTree //////////////////////\ngpcas.geometry.ScanBeamTree = function(yvalue) {\n\tthis.y = yvalue;         /* Scanbeam node y value             */\n\tthis.less;         /* Pointer to nodes with lower y     */\n\tthis.more;         /* Pointer to nodes with higher y    */\n}\n\n///////////////////////// ScanBeamTreeEntries /////////////////\ngpcas.geometry.ScanBeamTreeEntries = function(){\n\tthis.sbt_entries=0;\n\tthis.sb_tree;\n};\ngpcas.geometry.ScanBeamTreeEntries.prototype.build_sbt = function() {\n\tvar sbt= [];\n\n\tvar entries= 0;\n\tentries = this.inner_build_sbt( entries, sbt, this.sb_tree );\n\n\t//console.log(\"SBT = \"+this.sbt_entries);\n\n\tif( entries != this.sbt_entries )\n\t{\n\t//console.log(\"Something went wrong buildign sbt from tree.\");\n\t}\n\treturn sbt ;\n}\ngpcas.geometry.ScanBeamTreeEntries.prototype.inner_build_sbt = function( entries, sbt, sbt_node) {\n\tif( sbt_node.less != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.less);\n\t }\n\t sbt[entries]= sbt_node.y;\n\t entries++;\n\t if( sbt_node.more != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.more );\n\t }\n\t return entries ;\n}\n\n///////////////////////////  StNode\nStNode = gpcas.geometry.StNode = function( edge, prev) {\n\tthis.edge;         /* Pointer to AET edge               */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.prev;         /* Previous edge in sorted list      */\n\n\tthis.edge = edge ;\n\t this.xb = edge.xb ;\n\t this.xt = edge.xt ;\n\t this.dx = edge.dx ;\n\t this.prev = prev ;\n}\n\n/////////////////////   TopPolygonNode /////////////////\ngpcas.geometry.TopPolygonNode = function(){\n\tthis.top_node;\n};\nTopPolygonNode = gpcas.geometry.TopPolygonNode;\n\ngpcas.geometry.TopPolygonNode.prototype.add_local_min = function( x, y) {\n\t var existing_min= this.top_node;\n\t this.top_node = new gpcas.geometry.PolygonNode( existing_min, x, y );\n\t return this.top_node ;\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_left = function( p, q) {\n /* Label contour as a hole */\n q.proxy.hole = true ;\n var top_node = this.top_node;\n\n if (p.proxy != q.proxy) {\n\t/* Assign p's vertex list to the left end of q's list */\n\tp.proxy.v[Clip.RIGHT].next= q.proxy.v[Clip.LEFT];\n\tq.proxy.v[Clip.LEFT]= p.proxy.v[Clip.LEFT];\n\n\t/* Redirect any p.proxy references to q.proxy */\n\tvar target= p.proxy ;\n\tfor(var node= top_node; (node != null); node = node.next)\n\t{\n\t   if (node.proxy == target)\n\t   {\n\t\t  node.active= 0;\n\t\t  node.proxy= q.proxy;\n\t   }\n\t}\n }\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_right = function( p, q) {\n\t var top_node = this.top_node;\n\t /* Label contour as external */\n\t q.proxy.hole = false ;\n\n\t if (p.proxy != q.proxy)\n\t {\n\t\t/* Assign p's vertex list to the right end of q's list */\n\t\tq.proxy.v[Clip.RIGHT].next= p.proxy.v[Clip.LEFT];\n\t\tq.proxy.v[Clip.RIGHT]= p.proxy.v[Clip.RIGHT];\n\n\t\t/* Redirect any p->proxy references to q->proxy */\n\t\tvar target= p.proxy ;\n\t\tfor (var node = top_node ; (node != null ); node = node.next)\n\t\t{\n\t\t   if (node.proxy == target)\n\t\t   {\n\t\t\t  node.active = 0;\n\t\t\t  node.proxy= q.proxy;\n\t\t   }\n\t\t}\n\t }\n  }\ngpcas.geometry.TopPolygonNode.prototype.count_contours = function() {\nvar nc= 0;\n\nfor ( var polygon= this.top_node; (polygon != null) ; polygon = polygon.next)\n\t {\n\t\tif (polygon.active != 0)\n\t\t{\n\t\t   /* Count the vertices in the current contour */\n\t\t   var nv= 0;\n\t\t   for (var v= polygon.proxy.v[Clip.LEFT]; (v != null); v = v.next)\n\t\t   {\n\t\t\t  nv++;\n\t\t   }\n\n\t\t   /* Record valid vertex counts in the active field */\n\t\t   if (nv > 2)\n\t\t   {\n\t\t\t  polygon.active = nv;\n\t\t\t  nc++;\n\t\t   }\n\t\t   else\n\t\t   {\n\t\t\t  /* Invalid contour: just free the heap */\n//                  VertexNode nextv = null ;\n//                  for (VertexNode v= polygon.proxy.v[Clip.LEFT]; (v != null); v = nextv)\n//                  {\n//                     nextv= v.next;\n//                     v = null ;\n//                  }\n\t\t\t  polygon.active= 0;\n\t\t   }\n\t\t}\n\t }\n\t return nc;\n  }\ngpcas.geometry.TopPolygonNode.prototype.getResult = function(polyClass) {\n\nvar top_node = this.top_node;\nvar result= gpcas.geometry.Clip.createNewPoly( polyClass );\n//console.log(polyClass);\n\n\nvar num_contours = this.count_contours();\n\nif (num_contours > 0)\n\t {\n\t\tvar c= 0;\n\t\tvar npoly_node= null ;\n\t\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t\t{\n\t\t   npoly_node = poly_node.next;\n\t\t   if (poly_node.active != 0)\n\t\t   {\n\n\t\t\t  var poly = result ;\n\n\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t poly = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\t\t  }\n\t\t\t  if( poly_node.proxy.hole )\n\t\t\t  {\n\t\t\t\t poly.setIsHole( poly_node.proxy.hole );\n\t\t\t  }\n\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  // --- This algorithm puts the verticies into the poly in reverse order ---\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t\t  {\n\t\t\t\t poly.add( vtx.x, vtx.y );\n\t\t\t  }\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t result.addPoly( poly );\n\t\t\t  }\n\t\t\t  c++;\n\t\t   }\n\t\t}\n\n\t\t// -----------------------------------------\n\t\t// --- Sort holes to the end of the list ---\n\t\t// -----------------------------------------\n\t\tvar orig= result ;\n\t\tresult = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( !inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t }\n\t return result ;\n  }\ngpcas.geometry.TopPolygonNode.prototype.print = function() {\n    //console.log(\"---- out_poly ----\");\n\tvar top_node = this.top_node;\n    var c= 0;\n    var npoly_node= null ;\n\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t {\n\t\t//console.log(\"contour=\"+c+\"  active=\"+poly_node.active+\"  hole=\"+poly_node.proxy.hole);\n\t\tnpoly_node = poly_node.next;\n\t\tif (poly_node.active != 0)\n\t\t{\n\t\t   var v=0;\n\t\t   for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t   {\n\t\t\t  //console.log(\"v=\"+v+\"  vtx.x=\"+vtx.x+\"  vtx.y=\"+vtx.y);\n\t\t   }\n\t\t   c++;\n\t\t}\n\t }\n}\n\n  ///////////    VertexNode  ///////////////\ngpcas.geometry.VertexNode = function( x, y) {\n\tthis.x;    // X coordinate component\n\tthis.y;    // Y coordinate component\n\tthis.next; // Pointer to next vertex in list\n\n\tthis.x = x ;\n    this.y = y ;\n    this.next = null ;\n}\nVertexNode = gpcas.geometry.VertexNode;\n\n/////////////   VertexType   /////////////\ngpcas.geometry.VertexType = function(){};\ngpcas.geometry.VertexType.NUL=  0; /* Empty non-intersection            */\ngpcas.geometry.VertexType.EMX=  1; /* External maximum                  */\ngpcas.geometry.VertexType.ELI=  2; /* External left intermediate        */\ngpcas.geometry.VertexType.TED=  3; /* Top edge                          */\ngpcas.geometry.VertexType.ERI=  4; /* External right intermediate       */\ngpcas.geometry.VertexType.RED=  5; /* Right edge                        */\ngpcas.geometry.VertexType.IMM=  6; /* Internal maximum and minimum      */\ngpcas.geometry.VertexType.IMN=  7; /* Internal minimum                  */\ngpcas.geometry.VertexType.EMN=  8; /* External minimum                  */\ngpcas.geometry.VertexType.EMM=  9; /* External maximum and minimum      */\ngpcas.geometry.VertexType.LED= 10; /* Left edge                         */\ngpcas.geometry.VertexType.ILI= 11; /* Internal left intermediate        */\ngpcas.geometry.VertexType.BED= 12; /* Bottom edge                       */\ngpcas.geometry.VertexType.IRI= 13; /* Internal right intermediate       */\ngpcas.geometry.VertexType.IMX= 14; /* Internal maximum                  */\ngpcas.geometry.VertexType.FUL= 15; /* Full non-intersection             */\ngpcas.geometry.VertexType.getType = function( tr, tl ,br ,bl) {\n    return tr + (tl << 1) + (br << 2) + (bl << 3);\n}\n\nVertexType = gpcas.geometry.VertexType;\n\n////////////////// WeilerAtherton  /////////////\ngpcas.geometry.WeilerAtherton = function(){};\n\ngpcas.geometry.WeilerAtherton.prototype.merge = function(p1,p2) {\n\tp1=p1.clone();\n\tp2=p2.clone();\n}\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\n/*jshint -W072 */\nvar intersect = function (a10, a11, a20, a21, b10, b11, b20, b21) {\n    var ua_t = (b20 - b10) * (a11 - b11) - (b21 - b11) * (a10 - b10);\n    var ub_t = (a20 - a10) * (a11 - b11) - (a21 - a11) * (a10 - b10);\n    var u_b = (b21 - b11) * (a20 - a10) - (b20 - b10) * (a21 - a11);\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\nfunction Cell(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.items = [];\n}\n\nCell.prototype.insert = function(item) {\n    if (\n        (item.fromX >= this.x && item.fromY >= this.y && item.toX <= this.x + this.width && item.toY <= this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x+this.width, this.y) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x+this.width, this.y, this.x+this.width, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y+this.height, this.x+this.width, this.y+this.height)\n    ) {\n        this.items.push(item);\n    }\n};\n\nexports = module.exports = Cell;\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\nvar Cell = require('./cell');\nvar DoublyLinkedList = require('../../linkedlist/doublylinkedlist');\n\nfunction Grid(bounds, rows, cols) {\n    this.bounds = bounds;\n    this.rows = rows;\n    this.cols = cols;\n    this.cellX = this.bounds.width / this.cols;\n    this.cellY = this.bounds.height / this.rows;\n    this.cells = [];\n    this.out = new DoublyLinkedList();\n    for( var col = 0;col<this.cols;col++) {\n        this.cells[col] = [];\n        for ( var row=0;row<this.rows;row++) {\n            this.cells[col][row] = new Cell(col*this.cellX, row*this.cellY, this.cellX, this.cellY);\n        }\n    }\n}\n\nGrid.prototype.insert = function(item) {\n    if (item instanceof Array) {\n        var i = 0,\n            n = item.length;\n            while (i<n) {\n                this.insert(item);\n                i++;\n            }\n    } else {\n        for( var col = 0;col<this.cols;col++) {\n            for ( var row=0;row<this.rows;row++) {\n                this.cells[col][row].insert(item);\n            }\n        }\n    }\n};\n\nGrid.prototype.addOut = function(items) {\n    var i = 0,\n        n = items.length;\n    while (i<n) {\n        this.out.add(items[i]);\n        i++;\n    }\n};\n\nGrid.prototype.retrieve = function(item) {\n    // figure out cells\n    var nx = ((item.x%this.cellX) + item.width) > this.cellX ? true : false,\n        ny = ((item.y%this.cellY) + item.height) > this.cellY ? true : false,\n        x = Math.floor(item.x / this.cellX),\n        y = Math.floor(item.y / this.cellY);\n    this.out.clear();\n\n    this.addOut(this.cells[x][y].items);\n    if (nx) {\n        this.addOut(this.cells[x+1][y].items);\n    }\n    if (ny) {\n        this.addOut(this.cells[x][y+1].items);\n    }\n    if (nx && ny) {\n        this.addOut(this.cells[x+1][y+1].items);\n    }\n    return this.out;\n};\n\nexports = module.exports = Grid;\n\n},{\"../../linkedlist/doublylinkedlist\":29,\"./cell\":11}],13:[function(require,module,exports){\nmodule.exports = {\n  Grid: require('./grid'),\n  Cell: require('./cell')\n};\n\n},{\"./cell\":11,\"./grid\":12}],14:[function(require,module,exports){\nmodule.exports = {\n  Vector2: require('./vector2'),\n  LineSegment2: require('./linesegment2'),\n  Triangle2: require('./triangle2'),\n  Polygon2: require('./polygon2'),\n  RegularPolygon2: require('./regularpolygon2'),\n  gpc: require('./gpc'),\n  VisibilityPolygon: require('./visibilitypolygon'),\n\n  Grid: require('./grid'),\n  QuadTree: require('./quadtree')\n};\n\n},{\"./gpc\":10,\"./grid\":13,\"./linesegment2\":15,\"./polygon2\":16,\"./quadtree\":18,\"./regularpolygon2\":21,\"./triangle2\":22,\"./vector2\":23,\"./visibilitypolygon\":24}],15:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\n\nexports = module.exports = LineSegment2;\n\nvar cache = [];\nvar created = 0;\n\nfunction LineSegment2 (start, end) {\n\tif (!(this instanceof LineSegment2)) {\n\t\tvar l = cache.pop();\n\t\tif (!l) {\n\t\t\tl = new LineSegment2(start, end);\n\t\t\tcreated++;\n\t\t} else {\n\t\t\tl.start.free();\n\t\t\tl.end.free();\n\t\t\tl.set(start, end);\n\t\t}\n\t\treturn l;\n\t}\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n}\n\nLineSegment2.getStats = function() {\n\treturn [cache.length, created];\n};\n\nLineSegment2.prototype.set = function (start, end) {\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n\treturn this;\n};\n\nLineSegment2.prototype.free = function () {\n\tcache.push(this);\n};\n\nLineSegment2.prototype.lengthSq = function () {\n\treturn this.start.distanceSq(this.end);\n};\n\nLineSegment2.prototype.length = function() {\n\treturn this.start.distance(this.end);\n};\n\nLineSegment2.prototype.closestPoint = function (point, full) {\n\tvar l2 = this.lengthSq();\n\tif (l2 === 0) {\n\t\treturn this.start.clone();\n\t}\n\tvar t = ((point.x - this.start.x) * (this.end.x - this.start.x) + (point.y - this.start.y)*(this.end.y - this.start.y)) / l2;\n\tif (!full) {\n\t\tif (t < 0) {\n\t\t\treturn this.start.clone();\n\t\t}\n\t\tif (t > 1) {\n\t\t\treturn this.end.clone();\n\t\t}\n\t}\n\treturn Vector2(this.start.x + t * (this.end.x-this.start.x), this.start.y + t * (this.end.y - this.start.y));\n};\n\nLineSegment2.prototype.distanceSq = function (point, full) {\n\tvar c = this.closestPoint(point, full);\n\tvar d = point.distanceSq(c);\n\tc.free();\n\treturn d;\n};\n\nLineSegment2.prototype.distance = function (point, full) {\n\treturn Math.sqrt(this.distanceSq(point, full));\n};\n\nLineSegment2.prototype.intersect = function (l, full) {\n\tvar u_b = (l.end.y - l.start.y) * (this.end.x - this.start.x) - (l.end.x - l.start.x) * (this.end.y - this.start.y);\n\tif (u_b !== 0) {\n\t\tvar ua_t = (l.end.x - l.start.x) * (this.start.y - l.start.y) - (l.end.y - l.start.y) * (this.start.x - l.start.x);\n\t\tvar ub_t = (this.end.x - this.start.x) * (this.start.y - l.start.y) - (this.end.y - this.start.y) * (this.start.x - l.start.x);\n\t\tvar ua = ua_t / u_b;\n\t\tvar ub = ub_t / u_b;\n\t\tif (full || (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)) {\n\t\t\treturn Vector2(this.start.x - ua * (this.start.x - this.end.x), this.start.y - ua * (this.start.y - this.end.y));\n\t\t}\n\t} else {\n\t\treturn null; // perpendicular\n\t}\n\treturn false;\n};\n\nLineSegment2.prototype.intersectCircle = function (point, radius, full) {\n\tvar r2 = radius*radius;\n\tvar closest = this.closestPoint(point, full);\n\tvar dist_v = point.clone().subtract(closest);\n\tvar len2 = dist_v.distanceSq();\n\tdist_v.free();\n\tif (len2 < r2) {\n\t\treturn closest;\n\t} else {\n\t\tclosest.free();\n\t\treturn false;\n\t}\n};\n\nLineSegment2.prototype.equals = function(other) {\n\treturn (this.start === other.start && this.end === other.end);\n};\n\nLineSegment2.prototype.inverse = function() {\n\treturn LineSegment2(this.end.clone(), this.start.clone());\n};\n\n/* jshint +W064 */\n\n},{\"./vector2\":23}],16:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\nvar LineSegment2 = require('./linesegment2');\nvar epsilon = 0.0000001;\n\nexports = module.exports = Polygon2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Polygon2 (points) {\n    if (!(this instanceof Polygon2)) {\n        var p = cache.pop();\n        if (!p) {\n            p = new Polygon2(points);\n            created++;\n        } else {\n            p.freePoints();\n            p.set(points);\n        }\n        return p;\n    }\n    this.points = points || [];\n}\n\nPolygon2.fromArray = function (points)\n{\n    var p = Polygon2();\n    for (var i = 0;i<points.length; i++) {\n        p.add(Vector2.fromArray(points[i]));\n    }\n    return p;\n};\n\nPolygon2.getStats = function() {\n    return [cache.length, created];\n};\n\nPolygon2.prototype.free = function ()\n{\n    this.freePoints();\n    cache.push(this);\n};\n\nPolygon2.prototype.freePoints = function ()\n{\n    var p = this.points.pop();\n    while (p) {\n        p.free();\n        p = this.points.pop();\n    }\n    return this;\n};\n\nPolygon2.prototype.set = function (points)\n{\n    this.points = points || [];\n    return this;\n};\n\nPolygon2.prototype.add = function (point)\n{\n    this.points.push(point);\n    return this;\n};\n\nPolygon2.prototype.translate = function (vec)\n{\n    for ( var i = 0; i<this.points.length;i++) {\n        this.points[i].add(vec);\n    }\n    return this;\n};\n\nPolygon2.prototype.rotate = function (angle, origin)\n{\n    for (var i = 0; i<this.points.length;i++) {\n        this.points[i].rotate(angle, origin);\n    }\n    return this;\n};\n\nPolygon2.prototype.containsPoint = function (point)\n{\n    var inside = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n\n        var intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n\nPolygon2.prototype.intersectsLine = function (line, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    var intersect = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n        tempLine.start.set(xi, yi);\n        tempLine.end.set(xj, yj);\n        var is = tempLine.intersect(line);\n        if (is) {\n            if (ignorePoints && (this.points[i].isEqualEpsilon(is) || this.points[j].isEqualEpsilon(is) || line.start.isEqualEpsilon(is) || line.end.isEqualEpsilon(is) )) {\n                // special perpendicular test\n                var a = this.points[i].clone().subtract(this.points[j]).normalize();\n                var aa = a.angle();\n                a.copy(line.start).subtract(line.end).normalize();\n                var bb = a.angle();\n                a.free();\n                is.free();\n                if (Math.abs(aa - bb) < epsilon) {\n                    intersect = true;\n                    break;\n                }\n                continue;\n            }\n            is.free();\n            intersect = true;\n            break;\n        }\n    }\n    tempLine.free();\n    return intersect;\n};\n\n\nPolygon2.prototype.intersectsTriangle = function (triangle, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    tempLine.start.copy(triangle.v0);\n    tempLine.end.copy(triangle.v1);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v1);\n    tempLine.end.copy(triangle.v2);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v2);\n    tempLine.end.copy(triangle.v0);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n    return false;\n};\n\nPolygon2.prototype.AABB = function()\n{\n    var min = this.points[0].clone();\n    var max = this.points[0].clone();\n\n    for (var i = 1; i< this.points.length; i++) {\n        var p = this.points[i];\n        if ( p.x < min.x ) {\n            min.x = p.x;\n        } else if ( p.x > max.x ) {\n            max.x = p.x;\n        }\n        if ( p.y < min.y ) {\n            min.y = p.y;\n        } else if ( p.y > max.y ) {\n            max.y = p.y;\n        }\n    }\n    return [min, max];\n};\n\n// negative = CCW\nPolygon2.prototype.winding = function() {\n    return this.area() > 0;\n};\n\nPolygon2.prototype.rewind = function(cw) {\n    cw = !!cw;\n    var winding = this.winding();\n    if (winding !== cw) {\n        this.points.reverse();\n    }\n    return this;\n};\n\nPolygon2.prototype.area = function() {\n    var area = 0;\n    var first = this.points[0];\n    var p1 = Vector2();\n    var p2 = Vector2();\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        p1.copy(first).subtract(this.points[i]);\n        p2.copy(first).subtract(this.points[j]);\n        area += p1.cross(p2);\n    }\n    p1.free();\n    p2.free();\n    return area/2;\n};\n\nPolygon2.prototype.clean = function(distance)\n{\n    var p1 = Vector2();\n    var newpoints = [];\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var length = p1.copy(this.points[i]).subtract(this.points[j]).length();\n        if (length > distance) {\n            newpoints.push(this.points[i]);\n        } else {\n            this.points[i].free();\n        }\n    }\n    this.points = newpoints;\n};\n\nPolygon2.prototype.toArray = function ()\n{\n    var ret = [];\n    for (var i = 0; i< this.points.length; i++) {\n        ret.push(this.points[i].toArray());\n    }\n    return ret;\n};\n\n\n/* jshint +W064 */\n\n},{\"./linesegment2\":15,\"./vector2\":23}],17:[function(require,module,exports){\n'use strict';\n\nvar PointNode = require('./pointnode');\n\nfunction BoundsNode(bounds, depth, maxChildren, maxDepth) {\n    PointNode.call(this, bounds, depth, maxChildren, maxDepth);\n    this._stuckChildren = [];\n}\n\nBoundsNode.prototype = new PointNode();\nBoundsNode.prototype._classConstructor = BoundsNode;\nBoundsNode.prototype._stuckChildren = null;\n\n//we use this to collect and conctenate items being retrieved. This way\n//we dont have to continuously create new Array instances.\n//Note, when returned from QuadTree.retrieve, we then copy the array\nBoundsNode.prototype._out = [];\n\nBoundsNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        //todo: make _bounds bounds\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            this.nodes[index].insert(item);\n\n        } else {\n            this._stuckChildren.push(item);\n        }\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nBoundsNode.prototype.getChildren = function () {\n    return this.children.concat(this._stuckChildren);\n};\n\nBoundsNode.prototype.retrieve = function (item) {\n    var out = this._out;\n    out.length = 0;\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            out.push.apply(out, this.nodes[index].retrieve(item));\n        } else {\n            //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n            if (item.x <= this.nodes[PointNode.TOP_RIGHT]._bounds.x) {\n                if (item.y <= this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_LEFT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_LEFT].retrieve(item));\n                }\n            }\n\n            if (item.x + item.width > this.nodes[PointNode.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                if (item.y <= this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_RIGHT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_RIGHT].retrieve(item));\n                }\n            }\n        }\n    }\n\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n\n    return out;\n};\n\n//Returns all contents of node.\nBoundsNode.prototype.getAllContent = function () {\n    var out = this._out;\n    if (this.nodes.length) {\n\n        var i;\n        for (i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].getAllContent();\n        }\n    }\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n    return out;\n};\n\nBoundsNode.prototype.clear = function () {\n\n    this._stuckChildren.length = 0;\n\n    //array\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    if (!len) {\n        return;\n    }\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    //array\n    this.nodes.length = 0;\n\n    //we could call the super clear function but for now, im just going to inline it\n    //call the hidden super.clear, and make sure its called with this = this instance\n    //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n};\n\nexports = module.exports = BoundsNode;\n\n},{\"./pointnode\":19}],18:[function(require,module,exports){\nmodule.exports = {\n  QuadTree: require('./quadtree'),\n  PointNode: require('./pointnode'),\n  BoundsNode: require('./boundsnode')  \n};\n\n},{\"./boundsnode\":17,\"./pointnode\":19,\"./quadtree\":20}],19:[function(require,module,exports){\n'use strict';\n\nfunction PointNode(bounds, depth, maxDepth, maxChildren) {\n    this._bounds = bounds;\n    this.children = [];\n    this.nodes = [];\n\n    if (maxChildren) {\n        this._maxChildren = maxChildren;\n    }\n\n    if (maxDepth) {\n        this._maxDepth = maxDepth;\n    }\n\n    if (depth) {\n        this._depth = depth;\n    }\n}\n\n//subnodes\nPointNode.prototype.nodes = null;\nPointNode.prototype._classConstructor = PointNode;\n\n//children contained directly in the node\nPointNode.prototype.children = null;\nPointNode.prototype._bounds = null;\n\n//read only\nPointNode.prototype._depth = 0;\n\nPointNode.prototype._maxChildren = 4;\nPointNode.prototype._maxDepth = 4;\n\nPointNode.TOP_LEFT = 0;\nPointNode.TOP_RIGHT = 1;\nPointNode.BOTTOM_LEFT = 2;\nPointNode.BOTTOM_RIGHT = 3;\n\n\nPointNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        this.nodes[index].insert(item);\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nPointNode.prototype.retrieve = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        return this.nodes[index].retrieve(item);\n    }\n\n    return this.children;\n};\n\nPointNode.prototype._findIndex = function (item) {\n    var b = this._bounds;\n    var left = (item.x > b.x + b.width / 2) ? false : true;\n    var top = (item.y > b.y + b.height / 2) ? false : true;\n\n    //top left\n    var index = PointNode.TOP_LEFT;\n    if (left) {\n        //left side\n        if (!top) {\n            //bottom left\n            index = PointNode.BOTTOM_LEFT;\n        }\n    } else {\n        //right side\n        if (top) {\n            //top right\n            index = PointNode.TOP_RIGHT;\n        } else {\n            //bottom right\n            index = PointNode.BOTTOM_RIGHT;\n        }\n    }\n\n    return index;\n};\n\n\nPointNode.prototype.subdivide = function () {\n    var depth = this._depth + 1;\n\n    var bx = this._bounds.x;\n    var by = this._bounds.y;\n\n    //floor the values\n    var b_w_h = (this._bounds.width / 2) | 0; //todo: Math.floor?\n    var b_h_h = (this._bounds.height / 2) | 0;\n    var bx_b_w_h = bx + b_w_h;\n    var by_b_h_h = by + b_h_h;\n\n    //top left\n    this.nodes[PointNode.TOP_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //top right\n    this.nodes[PointNode.TOP_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //bottom left\n    this.nodes[PointNode.BOTTOM_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n\n    //bottom right\n    this.nodes[PointNode.BOTTOM_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n};\n\nPointNode.prototype.clear = function () {\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    this.nodes.length = 0;\n};\n\n\nexports = module.exports = PointNode;\n\n},{}],20:[function(require,module,exports){\n'use strict';\n\nvar PointNode = require('./pointnode'),\n    BoundsNode = require('./boundsnode');\n\n/**\n* QuadTree data structure.\n* @class QuadTree\n* @constructor\n* @param {Object} An object representing the bounds of the top level of the QuadTree. The object\n* should contain the following properties : x, y, width, height\n* @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds\n* (width / height)(false). Default value is false.\n* @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n* @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n**/\nfunction QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n    var node;\n    if (pointQuad) {\n        node = new PointNode(bounds, 0, maxDepth, maxChildren);\n    } else {\n        node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n    }\n\n    this.root = node;\n}\n\n/**\n* The root node of the QuadTree which covers the entire area being segmented.\n* @property root\n* @type Node\n**/\nQuadTree.prototype.root = null;\n\n\n/**\n* Inserts an item into the QuadTree.\n* @method insert\n* @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y\n* properties that represents its position in 2D space.\n**/\nQuadTree.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            len = item.length;\n        while (i<len) {\n            this.root.insert(item[i]);\n            i++;\n        }\n    } else {\n        this.root.insert(item);\n    }\n};\n\n/**\n* Clears all nodes and children from the QuadTree\n* @method clear\n**/\nQuadTree.prototype.clear = function () {\n    this.root.clear();\n};\n\n/**\n* Retrieves all items / points in the same node as the specified item / point. If the specified item\n* overlaps the bounds of a node, then all children in both nodes will be returned.\n* @method retrieve\n* @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n* with dimensions (x, y, width, height) properties.\n**/\nQuadTree.prototype.retrieve = function (item) {\n    //get a copy of the array of items\n    return this.root.retrieve(item);\n    // var out = this.root.retrieve(item).slice(0);\n    // return out;\n};\n\nexports = module.exports = QuadTree;\n\n},{\"./boundsnode\":17,\"./pointnode\":19}],21:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2'),\n    Polygon2 = require('./polygon2');\n\nexports = module.exports = RegularPolygon2;\n\nfunction RegularPolygon2 (radius,sides, center)\n{\n    center = center || Vector2();\n\n    if (!sides || sides < 2) {\n        sides = 3;\n    }\n    if (!radius || radius <= 0) {\n        radius = 1;\n    }\n\n    var p = Polygon2();\n    for ( var i = 0; i < sides; i++) {\n        p.add(Vector2( center.x + radius * Math.cos( (i * 2 * Math.PI / sides) + 0.25*Math.PI), center.y + radius * Math.sin((i * 2 * Math.PI / sides) + 0.25*Math.PI)));\n    }\n    return p;\n}\n/* jshint +W064 */\n\n},{\"./polygon2\":16,\"./vector2\":23}],22:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nexports = module.exports = Triangle2;\n\nvar epsilon = 0.0000001;\nvar cache = [];\nvar created = 0;\n\nfunction Triangle2 (v0, v1, v2) {\n    if (!(this instanceof Triangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Triangle2(v0, v1, v2);\n            created++;\n        } else {\n            v.set(v0, v1, v2);\n            //v.calcCircumcircle();\n        }\n        return v;\n    }\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    /*\n    this.center = Vector2();\n    this.radius = 0;\n    this.radius_squared = 0;\n\n    this.calcCircumcircle();\n    */\n}\n\nTriangle2.getStats = function() {\n    return [cache.length, created];\n};\n\nTriangle2.prototype.free = function ()\n{\n    cache.push(this);\n};\n\n\nTriangle2.prototype.set = function (v0, v1, v2)\n{\n    this.v0.free();\n    this.v1.free();\n    this.v2.free();\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    return this;\n};\n\nTriangle2.prototype.translate = function (vec)\n{\n    this.v0.add(vec);\n    this.v1.add(vec);\n    this.v2.add(vec);\n    return this;\n};\n\nTriangle2.prototype.calcCircumcircle = function() {\n    // From: http://www.exaflop.org/docs/cgafaq/cga1.html\n\n    var A = this.v1.x - this.v0.x;\n    var B = this.v1.y - this.v0.y;\n    var C = this.v2.x - this.v0.x;\n    var D = this.v2.y - this.v0.y;\n\n    var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);\n    var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);\n\n    var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));\n\n    var dx, dy;\n\n    if (Math.abs(G) < epsilon) {\n        // Collinear - find extremes and use the midpoint\n\n        var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);\n        var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);\n        var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);\n        var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);\n\n        this.center.set((minx + maxx) / 2, (miny + maxy) / 2);\n\n        dx = this.center.x - minx;\n        dy = this.center.y - miny;\n    } else {\n        var cx = (D * E - B * F) / G;\n        var cy = (A * F - C * E) / G;\n\n        this.center.set(cx, cy);\n\n        dx = this.center.x - this.v0.x;\n        dy = this.center.y - this.v0.y;\n    }\n\n    this.radius_squared = dx * dx + dy * dy;\n    this.radius = Math.sqrt(this.radius_squared);\n};\n\nTriangle2.prototype.inCircumcircle = function(v) {\n    var dx = this.center.x - v.x;\n    var dy = this.center.y - v.y;\n    var dist_squared = dx * dx + dy * dy;\n\n    return (dist_squared <= this.radius_squared);\n};\n/* jshint +W064 */\n\n},{}],23:[function(require,module,exports){\n'use strict';\n/* jshint -W064 */\n\nexports = module.exports = Vector2;\n\nvar epsilon = 0.0000001;\nvar degrees = 180 / Math.PI;\n\nvar cache = [];\nvar created = 0;\n\nfunction Vector2 (x, y) {\n    if (!(this instanceof Vector2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Vector2(x || 0, y || 0);\n            created++;\n        } else {\n            v.set(x, y);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n}\n\nVector2.getStats = function() {\n    return [cache.length, created];\n};\n\nVector2.fromArray = function (arr) {\n    return Vector2(arr[0] || 0, arr[1] || 0);\n};\n\nVector2.fromObject = function (obj) {\n    return Vector2(obj.x || 0, obj.y || 0);\n};\n\nVector2.prototype.set = function (x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n};\n\nVector2.prototype.free = function () {\n    cache.push(this);\n};\n\nVector2.prototype.add = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nVector2.prototype.addScalar = function (scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    return this;\n};\n\n\nVector2.prototype.subtract = function (vec) {\n    this.x -= vec.x;\n    this.y -= vec.y;\n    return this;\n};\n\nVector2.prototype.subtractScalar = function (scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n};\n\n\nVector2.prototype.divide = function (vec) {\n    this.x /= vec.x;\n    this.y /= vec.y;\n    return this;\n};\n\nVector2.prototype.multiply = function (vec) {\n    this.x *= vec.x;\n    this.y *= vec.y;\n    return this;\n};\n\nVector2.prototype.multiplyScalar = function (scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n};\n\nVector2.prototype.normalize = function () {\n    var length = this.length();\n\n    if (length === 0) {\n        this.x = 0;\n        this.y = 0;\n    } else {\n        this.x /= length;\n        this.y /= length;\n    }\n    return this;\n};\n\nVector2.prototype.clone = function () {\n    return Vector2(this.x, this.y);\n};\n\nVector2.prototype.copy = function (vec) {\n    this.x = vec.x;\n    this.y = vec.y;\n    return this;\n};\n\nVector2.prototype.zero = function () {\n    this.x = this.y = 0;\n    return this;\n};\n\nVector2.prototype.dot = function (vec) {\n    return this.x * vec.x + this.y * vec.y;\n};\n\nVector2.prototype.cross = function (vec) {\n    return (this.x * vec.y ) - (this.y * vec.x );\n};\n\nVector2.prototype.projectOnto = function (vec) {\n    var coeff = ( (this.x * vec.x)+(this.y * vec.y) ) / ((vec.x*vec.x)+(vec.y*vec.y));\n    this.x = coeff * vec.x;\n    this.y = coeff * vec.y;\n    return this;\n};\n\n\nVector2.prototype.horizontalAngle = function () {\n    return Math.atan2(this.y, this.x);\n};\n\nVector2.prototype.horizontalAngleDeg = function () {\n    return radian2degrees(this.horizontalAngle());\n};\n\nVector2.prototype.verticalAngle = function () {\n    return Math.atan2(this.x, this.y);\n};\n\nVector2.prototype.verticalAngleDeg = function () {\n    return radian2degrees(this.verticalAngle());\n};\n\nVector2.prototype.angle = Vector2.prototype.horizontalAngle;\nVector2.prototype.angleDeg = Vector2.prototype.horizontalAngleDeg;\nVector2.prototype.direction = Vector2.prototype.horizontalAngle;\n\nVector2.prototype.rotate = function (angle, origin) {\n    var ox = 0,\n        oy = 0;\n    if (origin) {\n        ox = origin.x || 0;\n        oy = origin.y || 0;\n    }\n\n    var nx = ox + (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));\n    var ny = oy + (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));\n\n    this.x = nx;\n    this.y = ny;\n\n    return this;\n};\n\nVector2.prototype.rotateDeg = function (angle) {\n    angle = degrees2radian(angle);\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateBy = function (rotation) {\n    var angle = this.angle() + rotation;\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateByDeg = function (rotation) {\n    rotation = degrees2radian(rotation);\n    return this.rotateBy(rotation);\n};\n\nVector2.prototype.distance = function (vec) {\n    return Math.sqrt(this.distanceSq(vec));\n};\n\nVector2.prototype.distanceSq = function (vec) {\n    var dx = this.x - vec.x,\n    dy = this.y - vec.y;\n    return dx * dx + dy * dy;\n};\n\nVector2.prototype.length = function () {\n    return Math.sqrt(this.lengthSq());\n};\n\nVector2.prototype.lengthSq = function () {\n    return this.x * this.x + this.y * this.y;\n};\n\nVector2.prototype.magnitude = Vector2.prototype.length;\n\nVector2.prototype.isZero = function() {\n    return this.x === 0 && this.y === 0;\n};\nVector2.prototype.isEqualTo = function(vec) {\n    return this.x === vec.x && this.y === vec.y;\n};\n\nVector2.prototype.isEqualEpsilon = function(vec) {\n    return Math.abs(this.x - vec.x) < epsilon && Math.abs(this.y - vec.y) < epsilon;\n};\n\nVector2.prototype.toString = function () {\n    return 'x: ' + this.x + ', y: ' + this.y;\n};\n\nVector2.prototype.toArray = function () {\n    return [ this.x, this.y ];\n};\n\nVector2.prototype.toObject = function () {\n    return { x: this.x, y: this.y };\n};\n\nfunction radian2degrees (rad) {\n    return rad * degrees;\n}\n\nfunction degrees2radian (deg) {\n    return deg / degrees;\n}\n/* jshint +W064 */\n\n},{}],24:[function(require,module,exports){\n'use strict';\n/* jshint -W064 */\n\n/*\n    Based upon https://code.google.com/p/visibility-polygon-js/\n    Made by Byron Knoll in 2013/2014.\n*/\n\nvar Polygon2 = require('./polygon2'),\n    Vector2 = require('./vector2'),\n    LineSegment2 = require('./linesegment2');\n\nvar PI = Math.PI;\nvar PI2 = PI*2;\nvar PImin = -1*PI;\nvar epsilon = 0.0000001;\n\nvar segmentIter = ['start', 'end'];\nfunction pointsorter(a,b) {\n    return a[2] - b[2];\n}\n\nfunction VisibilityPolygon(segments)\n{\n    this.polygon = Polygon2();\n    this.segments = segments;\n    this.heap = [];\n    this.map = new Array(this.segments.length);\n    this.points = new Array(this.segments.length * 2);\n    this.position = Vector2();\n}\n\nVisibilityPolygon.prototype.angle = function (p1, p2)\n{\n    var p = p2.clone().subtract(p1);\n    var a = p.angle();\n    p.free();\n    return a;\n};\n\nVisibilityPolygon.prototype.angle2 = function (a, b, c) {\n    var a1 = this.angle(a, b);\n    var a2 = this.angle(b, c);\n    var a3 = a1 - a2;\n    if (a3 < 0) { a3 += PI2; }\n    if (a3 > PI2) { a3 -= PI2; }\n    return a3;\n};\n\n\nVisibilityPolygon.prototype.compute = function (position)\n{\n    this.position.copy(position);\n    this.reset();\n    this.sortPoints();\n\n    var start = this.position.clone();\n    start.x +=1; // why?\n\n    var i = 0,\n        n = this.segments.length;\n    while (i < n) {\n        var a1 = this.angle(this.segments[i].start, this.position);\n        var a2 = this.angle(this.segments[i].end, this.position);\n        if (\n            ( a1 > PImin && a1 <= 0 && a2 <= PI && a2 >= 0 && a2 - a1 > PI) ||\n            (a2 > PImin && a2 <= 0 && a1 <= PI && a1 >= 0 && a1 - a2 > PI)\n        ) {\n            this.insert(i, start);\n        }\n        i += 1;\n    }\n    i = 0;\n    n = this.segments.length*2;\n    while (i < n) {\n        var extend = false;\n        var shorten = false;\n        var orig = i;\n        var vertex = this.segments[this.points[i][0]][this.points[i][1]];\n        var old_segment = this.heap[0];\n        do {\n            if (this.map[this.points[i][0]] !== -1) {\n                if (this.points[i][0] === old_segment) {\n                    extend = true;\n                    vertex = this.segments[this.points[i][0]][this.points[i][1]];\n                }\n                this.remove(this.map[this.points[i][0]], vertex);\n            } else {\n                this.insert(this.points[i][0], vertex);\n                if (this.heap[0] !== old_segment) {\n                    shorten = true;\n                }\n            }\n            ++i;\n            if (i === n) { break; }\n        } while (this.points[i][2] < this.points[orig][2] + epsilon);\n\n        var l = LineSegment2(position.clone(), vertex.clone());\n        if (extend) {\n            this.polygon.add(vertex.clone());\n            var cur = this.segments[this.heap[0]].intersect(l, true);\n            if (cur ) {\n                if (!cur.isEqualEpsilon(vertex)) {\n                    this.polygon.add(cur);\n                } else {\n                    cur.free();\n                }\n            }\n        } else if (shorten) {\n            this.polygon.add(this.segments[old_segment].intersect(l, true));\n            this.polygon.add(this.segments[this.heap[0]].intersect(l, true));\n        }\n    }\n    return this.polygon;\n};\n\n\nVisibilityPolygon.prototype.insert = function (index, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var intersect = this.segments[index].intersect(l, true);\n    if (intersect === false) {\n        l.free();\n        return;\n    }\n    intersect.free();\n\n    var cur = this.heap.length;\n    this.heap.push(index);\n    this.map[index] = cur;\n    while (cur > 0) {\n        var parent = this.parent(cur);\n        if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n            break;\n        }\n        this.map[this.heap[parent]] = cur;\n        this.map[this.heap[cur]] = parent;\n        var temp = this.heap[cur];\n        this.heap[cur] = this.heap[parent];\n        this.heap[parent] = temp;\n        cur = parent;\n    }\n};\n\nVisibilityPolygon.prototype.remove = function (index, destination) {\n    this.map[this.heap[index]] = -1;\n    if (index === this.heap.length - 1) {\n        this.heap.pop();\n        return;\n    }\n    this.heap[index] = this.heap.pop();\n    this.map[this.heap[index]] = index;\n    var cur = index;\n    var parent = this.parent(cur);\n    if (cur !== 0 && this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n        while (cur > 0) {\n            parent = this.parent(cur);\n            if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n                break;\n            }\n            this.swap(cur, parent);\n            cur = parent;\n        }\n    } else {\n        while (true) {\n            var left = this.child(cur);\n            var right = left + 1;\n            if (left < this.heap.length && this.lessThan(this.heap[left], this.heap[cur], destination) &&\n                (right === this.heap.length || this.lessThan(this.heap[left], this.heap[right], destination))) {\n                    this.swap(cur, left);\n                    cur = left;\n                } else if (right < this.heap.length && this.lessThan(this.heap[right], this.heap[cur], destination)) {\n                    this.swap(cur, right);\n                    cur = right;\n                } else {\n                    break;\n                }\n            }\n        }\n    };\n\n\n\nVisibilityPolygon.prototype.lessThan = function (index1, index2, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var inter1 = this.segments[index1].intersect(l, true);\n    var inter2 = this.segments[index2].intersect(l, true);\n    if (!inter1.isEqualEpsilon(inter2)) {\n        var d1 = inter1.distanceSq(this.position);\n        var d2 = inter2.distanceSq(this.position);\n        inter1.free();\n        inter2.free();\n        l.free();\n        return d1 < d2;\n    }\n    var end1 = this.segments[index1].start;\n    if (inter1.isEqualEpsilon(this.segments[index1].start)) {\n        end1 = this.segments[index1].end;\n    }\n    var end2 = this.segments[index2].start;\n    if (inter2.isEqualEpsiolon(this.segments[index2].start)) {\n        end2 = this.segments[index2].end;\n    }\n    var a1 = this.angle2(end1, inter1, this.position);\n    var a2 = this.angle2(end2, inter2, this.position);\n    inter1.free();\n    inter2.free();\n    if (a1 < PI) {\n        if (a2 > PI) {\n            return true;\n        }\n        return a2 < a1;\n    }\n    return a1 < a2;\n};\n\nVisibilityPolygon.prototype.parent = function (index) {\n    return Math.floor((index - 1) / 2);\n};\n\nVisibilityPolygon.prototype.child = function (index) {\n    return 2 * index + 1;\n};\n\nVisibilityPolygon.prototype.swap = function (c, l) {\n    this.map[this.heap[l]] = c;\n    this.map[this.heap[c]] = l;\n    var temp = this.heap[l];\n    this.heap[l] = this.heap[c];\n    this.heap[c] = temp;\n};\n\n\nVisibilityPolygon.prototype.sortPoints = function ()\n{\n    var i = 0,\n    n = this.segments.length,\n    p = null,\n    pp = Vector2();\n    while (i < n) {\n        for (var j = 0; j < 2; ++j) {\n            if (j === 0) {\n                p = this.segments[i][segmentIter[j]];\n            } else {\n                p = this.segments[i][segmentIter[j]];\n            }\n            pp.copy(this.position).subtract(p);\n            var nr = 2 * i + j;\n            if (this.points[nr]) {\n                this.points[nr][0] = i;\n                this.points[nr][1] = segmentIter[j];\n                this.points[nr][2] = pp.angle();\n            } else {\n                this.points[nr] = [i, segmentIter[j], pp.angle()];\n            }\n        }\n        i += 1;\n    }\n    pp.free();\n    this.points = this.points.sort(pointsorter);\n};\n\nVisibilityPolygon.prototype.reset = function ()\n{\n    this.polygon.freePoints();\n    var i = 0,\n    n = this.map.length;\n    while (i < n) {\n        this.map[i] = -1;\n        i += 1;\n    }\n    while (this.heap.length > 0) {\n        this.heap.pop();\n    }\n};\n/* jshint +W064 */\n\n},{\"./linesegment2\":15,\"./polygon2\":16,\"./vector2\":23}],25:[function(require,module,exports){\n(function (global){\nvar core = {};\n\n\ncore.geometry = require('./geometry');\ncore.linkedlist = require('./linkedlist');\ncore.procedural = require('./procedural');\ncore.timer = require('./timer');\ncore.input = require('./input');\ncore.game = require('./game');\n\nmodule.exports = core;\n\nglobal.ULTRON = core;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./game\":6,\"./geometry\":14,\"./input\":26,\"./linkedlist\":30,\"./procedural\":33,\"./timer\":35}],26:[function(require,module,exports){\nmodule.exports = {\n  Unified: require('./unified')\n};\n\n},{\"./unified\":28}],27:[function(require,module,exports){\n//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\n// taken from game-shell\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif ( window.addEventListener ) {\n  _addEventListener = \"addEventListener\";\n} else {\n  _addEventListener = \"attachEvent\";\n  prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\n  elem[ _addEventListener ]( prefix + eventName, support === \"wheel\" ? callback : function( originalEvent ) {\n    !originalEvent && ( originalEvent = window.event );\n\n    // create a normalized event object\n    var event = {\n      // keep a ref to the original event object\n      originalEvent: originalEvent,\n      target: originalEvent.target || originalEvent.srcElement,\n      type: \"wheel\",\n      deltaMode: originalEvent.type === \"MozMousePixelScroll\" ? 0 : 1,\n      deltaX: 0,\n      delatZ: 0,\n      preventDefault: function() {\n        originalEvent.preventDefault ?\n          originalEvent.preventDefault() :\n          originalEvent.returnValue = false;\n      }\n    };\n\n    // calculate deltaY (and deltaX) according to the event\n    if ( support === \"mousewheel\" ) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n      // Webkit also support wheelDeltaX\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n    } else {\n      event.deltaY = originalEvent.detail;\n    }\n\n    // it's time to fire the callback\n    return callback( event );\n  }, useCapture || false );\n}\n\nmodule.exports = function( elem, callback, useCapture ) {\n  _addWheelListener( elem, support, callback, useCapture );\n\n  // handle MozMousePixelScroll in older Firefox\n  if( support === \"DOMMouseScroll\" ) {\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\n  }\n};\n\n},{}],28:[function(require,module,exports){\n'use strict';\n\n// taken from https://github.com/andyhall/game-inputs\n\nvar vkey = require('vkey');\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\nvar EventEmitter = require('eventemitter3');\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = require('./mousewheel-polyfill');\n\nmodule.exports = Inputs;\n\n// map button index to name\nvar gamepadButtonNames = [\n    'a',\n    'b',\n    'x',\n    'y',\n    'left-shoulder',\n    'right-shoulder',\n    'left-trigger',\n    'right-trigger',\n    'select',\n    'start',\n    'left-stick',\n    'right-stick',\n    'dpad-up',\n    'dpad-down',\n    'dpad-left',\n    'dpad-right'\n];\nvar gamepadAxesNames = [\n    'left-stick-x',\n    'left-stick-y',\n    'right-stick-x',\n    'right-stick-y'\n];\nvar hasGamepadEvents = 'GamepadEvent' in window;\n\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from)\n *        game-shell: https://github.com/mikolalysenko/game-shell\n *\n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *\n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n*/\n\n\nfunction Inputs(element, opts) {\n\n  // settings\n  this.element = element || document;\n  opts = opts || {};\n  this.preventDefaults = !!opts.preventDefaults;\n  this.stopPropagation = !!opts.stopPropagation;\n\n  // emitters\n  this.down = new EventEmitter();\n  this.up = new EventEmitter();\n  this.gamepadconnected = new EventEmitter();\n  this.gamepaddisconnected = new EventEmitter();\n\n  // state object to be queried\n  this.state = {\n    dx: 0, dy: 0,\n    scrollx: 0, scrolly: 0, scrollz: 0\n  };\n\n  // internal state\n  this._keybindmap = {};       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n  this._keyStates = {};        // { 'vkeycode' : boolean }\n  this._bindPressCounts = {};  // { 'binding' : int }\n  this._gamepads = {}; // { 'index' : gamepad }\n  this._gamepadButtonStates = {}; // { 'vcode' : int }\n\n  // raf handle\n  this._gamepadRaf = false;\n\n  // register for dom events\n  this.initEvents();\n}\n\n\n/*\n *\n *   PUBLIC API\n *\n*/\n\nInputs.prototype.initEvents = function() {\n  // keys\n  window.addEventListener( 'keydown', onKeyEvent.bind(undefined,this,true), false );\n  window.addEventListener( 'keyup', onKeyEvent.bind(undefined,this,false), false );\n  // mouse buttons\n  this.element.addEventListener('mousedown', onMouseEvent.bind(undefined,this,true), false);\n  this.element.addEventListener('mouseup', onMouseEvent.bind(undefined,this,false), false);\n  this.element.oncontextmenu = onContextMenu.bind(undefined,this);\n  // mouse other\n  this.element.addEventListener('mousemove', onMouseMove.bind(undefined,this), false);\n  addMouseWheel(this.element, onMouseWheel.bind(undefined,this), false);\n\n  // gamepads\n  if ( hasGamepadEvents ) {\n      window.addEventListener('gamepadconnected', onGamepadConnected.bind(undefined,this), false);\n      window.addEventListener('gamepaddisconnected', onGamepadDisconnected.bind(undefined,this), false);\n  } else {\n      window.setInterval(scanGamepads.bind(undefined, this), 500);\n  }\n};\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function(binding) {\n  for (var i=1; i<arguments.length; ++i) {\n    var vkeyCode = arguments[i];\n    var arr = this._keybindmap[vkeyCode] || [];\n    if (arr.indexOf(binding) === -1) {\n      arr.push(binding);\n    }\n    this._keybindmap[vkeyCode] = arr;\n  }\n  this.state[binding] = !!this.state[binding];\n};\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function(binding) {\n  for (var b in this._keybindmap) {\n    var arr = this._keybindmap[b];\n    var i = arr.indexOf(binding);\n    if (i>-1) { arr.splice(i,1); }\n  }\n};\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function() {\n  this.state['mouse-dx'] = this.state['mouse-dy'] = 0;\n  this.state['mouse-scrollx'] = this.state['mouse-scrolly'] = this.state['mouse-scrollz'] = 0;\n};\n\n\n\nInputs.prototype.getBoundKeys = function() {\n  var arr = [];\n  for (var b in this._keybindmap) { arr.push(b); }\n  return arr;\n};\n\n\n/*\n *   INTERNALS - DOM EVENT HANDLERS\n*/\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n  handleKeyEvent( ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev );\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n  // simulate a code out of range of vkey\n  var keycode = -1 - ev.button;\n  var vkeycode = '<mouse '+ (ev.button+1) +'>';\n  handleKeyEvent( keycode, vkeycode, wasDown, inputs, ev );\n  return false;\n}\n\nfunction onContextMenu(inputs) {\n  // cancel context menu if there's a binding for right mousebutton\n  var arr = inputs._keybindmap['<mouse 3>'];\n  if (arr) { return false; }\n}\n\nfunction onMouseMove(inputs, ev) {\n  // for now, just populate the state object with mouse movement\n  var dx = ev.movementX || ev.mozMovementX || ev.webkitMovementX || 0,\n      dy = ev.movementY || ev.mozMovementY || ev.webkitMovementY || 0;\n  inputs.state['mouse-dx'] += dx;\n  inputs.state['mouse-dy'] += dy;\n  // TODO: verify if this is working/useful during pointerlock?\n}\n\nfunction onMouseWheel(inputs, ev) {\n  // basically borrowed from game-shell\n  var scale = 1;\n  switch(ev.deltaMode) {\n    case 0: scale=1;   break;  // Pixel\n    case 1: scale=12;  break;  // Line\n    case 2:  // page\n      // TODO: investigagte when this happens, what correct handling is\n      scale = inputs.element.clientHeight || window.innerHeight;\n      break;\n  }\n  // accumulate state\n  inputs.state['mouse-scrollx'] += ev.deltaX * scale;\n  inputs.state['mouse-scrolly'] += ev.deltaY * scale;\n  inputs.state['mouse-scrollz'] += (ev.deltaZ * scale) || 0;\n  return false;\n}\n\n\n/*\n *   KEY BIND HANDLING\n*/\n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n  var arr = inputs._keybindmap[vcode];\n  // don't prevent defaults if there's no binding\n  if (!arr) { return; }\n  if (inputs.preventDefaults) { ev.preventDefault(); }\n  if (inputs.stopPropagation) { ev.stopPropagation(); }\n\n  // if the key's state has changed, handle an event for all bindings\n  var currstate = inputs._keyStates[keycode];\n  if ( XOR(currstate, wasDown) ) {\n    // for each binding: emit an event, and update cached state information\n    for (var i=0; i<arr.length; ++i) {\n      handleBindingEvent( arr[i], wasDown, inputs, ev );\n    }\n  }\n  inputs._keyStates[keycode] = wasDown;\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n  // keep count of presses mapped by binding\n  // (to handle two keys with the same binding pressed at once)\n  var ct = inputs._bindPressCounts[binding] || 0;\n  ct += wasDown ? 1 : -1;\n  if (ct<0) { ct = 0; } // shouldn't happen\n  inputs._bindPressCounts[binding] = ct;\n\n  // emit event if binding's state has changed\n  var currstate = inputs.state[binding];\n  if ( XOR(currstate, ct) ) {\n    var emitter = wasDown ? inputs.down : inputs.up;\n    emitter.emit(binding, binding, ev);\n  }\n  inputs.state[binding] = !!ct;\n}\n\n/**\nGamepad HANDLERS\n*/\n\nfunction handleGamePadButtonEvent(val, vcode, inputs) {\n    var arr = inputs._keybindmap[vcode];\n    if (!arr) { return; }\n\n    var pressed = val === 1.0;\n    var isPerc = false;\n    if (typeof(val) === 'object') {\n        pressed = val.pressed;\n        val = val.value;\n        isPerc = true;\n        inputs.state[vcode] = val;\n    } else {\n        var currstate = inputs._buttonStates[vcode];\n        if (XOR(currstate, val)) {\n            var i = 0;\n            for (i=0; i<arr.length; ++i) {\n                handleBindingEvent( arr[i], pressed, inputs, null); // pass null as fake event\n            }\n        }\n    }\n}\n\nfunction updateGamepads(inputs) {\n    var found = scanGamepads(inputs);\n    if (!found) {\n        if (inputs._gamepadRaf) {\n            cancel(inputs._gamepadRaf);\n            inputs._gamepadRaf = false;\n        }\n        return;\n    }\n\n    var vcode = '';\n    for (var j in inputs._gamepads) {\n        var gamepad = inputs._gamepads[j];\n\n        for (var i=0;i<gamepad.buttons.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadButtonNames[i] + '>';\n            handleGamePadButtonEvent(gamepad.buttons[i], vcode, inputs);\n        }\n\n        for (i=0;i<gamepad.axes.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadAxesNames[i] + '>';\n            inputs.state[vcode] = gamepad.axes[i];\n        }\n    }\n    inputs._gamepadRaf = request(updateGamepads);\n}\n\nfunction onGamepadConnected(inputs, ev) {\n    addGamepad(inputs, ev.gamepad);\n}\n\nfunction onGamepadDisconnected(inputs, ev) {\n    removeGamepad(inputs, ev.gamepad);\n}\n\n\nfunction addGamepad(inputs, gamepad) {\n    inputs._gamepads[gamepad.index] = gamepad;\n    inputs.gamepadconnected.emit(gamepad);\n    if (!inputs._gamepadRaf) {\n        inputs._gamepadRaf = request(updateGamepads);\n    }\n}\n\nfunction removeGamepad(inputs, gamepad) {\n    delete inputs._gamepads[gamepad.index];\n    inputs.gamepaddisconnected.emit(gamepad);\n    for (var j in inputs._gamepads) {\n        if (inputs._gamepads.hasOwnProperty(j)) {\n            return;\n        }\n    }\n    if (inputs._gamepadRaf) {\n        cancel(inputs._gamepadRaf);\n        inputs._gamepadRaf = false;\n    }\n}\n\n\nfunction scanGamepads(inputs) {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n    var found = false;\n    for (var i = 0; i < gamepads.length; i++) {\n        if (gamepads[i]) {\n            found = true;\n            if (!(gamepads[i].index in inputs._gamepads)) {\n                addGamepad(inputs, gamepads[i]);\n            } else {\n                inputs._gamepads[gamepads[i].index] = gamepads[i];\n            }\n        }\n    }\n    return found;\n}\n\n/*\n *    HELPERS\n *\n*/\n\n\n// how is this not part of Javascript?\nfunction XOR(a,b) {\n  return a ? !b : b;\n}\n\n},{\"./mousewheel-polyfill\":27,\"eventemitter3\":2,\"request-frame\":3,\"vkey\":4}],29:[function(require,module,exports){\n/*\n * Doubly Linked List implementation in JavaScript\n * Copyright (c) 2009 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n /*\n  * Optimizations and data reuse by Wouter Commandeur\n */\n\n'use strict';\n\n/**\n * A linked list implementation in JavaScript.\n * @class DoublyLinkedList\n * @constructor\n */\nfunction DoublyLinkedList() {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    this._head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    this._tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type int\n     * @private\n     */\n    this._length = 0;\n\n    this._nodeCache = [];\n\n}\n\nDoublyLinkedList.prototype = {\n\n    //restore constructor\n    constructor: DoublyLinkedList,\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {variant} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    add: function (data) {\n        //create a new item object, place data in\n        var node = this._allocate(data);\n\n        //special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n        } else {\n            //attach to the tail node\n            this._tail.next = node;\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        //don't forget to update the count\n        this._length++;\n\n    },\n\n\n    set: function(index, data) {\n        // update data at index\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            current.data = data;\n        }\n    },\n\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {int} index The zero-based index of the item whose value\n     *      should be returned.\n     * @return {variant} The value in the \"data\" portion of the given item\n     *      or null if the item doesn't exist.\n     * @method item\n     */\n    item: function(index){\n\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            return current.data;\n        } else {\n            return null;\n        }\n    },\n\n    pop: function() {\n        return this.remove(this._length -1);\n    },\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {variant} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    remove: function(index){\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n\n            var current = this._head,\n                i = 0;\n\n            //special case: removing first item\n            if (index === 0){\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head){\n                    this._tail = null;\n                } else {\n                    this._head.prev = null;\n                }\n\n            //special case: removing last item\n            } else if (index === this._length -1){\n                current = this._tail;\n                this._tail = current.prev;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while(i++ < index){\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.prev.next = current.next;\n            }\n\n            //decrement the length\n            this._length--;\n\n            // release into object pool\n            this._free(current);\n\n            //return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    },\n\n    clear: function() {\n        while (this._length > 0) {\n            this.remove(0);\n        }\n    },\n\n   /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    size: function(){\n        return this._length;\n    },\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    toArray: function(){\n        var result = [],\n            current = this._head;\n\n        while(current){\n            result.push(current.data);\n            current = current.next;\n        }\n\n        return result;\n    },\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    toString: function(){\n        return this.toArray().toString();\n    },\n\n    _free: function(node) {\n        this._nodeCache.push(node);\n    },\n\n    _allocate: function(data) {\n        var node = this._nodeCache.pop();\n        if (!node) {\n            node = {};\n        }\n        node.data = data;\n        node.prev = null;\n        node.next = null;\n        return node;\n    }\n};\n\nexports = module.exports = DoublyLinkedList;\n\n},{}],30:[function(require,module,exports){\nmodule.exports = {\n  DoublyLinkedList: require('./doublylinkedlist')\n};\n\n},{\"./doublylinkedlist\":29}],31:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\nvar RegularPolygon2 = require('../geometry/regularpolygon2');\nvar Polygon2 = require('../geometry/polygon2');\nvar Vector2 = require('../geometry/vector2');\nvar LineSegment2 = require('../geometry/linesegment2');\nvar gpc = require('../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('./graph');\n\nexports = module.exports = Building;\n\nvar createPoly = function(points) {\n\tvar res  = new gpc.geometry.PolyDefault();\n\tfor(var i=0 ; i < points.length ; i++) {\n\t\tres.addPoint(new gpc.geometry.Point(points[i][0],points[i][1]));\n\t}\n\treturn res;\n};\n\nvar getPolygonVertices = function(poly) {\n\tvar vertices=[];\n\tvar numPoints = poly.getNumPoints();\n\tvar i;\n\n\tfor(i=0;i<numPoints;i++) {\n\t\tvertices.push([poly.getX(i) , poly.getY(i)]);\n\t}\n\treturn vertices;\n};\n\nfunction Building( chance, iterations, minRadius, maxRadius, maxSides, noRotate)\n{\n\tvar end, l;\n\tthis.centers = [];\n\titerations = iterations || 1;\n//\tif ( iterations < 3 ) {\n//\t\titerations = 3;\n//\t}\n\tmaxSides = maxSides || 6;\n\tif ( maxSides < 4 ) {\n\t\tmaxSides = 4;\n\t}\n\tvar sidesChanceObj = { min: 4, max: maxSides };\n\tvar radiusChanceObj = { min: minRadius, max: maxRadius };\n\n\tvar sides = chance.integer(sidesChanceObj);\n\tvar polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\tvar gpcPoly = createPoly(polygon.toArray());\n\tpolygon.free();\n\tvar vec, gpcPoly2, num;\n\tthis.centers.push(Vector2());\n\n\tfor (var i = 1; i < iterations;i++) {\n\t\t// new random polygon\n\t\tsides = chance.integer(sidesChanceObj);\n\t\tpolygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\n\t\t// rotate random\n\t\tif (!noRotate) {\n\t\t\tpolygon.rotate(chance.floating({min: 0, max: 2 * Math.PI / sides}));\n\t\t}\n\n\t\t// random point on prev poly\n\t\tnum = chance.integer({min: 0, max:gpcPoly.getNumPoints()-1});\n\t\tvec = Vector2(gpcPoly.getX(num), gpcPoly.getY(num));\n\t\tthis.centers.push(vec);\n\n\t\t// center the polygon on a random point of the previous polygon\n\t\tpolygon.translate(vec);\n\t\tgpcPoly2 = createPoly(polygon.toArray());\n\t\tgpcPoly = gpcPoly.union(gpcPoly2);\n\n\t\t// free our stuff for reuse\n\t\tpolygon.free();\n\t}\n\tvar arr = getPolygonVertices(gpcPoly);\n\n\t// generate final polygon\n\tpolygon = Polygon2.fromArray(arr);\n\tthis.polygon = polygon;\n\n\t// this.polygon.clean(30);\n\n\t// add outer doors\n\tvar nrdoors = Math.ceil(iterations/2);\n\tthis.doors = [];\n\n\tvar nr;\n\tvar dooredges = {};\n\tfor ( i=0;i<nrdoors;i++) {\n\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\twhile (dooredges[nr]) {\n\t\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\t}\n\t\tdooredges[nr] = true;\n\t\tend = nr + 1;\n\t\tif (end === this.polygon.points.length) {\n\t\t\tend = 0;\n\t\t}\n\t\tl = LineSegment2(this.polygon.points[nr].clone(), this.polygon.points[end].clone());\n\t\tvar p2 = l.end.clone();\n\t\tvar p1 = l.start.clone();\n\t\tvar length = l.length(); // p2.subtract(l.start).length();\n\t\tp2.subtract(l.start).normalize().multiplyScalar(length/2);\n\t\tp1.add(p2);\n\t\t// this.centers.push(p1);\n\t\tthis.doors.push(p1);\n\t\tp2.free();\n\t\tl.free();\n\t}\n\n\n\n\tvar c = [];\n\tfor (i = 0; i < this.centers.length; i++) {\n\t\tc.push(this.centers[i].toArray());\n\t}\n\n\tthis.graph = new Graph();\n\tthis.delaunay_used = {};\n\n\t// delaunay the centers\n\tthis.delaunay = Delaunay.triangulate(c);\n\n\tfor (i = 0; i < this.delaunay.length; i += 1) {\n\t\tif (!this.delaunay_used[this.delaunay[i]]) {\n\t\t\tthis.graph.addNode(this.delaunay[i]);\n\t\t\tthis.delaunay_used[this.delaunay[i]] = true;\n\t\t}\n\t}\n\n\n\tthis.delaunay_exists = {};\n\n\tthis.delaunay_triangles = [];\n\tthis.delaunay_lines = [];\n\tfor (i = 0; i < this.delaunay.length; i += 3) {\n\t\t// line 1\n\t\tthis.addDelaunayLine(i, i+1);\n\t\tthis.addDelaunayLine(i+1, i+2);\n\t\tthis.addDelaunayLine(i+2, i);\n\t}\n\n\t// connect the doors;\n\tnr = this.centers.length;\n\tfor (i = 0; i < this.doors.length; i++) {\n\t\tthis.connectDoor(this.doors[i], nr);\n\t}\n\n\n\n\t// calculate the minimal spanning tree\n\tvar edges = this.graph.prim(); // Prim(this.graph);\n\t// console.log(edges);\n\tthis.mst_lines = [];\n\n\tfor (i = 0; i < edges.length; i ++) {\n\t\tvar start = edges[i].source;\n\t\tend = edges[i].sink;\n\t\tl = LineSegment2(this.centers[start].clone(), this.centers[end].clone());\n\t\tthis.mst_lines.push(l);\n\t\t//var l = LineSegment2()\n\t}\n\n\n\tthis.outside = this.polygon.AABB();\n\n\tthis.outside[0].subtractScalar(50);\n\tthis.outside[1].addScalar(50);\n\n}\n\nBuilding.prototype.connectDoor = function(door, nr)\n{\n\tvar min = 9999999;\n\tvar l,d;\n\tvar point = false;\n\tfor (var i= 0;i<nr;i++) {\n\t\tl = LineSegment2(this.centers[i].clone(), door.clone());\n\t\tif (!this.polygon.intersectsLine(l, true)) {\n\t\t\td = l.length();\n\t\t\tif ( d < min ) {\n\t\t\t\tmin = d;\n\t\t\t\tpoint = i;\n\t\t\t}\n\t\t}\n\t\tl.free();\n\t}\n\tif (point !== false) {\n\t\tthis.centers.push(door.clone());\n\t\tthis.graph.addNode(this.centers.length - 1);\n\t\tthis.graph.addEdge(point, this.centers.length - 1, min);\n\t\tthis.delaunay_lines.push(LineSegment2(this.centers[point].clone(), door.clone()));\n\t} else {\n\t\tl.free();\n\t}\n\n};\n\nBuilding.prototype.addDelaunayLine = function(start, end)\n{\n\tvar key1 = start + ':' + end;\n\tvar key2 = end + ':' + start;\n\tif (this.delaunay_exists[key1] || this.delaunay_exists[key2]) {\n\t\treturn;\n\t}\n\tthis.delaunay_exists[key1] = true;\n\tthis.delaunay_exists[key2] = true;\n\tvar l = LineSegment2(this.centers[this.delaunay[start]].clone(), this.centers[this.delaunay[end]].clone());\n\tif (this.polygon.intersectsLine(l)) {\n\t\tl.free();\n\t} else {\n\t\tthis.graph.addEdge(this.delaunay[start], this.delaunay[end], l.length());\n\t\tthis.delaunay_lines.push(l);\n\t}\n};\n\n\nBuilding.prototype.translate = function (vec)\n{\n\tthis.polygon.translate(vec);\n\tfor (var i=0;i<this.centers.length;i++) {\n\t\tthis.centers[i].add(vec);\n\t}\n\tfor (i =0;i<this.delaunay_triangles.length;i++) {\n\t\tthis.delaunay_triangles[i].translate(vec);\n\t}\n\treturn this;\n};\n\n\n/* jshint +W064 */\n\n},{\"../geometry/gpc\":10,\"../geometry/linesegment2\":15,\"../geometry/polygon2\":16,\"../geometry/regularpolygon2\":21,\"../geometry/vector2\":23,\"./graph\":32,\"delaunay-fast\":1}],32:[function(require,module,exports){\n'use strict';\n\n\n\n// Represents an edge from source to sink with capacity\nvar Edge = function(source, sink, capacity) {\n    this.source = source;\n    this.sink = sink;\n    this.capacity = capacity;\n};\n\n// Main class to manage the network\nvar Graph = function() {\n    this.edges = {};\n    this.nodes = [];\n    this.nodeMap = {};\n\n    // Add a node to the graph\n    this.addNode = function(node) {\n        this.nodes.push(node);\n        this.nodeMap[node] = this.nodes.length-1;\n        this.edges[node] = [];\n    };\n\n    // Add an edge from source to sink with capacity\n    this.addEdge = function(source, sink, capacity) {\n        // Create the two edges = one being the reverse of the other\n        this.edges[source].push(new Edge(source, sink, capacity));\n        this.edges[sink].push(new Edge(sink, source, capacity));\n    };\n\n    // Does edge from source to sink exist?\n    this.edgeExists = function(source, sink) {\n        if(this.edges[source] !== undefined) {\n            for(var i=0;i<this.edges[source].length;i++) {\n                if(this.edges[source][i].sink === sink) {\n                    return this.edges[source][i];\n                }\n            }\n        }\n        return null;\n    };\n\n\n    this.prim = function() {\n        var result = [];\n        var resultEdges = [];\n        var usedNodes = {};\n\n        function findMin(g) {\n            var min = [999999,null];\n            for(var i=0;i<result.length;i++) {\n                for(var n=0;n<g.edges[result[i]].length;n++) {\n                    if(g.edges[result[i]][n].capacity < min[0] && usedNodes[g.edges[result[i]][n].sink] === undefined) {\n                        min = [g.edges[result[i]][n].capacity, g.edges[result[i]][n]];\n                    }\n                }\n            }\n            return min;\n        }\n\n        // Pick random start point\n        var node = this.nodes[Math.round(Math.random()*(this.nodes.length-1))];\n        result.push(node);\n        usedNodes[node] = true;\n\n        var min = findMin(this);\n        while(min[1] !== null) {\n            resultEdges.push(min[1]);\n            result.push(min[1].sink);\n            usedNodes[min[1].sink] = true;\n            min = findMin(this);\n        }\n\n        return resultEdges;\n    };\n\n};\n\nmodule.exports = Graph;\n\n},{}],33:[function(require,module,exports){\nmodule.exports = {\n  Graph: require('./graph'),\n  Building: require('./building')\n};\n\n},{\"./building\":31,\"./graph\":32}],34:[function(require,module,exports){\n'use strict';\n\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\n\nvar NOOP = function(){};\n\nexports = module.exports = GameLoop;\n\nfunction GameLoop () {\n  this.simulationTimestep = 1000 / 60;\n  this.frameDelta = 0;\n  this.lastFrameTimeMs = 0;\n  this.fps = 60;\n  this.lastFpsUpdate = 0;\n  this.framesThisSecond = 0;\n  this.numUpdateSteps = 0;\n  this.minFrameDelay = 0;\n  this.running = false;\n  this.started = false;\n  this.panic = false;\n  this.rafHandle = false;\n  this.boundAnimate = this.animate.bind(this);\n}\n\nGameLoop.prototype.begin = NOOP;\nGameLoop.prototype.update = NOOP;\nGameLoop.prototype.render = NOOP;\nGameLoop.prototype.end = NOOP;\n\nGameLoop.prototype.getSimulationTimestep = function() {\n  return this.simulationTimestep;\n};\n\nGameLoop.prototype.setSimulationTimestep = function(timestep) {\n  this.simulationTimestep = timestep;\n  return this;\n};\n\nGameLoop.prototype.getFPS = function () {\n  return this.fps;\n};\n\nGameLoop.prototype.getMaxAllowedFPS = function() {\n  return 1000 / this.minFrameDelay;\n};\n\nGameLoop.prototype.setMaxAllowedFPS =  function(fps) {\n  if (typeof fps === 'undefined') {\n    fps = Infinity;\n  }\n  if (fps === 0) {\n    this.stop();\n  }\n  else {\n    // Dividing by Infinity returns zero.\n    this.minFrameDelay = 1000 / fps;\n  }\n  return this;\n};\n\nGameLoop.prototype.resetFrameDelta = function() {\n  var oldFrameDelta = this.frameDelta;\n  this.frameDelta = 0;\n  return oldFrameDelta;\n};\n\nGameLoop.prototype.setBegin = function(fun) {\n  this.begin = fun || this.begin;\n  return this;\n};\n\nGameLoop.prototype.setUpdate = function(fun) {\n  this.update = fun || this.update;\n  return this;\n};\n\nGameLoop.prototype.setRender = function(fun) {\n  this.render = fun || this.render;\n  return this;\n};\n\nGameLoop.prototype.setEnd = function(fun) {\n  this.end = fun || this.end;\n  return this;\n};\n\nGameLoop.prototype.start = function() {\n  if (!this.started) {\n    this.started = true;\n    var self = this;\n    this.rafHandle = request(function(timestamp) {\n      self.render(1);\n      self.running = true;\n      self.lastFrameTimeMs = timestamp;\n      self.lastFpsUpdate = timestamp;\n      self.framesThisSecond = 0;\n      self.rafHandle = request(self.boundAnimate);\n    });\n  }\n  return this;\n};\n\nGameLoop.prototype.stop = function() {\n  this.running = false;\n  this.started = false;\n  cancel(this.rafHandle);\n  return this;\n};\n\nGameLoop.prototype.isRunning = function() {\n  return this.running;\n};\n\nGameLoop.prototype.animate = function animate(timestamp) {\n\n    if (timestamp < this.lastFrameTimeMs + this.minFrameDelay) {\n        this.rafHandle = request(this.boundAnimate);\n        return;\n    }\n\n    this.frameDelta += timestamp - this.lastFrameTimeMs;\n    this.lastFrameTimeMs = timestamp;\n\n    this.begin(timestamp, this.frameDelta);\n\n    if (timestamp > this.lastFpsUpdate + 1000) {\n        this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;\n        this.lastFpsUpdate = timestamp;\n        this.framesThisSecond = 0;\n    }\n    this.framesThisSecond++;\n\n     /* - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    this.numUpdateSteps = 0;\n    while (this.frameDelta >= this.simulationTimestep) {\n        this.update(this.simulationTimestep);\n        this.frameDelta -= this.simulationTimestep;\n\n        if (++this.numUpdateSteps >= 240) {\n            this.panic = true;\n            break;\n        }\n    }\n\n    this.render(this.frameDelta / this.simulationTimestep);\n\n    this.end(this.fps, this.panic);\n\n    this.panic = false;\n\n    this.rafHandle = request(this.boundAnimate);\n};\n\n},{\"request-frame\":3}],35:[function(require,module,exports){\nmodule.exports = {\n  GameLoop: require('./gameloop')\n};\n\n},{\"./gameloop\":34}]},{},[25])(25)\n});\n\n","'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\n *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for\n *   optimal cross-browser development.\n *    Version:  v1.4.0\n *     License:  MIT\n *      Copyright Julien Etienne 2015 All Rights Reserved.\n *        github:  https://github.com/julienetie/request-frame\n *\n */\n(function (window) {\n\n/**\n * @param  {String} type - request | cancel | native.\n * @return {Function} Timing function.\n */\nfunction requestFrame(type) {\n    // The only vendor prefixes required.\n    var vendors = ['moz', 'webkit'],\n\n        // Disassembled timing function abbreviations.\n        aF = 'AnimationFrame',\n        rqAF = 'Request' + aF,\n\n        // Final assigned functions.\n        assignedRequestAnimationFrame,\n        assignedCancelAnimationFrame,\n\n        // Initial time of the timing lapse.\n        previousTime = 0,\n\n        mozRAF = window.mozRequestAnimationFrame,\n        mozCAF = window.mozCancelAnimationFrame,\n\n        // Checks for firefox 4 - 10 function pair mismatch.\n        hasMozMismatch = mozRAF && !mozCAF,\n\n        func;\n\n    // Date.now polyfill, mainly for legacy IE versions.\n    if (!Date.now) {\n        Date.now = function() {\n            return new Date().getTime();\n        };\n    }\n\n    /**\n     * hasIOS6RequestAnimationFrameBug.\n     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}\n     * - for Commentary.\n     * @Copyright 2015 - Julien Etienne. \n     * @License: MIT.\n     */\n    function hasIOS6RequestAnimationFrameBug() {\n        var webkitRAF = window.webkitRequestAnimationFrame,\n            rAF = window.requestAnimationFrame,\n\n            // CSS/ Device with max for iOS6 Devices.\n            hasMobileDeviceWidth = screen.width <= 768 ? true : false,\n\n            // Only supports webkit prefixed requestAnimtionFrane.\n            requiresWebkitprefix = !(webkitRAF && rAF),\n\n            // iOS6 webkit browsers don't support performance now.\n            hasNoNavigationTiming = window.performance ? false : true,\n\n            iOS6Notice = 'setTimeout is being used as a substitiue for' +\n            'requestAnimationFrame due to a bug within iOS 6 builds',\n\n            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&\n            hasNoNavigationTiming;\n\n        function bugCheckresults(timingFnA, timingFnB, notice) {\n            if (timingFnA || timingFnB) {\n                console.warn(notice);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function displayResults() {\n            if (hasIOS6Bug) {\n                return bugCheckresults(webkitRAF, rAF, iOS6Notice);\n            } else {\n                return false;\n            }\n        }\n\n        return displayResults();\n    }\n\n    /**\n     * Native clearTimeout function.\n     * @return {Function}\n     */\n    function clearTimeoutWithId(id) {\n        clearTimeout(id);\n    }\n\n    /**\n     * Based on a polyfill by Erik, introduced by Paul Irish & \n     * further improved by Darius Bacon.\n     * @see  {@link http://www.paulirish.com/2011/\n     * requestanimationframe-for-smart-animating}\n     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/\n     * master/requestAnimationFrame.js}\n     * @callback {Number} Timestamp.\n     * @return {Function} setTimeout Function.\n     */\n    function setTimeoutWithTimestamp(callback) {\n        var immediateTime = Date.now(),\n            lapsedTime = Math.max(previousTime + 16, immediateTime);\n        return setTimeout(function() {\n                callback(previousTime = lapsedTime);\n            },\n            lapsedTime - immediateTime);\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the setTimeoutWithTimestamp function.\n     * @return {Function}\n     */\n    function queryRequestAnimationFrame() {\n        if (Array.prototype.filter) {\n            assignedRequestAnimationFrame = window['request' + aF] ||\n                window[vendors.filter(function(vendor) {\n                    if (window[vendor + rqAF] !== undefined)\n                        return vendor;\n                }) + rqAF] || setTimeoutWithTimestamp;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedRequestAnimationFrame;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the clearTimeoutWithId function.\n     * @return {Function}\n     */\n    function queryCancelAnimationFrame() {\n        var cancellationNames = [];\n        if (Array.prototype.map) {\n            vendors.map(function(vendor) {\n                return ['Cancel', 'CancelRequest'].map(\n                    function(cancellationNamePrefix) {\n                        cancellationNames.push(vendor +\n                            cancellationNamePrefix + aF);\n                    });\n            });\n        } else {\n            return clearTimeoutWithId;\n        }\n\n        /**\n         * Checks for the prefixed cancelAnimationFrame implementation.\n         * @param  {Array} prefixedNames - An array of the prefixed names. \n         * @param  {Number} i - Iteration start point.\n         * @return {Function} prefixed cancelAnimationFrame function.\n         */\n        function prefixedCancelAnimationFrame(prefixedNames, i) {\n            var cancellationFunction;\n            for (; i < prefixedNames.length; i++) {\n                if (window[prefixedNames[i]]) {\n                    cancellationFunction = window[prefixedNames[i]];\n                    break;\n                }\n            }\n            return cancellationFunction;\n        }\n\n        // Use truthly function\n        assignedCancelAnimationFrame = window['cancel' + aF] ||\n            prefixedCancelAnimationFrame(cancellationNames, 0) ||\n            clearTimeoutWithId;\n\n        // Check for iOS 6 bug\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedCancelAnimationFrame;\n        } else {\n            return clearTimeoutWithId;\n        }\n    }\n\n    function getRequestFn() {\n        if (hasMozMismatch) {\n            return setTimeoutWithTimestamp;\n        } else {\n            return queryRequestAnimationFrame();\n        }\n    }\n\n    function getCancelFn() {\n        return queryCancelAnimationFrame();\n    }\n\n    function setNativeFn() {\n        if (hasMozMismatch) {\n            window.requestAnimationFrame = setTimeoutWithTimestamp;\n            window.cancelAnimationFrame = clearTimeoutWithId;\n        } else {\n            window.requestAnimationFrame = queryRequestAnimationFrame();\n            window.cancelAnimationFrame = queryCancelAnimationFrame();\n        }\n    }\n\n    /**\n     * The type value \"request\" singles out firefox 4 - 10 and \n     * assigns the setTimeout function if plausible.\n     */\n\n    switch (type) {\n        case 'request':\n        case '':\n            func = getRequestFn();\n            break;\n\n        case 'cancel':\n            func = getCancelFn();\n            break;\n\n        case 'native':\n            setNativeFn();\n            break;\n        default:\n            throw new Error('RequestFrame parameter is not a type.');\n    }\n    return func;\n}\n\n\n// Node.js/ CommonJS\nif (typeof module === 'object' && typeof module.exports === 'object') {\nmodule.exports = exports = requestFrame;\n}\n\n// AMD\nelse if (typeof define === 'function' && define.amd) {\ndefine(function() {\n  return requestFrame;\n});\n}\n\n// Default to window as global\nelse if (typeof window === 'object') {\nwindow.requestFrame = requestFrame;\n}\n/* global -module, -exports, -define */\n\n}((typeof window === \"undefined\" ? {} : window)));\n","var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n","'use strict';\n\nvar StateStack = require('./statestack');\nvar GameLoop = require('../timer/gameloop');\nvar NOOP = function() {};\n\nexports = module.exports = Game;\n\nfunction Game () {\n  this.states = {};\n  this.statestack = new StateStack();\n  this.gameloop = new GameLoop();\n\n  var self = this;\n\n  this.gameloop.setBegin(\n    function(timestamp, frameDelta) {\n      self.begin(timestamp, frameDelta);\n      self.statestack.begin(timestamp, frameDelta);\n    }\n  );\n\n  this.gameloop.setUpdate(\n    function(simulationTimestep) {\n      self.update(simulationTimestep);\n      self.statestack.update(simulationTimestep);\n    }\n  );\n\n  this.gameloop.setRender(\n    function(percentageTimestepRemaining) {\n      // render -> game is last.\n      self.statestack.render(percentageTimestepRemaining);\n      self.render(percentageTimestepRemaining);\n    }\n  );\n\n  this.gameloop.setEnd(\n    function(fps, panic) {\n      self.end(fps. panic);\n      self.statestack.end(fps, panic);\n    }\n  );\n\n}\n\n/* GAMELOOP HANDLING */\n\nGame.prototype.start = function() {\n  return this.gameloop.start();\n};\n\nGame.prototype.stop = function() {\n  return this.gameloop.stop();\n};\n\nGame.prototype.begin = NOOP;\nGame.prototype.end = NOOP;\nGame.prototype.update = NOOP;\nGame.prototype.render = NOOP;\n\n\n\n/* STATE HANDLING */\n\nGame.prototype.addState = function(state) {\n  state.game = this;\n  this.states[state.name] = state;\n  state.create();\n  return this;\n};\n\nGame.prototype.startState = function (stateName) {\n  var state = this.states[stateName];\n  if (!state) {\n    return;\n  }\n  return this.statestack.push(this.states[stateName]);\n};\n\nGame.prototype.stopState = function (stateName) {\n  var state = this.states[stateName];\n  if (!state) {\n    return;\n  }\n  return this.statestack.pop(state);\n};\n","module.exports = {\n  Game: require('./game'),\n  State: require('./state'),\n  StateList: require('./statelist'),\n  StateStack: require('./statestack')\n};\n","'use strict';\n\nexports = module.exports = State;\n\nvar NOOP = function() {};\n\nfunction State ( name ) {\n    this.name = name;\n}\n\nState.prototype.create = NOOP;\nState.prototype.begin = NOOP;\nState.prototype.update = NOOP;\nState.prototype.render = NOOP;\nState.prototype.end = NOOP;\nState.prototype.onEnter = NOOP;\nState.prototype.onExit = NOOP;\n","'use strict';\n\nexports = module.exports = StateList;\n\nfunction StateList() {\n    this.states = [];\n}\n\nStateList.prototype.pop = function () {\n    return this.states.pop();\n};\n\nStateList.prototype.push = function ( state ) {\n    return this.states.push(state);\n};\n\nStateList.prototype.top = function (depth) {\n    depth = depth || 0;\n    return this.states[this.states.length-(depth+1)];\n};\n","'use strict';\n\nvar StateList = require('./statelist');\n\nexports = module.exports = StateStack;\n\nfunction StateStack() {\n    this.states = new StateList();\n}\n\nStateStack.prototype.begin = function (timestamp, frameDelta) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.begin(timestamp, frameDelta) ) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.update = function (simulationTimestep) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.update(simulationTimestep)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.render = function (percentageTimestepRemaining) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.render(percentageTimestepRemaining)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.end = function (fps, panic) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.end(fps, panic)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.pop = function () {\n    var state = this.states.pop();\n    state.onExit();\n    return state;\n};\n\nStateStack.prototype.push = function (state) {\n    this.states.push(state);\n    return state.onEnter();\n};\n","'use strict';\n\nvar gpcas = gpcas || {};\ngpcas.util = {};\ngpcas.geometry = {};\n\nexports = module.exports = gpcas;\n\n//////////\nvar Clip, BundleState, LmtNode, TopPolygonNode, AetTree, HState, VertexType, VertexNode, ItNodeTable, StNode;\n\n//Object.prototype.equals = function(x) {\nfunction equals(x1, x) {\n\n    var p;\n    for(p in x1) {\n        if(typeof(x[p])==='undefined') {return false;}\n    }\n\n    for(p in x1) {\n        if (x1[p]) {\n            switch(typeof(x1[p])) {\n                case 'object':\n                    if (!equals(x1[p], x[p])) { return false; } break;\n                case 'function':\n                    if (typeof(x[p])==='undefined' ||\n                        (p !== 'equals' && x1[p].toString() !== x[p].toString()))\n                        return false;\n                    break;\n                default:\n                    if (x1[p] !== x[p]) { return false; }\n            }\n        } else {\n            if (x[p])\n                return false;\n        }\n    }\n\n    for(p in x) {\n        if(typeof(x1[p])==='undefined') {return false;}\n    }\n\n    return true;\n}\n///point\nvar Point = function(x,y) {\n    this.x = x;\n    this.y = y;\n};\ngpcas.geometry.Point = Point;\n\n////////////// CLASS ArrayHelper ////////////////////////////////////\ngpcas.util.ArrayHelper = function() {};\nvar gpcstatic = gpcas.util.ArrayHelper;\n\ngpcstatic.create2DArray = function(x,y){\n    var a = [];\n    for (var i=0; i<x; i++){\n        a[i]= [];\n    }\n    return a;\n};\ngpcstatic.valueEqual = function(obj1, obj2) {\n    if (obj1===obj2) return true;\n    if(equals(obj1, obj2)) return true;\n\n    return false;\n}\ngpcstatic.sortPointsClockwise = function(vertices) {\n    var isArrayList  = false;\n\n    if (vertices instanceof gpcas.util.ArrayList){\n        vertices= vertices.toArray();\n        isArrayList=true;\n    }\n\n    //point\n    var maxTop   = null;\n    var maxBottom  = null;\n    var maxLeft   = null;\n    var maxRight  = null;\n\n\n    var maxLeftIndex;\n    var newVertices = vertices;\n\n\n\n    for (var i  = 0; i<vertices.length; i++){\n        var vertex  = vertices[i] ;\n\n        if ((maxTop===null)||(maxTop.y>vertex.y)||((maxTop.y===vertex.y)&&(vertex.x<maxTop.x))){\n            maxTop=vertex;\n        }\n        if ((maxBottom===null)||(maxBottom.y<vertex.y)||((maxBottom.y===vertex.y)&&(vertex.x>maxBottom.x))){\n            maxBottom=vertex;\n        }\n        if ((maxLeft===null)||(maxLeft.x>vertex.x)||((maxLeft.x===vertex.x)&&(vertex.y>maxLeft.y))){\n            maxLeft=vertex;\n            maxLeftIndex=i;\n        }\n        if ((maxRight===null)||(maxRight.x<vertex.x)||((maxRight.x===vertex.x)&&(vertex.y<maxRight.y))){\n            maxRight=vertex;\n        }\n    }\n\n    if (maxLeftIndex>0){\n        newVertices = []\n        var j = 0;\n        for (var i=maxLeftIndex; i<vertices.length;i++){\n            newVertices[j++]=vertices[i];\n        }\n        for (var i=0; i<maxLeftIndex; i++){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n\n    var reverse  = false;\n    for(var i=0 ; i<vertices.length;i++) {\n        var vertex = vertices[i];\n        if (equals(vertex, maxBottom)){\n            reverse=true;\n            break;\n        } else if (equals(vertex, maxTop)){\n            break;\n        }\n    }\n    if (reverse){\n        newVertices=[]\n        newVertices[0]=vertices[0];\n        var j =1;\n        for (var i=vertices.length-1; i>0; i--){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n    return (isArrayList?(new gpcas.util.ArrayList(vertices)):(vertices));\n}\n\n/////////////// END ArrayHelper  ////////////////////////////////////////////////\n\nvar ArrayHelper = gpcas.util.ArrayHelper;\n////////////////// CLASS ArrayList  /////////////////////////\n\ngpcas.util.ArrayList = function(arr) {\n\tthis._array = [];\n\tif(arr != null) {\n\t\tthis._array=arr;\n\t}\n\n};\nvar p = gpcas.util.ArrayList.prototype;\n\np.add = function(value) {\n    this._array.push(value);\n};\np.get = function(index) {\n    return this._array[index];\n};\np.size = function() {\n\treturn this._array.length;\n};\np.clear = function() {\n    this._array  = [];\n\n};\np.equals = function(list) {\n    if (this._array.length != list.size()) return false;\n\n    for (var i = 0; i<this._array.length ; i++){\n        var obj1  = this._array[i];\n        var obj2  = list.get(i);\n\n        if (!ArrayHelper.valueEqual(obj1,obj2)){\n            return false;\n        }\n    }\n    return true;\n}\np.hashCode = function(){\n    return 0;\n};\np.isEmpty = function() {\n    return (this._array.length == 0);\n}\np.toArray = function(){\n    return this._array;\n}\n///////////////// END ArrayList ////////////////////////\n\n\n\n\n\n\ngpcas.geometry.Clip = function(){};\ngpcas.geometry.Clip.DEBUG = false;\ngpcas.geometry.Clip.GPC_EPSILON = 2.2204460492503131e-016;\ngpcas.geometry.Clip.GPC_VERSION = \"2.31\";\ngpcas.geometry.Clip.LEFT = 0;\ngpcas.geometry.Clip.RIGHT = 1;\ngpcas.geometry.Clip.ABOVE = 0;\ngpcas.geometry.Clip.BELOW = 1;\ngpcas.geometry.Clip.CLIP = 0;\ngpcas.geometry.Clip.SUBJ = 1;\nClip = gpcas.geometry.Clip;\n\n\n\nvar p = gpcas.geometry.Clip.prototype;\nvar gpcstatic = gpcas.geometry.Clip;\n\n// ----------------------\n// --- gpcstatic Methods ---\n// ----------------------\n\n/**\n * Return the intersection of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he intersection with\n * @param p2        One of the polygons to performt he intersection with\n * @param polyClass The type of <code>Poly</code> to return\n */\n\ngpcstatic.intersection = function(p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_INT, p1, p2, polyClass );\n};\n\n\n\n/**\n * Return the union of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he union with\n * @param p2        One of the polygons to performt he union with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.union = function(p1, p2, polyClass) {\n\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n\n\treturn gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_UNION, p1, p2, polyClass );\n};\n\n\n/**\n * Return the xor of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he xor with\n * @param p2        One of the polygons to performt he xor with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.xor = function( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_XOR, p1, p2, polyClass );\n};\n\n\n/**\n * Return the difference of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        Polygon from which second polygon will be substracted\n * @param p2        Second polygon\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.difference = function ( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_DIFF, p2, p1, polyClass );\n}\ngpcstatic.intersection = function( p1, p2) {\n\treturn gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, \"PolyDefault.class\" );\n}\n\n\n// -----------------------\n// --- Private Methods ---\n// -----------------------\n\n/**\n * Create a new <code>Poly</code> type object using <code>polyClass</code>.\n */\ngpcstatic.createNewPoly = function ( polyClass) {\n    /* TODO :\n     try\n     {\n     return (Poly)polyClass.newInstance();\n     }\n     catch( var e:Exception)\n     {\n     throw new RuntimeException(e);\n     }*/\n    if (polyClass==\"PolySimple\"){\n        return new gpcas.geometry.PolySimple();\n    }\n    if (polyClass==\"PolyDefault\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\tif (polyClass==\"PolyDefault.class\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\n    return null;\n}\n\n/**\n * <code>clip()</code> is the main method of the clipper algorithm.\n * This is where the conversion from really begins.\n */\ngpcstatic.clip = function ( op, subj, clip, polyClass) {\n    var result = gpcas.geometry.Clip.createNewPoly( polyClass ) ;\n\n    /* Test for trivial NULL result cases */\n    if( (subj.isEmpty() && clip.isEmpty()) ||\n        (subj.isEmpty() && ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF))) ||\n        (clip.isEmpty() &&  (op == gpcas.geometry.OperationType.GPC_INT)) )\n    {\n        return result ;\n    }\n\n\n\n    /* Identify potentialy contributing contours */\n    if( ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF)) &&\n        !subj.isEmpty() && !clip.isEmpty() )\n    {\n        gpcas.geometry.Clip.minimax_test(subj, clip, op);\n    }\n\n\t//console.log(\"SUBJ \" + subj);\n    //console.log(\"CLIP \" + clip);\n\n\n\n    /* Build LMT */\n    var lmt_table = new gpcas.geometry.LmtTable();\n    var sbte = new gpcas.geometry.ScanBeamTreeEntries();\n    var s_heap= null ;\n    var c_heap= null ;\n\n\n\n    if (!subj.isEmpty())\n    {\n        s_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, subj, gpcas.geometry.Clip.SUBJ, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for subj ---------\");\n        lmt_table.print();\n    }\n    if (!clip.isEmpty())\n    {\n        c_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, clip, gpcas.geometry.Clip.CLIP, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for clip ---------\");\n        lmt_table.print();\n    }\n\n    /* Return a NULL result if no contours contribute */\n    if (lmt_table.top_node == null)\n    {\n        return result;\n    }\n\n    /* Build scanbeam table from scanbeam tree */\n    var sbt = sbte.build_sbt();\n\n\n\n    var parity= [];\n    parity[0] = gpcas.geometry.Clip.LEFT ;\n    parity[1] = gpcas.geometry.Clip.LEFT ;\n\n    /* Invert clip polygon for difference operation */\n    if (op == gpcas.geometry.OperationType.GPC_DIFF)\n    {\n        parity[Clip.CLIP]= gpcas.geometry.Clip.RIGHT;\n    }\n\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(sbt);\n    }\n\n    var local_min = lmt_table.top_node ;\n\n    var out_poly = new TopPolygonNode(); // used to create resulting Poly\n\n    var aet = new AetTree();\n    var scanbeam = 0;\n\n\n\n    /* Process each scanbeam */\n    while( scanbeam < sbt.length )\n    {\n        /* Set yb and yt to the bottom and top of the scanbeam */\n        var yb = sbt[scanbeam++];\n        var yt = 0.0;\n        var dy = 0.0;\n        if( scanbeam < sbt.length )\n        {\n            yt = sbt[scanbeam];\n            dy = yt - yb;\n        }\n\n\n\n        /* === SCANBEAM BOUNDARY PROCESSING ================================ */\n\n        /* If LMT node corresponding to yb exists */\n        if (local_min != null )\n        {\n            if (local_min.y == yb)\n            {\n                /* Add edges starting at this local minimum to the AET */\n                for( var edge= local_min.first_bound; (edge != null) ; edge= edge.next_bound)\n                {\n                    gpcas.geometry.Clip.add_edge_to_aet( aet, edge );\n                }\n\n                local_min = local_min.next;\n            }\n        }\n\n        if( gpcas.geometry.Clip.DEBUG )\n        {\n            aet.print();\n        }\n        /* Set dummy previous x value */\n        var px = -Number.MAX_VALUE;\n\n        /* Create bundles within AET */\n        var e0 = aet.top_node ;\n        var e1 = aet.top_node ;\n\n\n\n        /* Set up bundle fields of first edge */\n        aet.top_node.bundle[Clip.ABOVE][ aet.top_node.type ] = (aet.top_node.top.y != yb) ? 1: 0;\n        aet.top_node.bundle[Clip.ABOVE][ ((aet.top_node.type==0) ? 1: 0) ] = 0;\n        aet.top_node.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n        for (var next_edge= aet.top_node.next ; (next_edge != null); next_edge = next_edge.next)\n        {\n            var ne_type= next_edge.type ;\n            var ne_type_opp= ((next_edge.type==0) ? 1: 0); //next edge type opposite\n\n            /* Set up bundle fields of next edge */\n            next_edge.bundle[Clip.ABOVE][ ne_type     ]= (next_edge.top.y != yb) ? 1: 0;\n            next_edge.bundle[Clip.ABOVE][ ne_type_opp ] = 0;\n            next_edge.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n            /* Bundle edges above the scanbeam boundary if they coincide */\n            if ( next_edge.bundle[Clip.ABOVE][ne_type] == 1)\n            {\n                if (Clip.EQ(e0.xb, next_edge.xb) && gpcas.geometry.Clip.EQ(e0.dx, next_edge.dx) && (e0.top.y != yb))\n                {\n                    next_edge.bundle[Clip.ABOVE][ ne_type     ] ^= e0.bundle[Clip.ABOVE][ ne_type     ];\n                    next_edge.bundle[Clip.ABOVE][ ne_type_opp ]  = e0.bundle[Clip.ABOVE][ ne_type_opp ];\n                    next_edge.bstate[Clip.ABOVE] = BundleState.BUNDLE_HEAD;\n                    e0.bundle[Clip.ABOVE][Clip.CLIP] = 0;\n                    e0.bundle[Clip.ABOVE][Clip.SUBJ] = 0;\n                    e0.bstate[Clip.ABOVE] = BundleState.BUNDLE_TAIL;\n                }\n                e0 = next_edge;\n\n            }\n        }\n\n        var horiz= [] ;\n        horiz[Clip.CLIP]= HState.NH;\n        horiz[Clip.SUBJ]= HState.NH;\n\n        var exists= [] ;\n        exists[Clip.CLIP] = 0;\n        exists[Clip.SUBJ] = 0;\n\n        var cf= null ;\n\n        /* Process each edge at this scanbeam boundary */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next )\n        {\n            exists[Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP] + (edge.bundle[Clip.BELOW][Clip.CLIP] << 1);\n            exists[Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ] + (edge.bundle[Clip.BELOW][Clip.SUBJ] << 1);\n\n            if( (exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0) )\n            {\n                /* Set bundle side */\n                edge.bside[Clip.CLIP] = parity[Clip.CLIP];\n                edge.bside[Clip.SUBJ] = parity[Clip.SUBJ];\n\n                var contributing= false ;\n                var br=0;\n                var bl=0;\n                var tr=0;\n                var tl=0;\n                /* Determine contributing status and quadrant occupancies */\n                if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && ((parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && ((parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP]!=0) && (parity[Clip.SUBJ]!=0)) ? 1: 0;\n                    bl = ( ((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1: 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) !=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0)) !=0) ) ? 1: 0;\n                    tl = (((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0))?1:0;\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                {\n                    contributing= (exists[Clip.CLIP]!=0) || (exists[Clip.SUBJ]!=0);\n                    br= (parity[Clip.CLIP]) ^ (parity[Clip.SUBJ]);\n                    bl= (parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) ^ (parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    tr= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0));\n                    tl= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])\n                        ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]);\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && (!(parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && (!(parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br= ((parity[Clip.CLIP]!=0) || (parity[Clip.SUBJ]!=0))?1:0;\n                    bl= (((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                    tr= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0))!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0))!=0) ) ?1:0;\n                    tl= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0) ) ? 1:0;\n                }\n                else\n                {\n                    //console.log(\"ERROR : Unknown op\");\n                }\n\n                /* Update parity */\n                parity[Clip.CLIP] ^= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                parity[Clip.SUBJ] ^= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n\n                /* Update horizontal state */\n                if (exists[Clip.CLIP]!=0)\n                {\n                    horiz[Clip.CLIP] = HState.next_h_state[horiz[Clip.CLIP]][((exists[Clip.CLIP] - 1) << 1) + parity[Clip.CLIP]];\n                }\n                if( exists[Clip.SUBJ]!=0)\n                {\n                    horiz[Clip.SUBJ] = HState.next_h_state[horiz[Clip.SUBJ]][((exists[Clip.SUBJ] - 1) << 1) + parity[Clip.SUBJ]];\n                }\n\n                if (contributing)\n                {\n                    var xb= edge.xb;\n\n\n\n                    var vclass= VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                        case VertexType.IMN:\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.ELI:\n                            edge.outp[Clip.BELOW].add_left( xb, yb);\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            break;\n                        case VertexType.EMX:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            break;\n                        case VertexType.ILI:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.IRI:\n                            edge.outp[Clip.BELOW].add_right( xb, yb );\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMX:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb );\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMM:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.EMM:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.LED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_left( xb, yb);\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        case VertexType.RED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_right( xb, yb );\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing conditional */\n            } /* End of edge exists conditional */\n            if( gpcas.geometry.Clip.DEBUG )\n            {\n                out_poly.print();\n            }\n\t\t\tout_poly.print();\n        } /* End of AET loop */\n\n\n\n        /* Delete terminating edges from the AET, otherwise compute xt */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n        {\n            if (edge.top.y == yb)\n            {\n                var prev_edge= edge.prev;\n                var next_edge= edge.next;\n\n                if (prev_edge != null)\n                    prev_edge.next = next_edge;\n                else\n                    aet.top_node = next_edge;\n\n                if (next_edge != null )\n                    next_edge.prev = prev_edge;\n\n                /* Copy bundle head state to the adjacent tail edge if required */\n                if ((edge.bstate[Clip.BELOW] == BundleState.BUNDLE_HEAD) && (prev_edge!=null))\n                {\n                    if (prev_edge.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                    {\n                        prev_edge.outp[Clip.BELOW]= edge.outp[Clip.BELOW];\n                        prev_edge.bstate[Clip.BELOW]= BundleState.UNBUNDLED;\n                        if ( prev_edge.prev != null)\n                        {\n                            if (prev_edge.prev.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                            {\n                                prev_edge.bstate[Clip.BELOW] = BundleState.BUNDLE_HEAD;\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if (edge.top.y == yt)\n                    edge.xt= edge.top.x;\n                else\n                    edge.xt= edge.bot.x + edge.dx * (yt - edge.bot.y);\n            }\n        }\n\n        if (scanbeam < sbte.sbt_entries )\n        {\n            /* === SCANBEAM INTERIOR PROCESSING ============================== */\n\n            /* Build intersection table for the current scanbeam */\n            var it_table= new ItNodeTable();\n            it_table.build_intersection_table(aet, dy);\n\n\n\n            /* Process each node in the intersection table */\n\n            for (var intersect= it_table.top_node ; (intersect != null); intersect = intersect.next)\n            {\n\n\n\t\t\t\te0= intersect.ie[0];\n\t\t\t\te1= intersect.ie[1];\n\n                /* Only generate output for contributing intersections */\n\n                if ( ((e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)) &&\n                    ((e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)))\n                {\n                    var p= e0.outp[Clip.ABOVE];\n                    var q= e1.outp[Clip.ABOVE];\n                    var ix= intersect.point.x;\n                    var iy= intersect.point.y + yb;\n\n                    var in_clip= ( ( (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e0.bside[Clip.CLIP]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&  (e1.bside[Clip.CLIP]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&\n                        (e0.bside[Clip.CLIP]!=0) && (e1.bside[Clip.CLIP]!=0) ) ) ? 1: 0;\n\n                    var in_subj= ( ( (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e0.bside[Clip.SUBJ]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&  (e1.bside[Clip.SUBJ]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&\n                        (e0.bside[Clip.SUBJ]!=0) && (e1.bside[Clip.SUBJ]!=0) ) ) ? 1: 0;\n\n                    var tr=0\n                    var tl=0;\n                    var br=0;\n                    var bl=0;\n                    /* Determine quadrant occupancies */\n                    if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                    {\n                        tr= ((in_clip!=0) && (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1:0;\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                    {\n                        tr= in_clip^ in_subj;\n                        tl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        br= (in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        bl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])\n                            ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                    {\n                        tr= ((in_clip!=0) || (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) ||\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                    }\n                    else\n                    {\n                        //console.log(\"ERROR : Unknown op type, \"+op);\n                    }\n\n                    var vclass = VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (p != null)\n                            {\n                                p.add_right(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.ELI:\n                            if (q != null)\n                            {\n                                q.add_left(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.EMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left( ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ILI:\n                            if (p != null)\n                            {\n                                p.add_left(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IRI:\n                            if (q!=null)\n                            {\n                                q.add_right(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        case VertexType.EMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing intersection conditional */\n\n                /* Swap bundle sides in response to edge crossing */\n                if (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e1.bside[Clip.CLIP] = (e1.bside[Clip.CLIP]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e0.bside[Clip.CLIP]= (e0.bside[Clip.CLIP]==0)?1:0;\n                if (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e1.bside[Clip.SUBJ]= (e1.bside[Clip.SUBJ]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e0.bside[Clip.SUBJ]= (e0.bside[Clip.SUBJ]==0)?1:0;\n\n                /* Swap e0 and e1 bundles in the AET */\n                var prev_edge= e0.prev;\n                var next_edge= e1.next;\n                if (next_edge != null)\n                {\n                    next_edge.prev = e0;\n                }\n\n                if (e0.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD)\n                {\n                    var search= true;\n                    while (search)\n                    {\n                        prev_edge= prev_edge.prev;\n                        if (prev_edge != null)\n                        {\n                            if (prev_edge.bstate[Clip.ABOVE] != BundleState.BUNDLE_TAIL)\n                            {\n                                search= false;\n                            }\n                        }\n                        else\n                        {\n                            search= false;\n                        }\n                    }\n                }\n                if (prev_edge == null)\n                {\n                    aet.top_node.prev = e1;\n                    e1.next           = aet.top_node;\n                    aet.top_node      = e0.next;\n                }\n                else\n                {\n                    prev_edge.next.prev = e1;\n                    e1.next             = prev_edge.next;\n                    prev_edge.next      = e0.next;\n                }\n                e0.next.prev = prev_edge;\n                e1.next.prev = e1;\n                e0.next      = next_edge;\n                if( gpcas.geometry.Clip.DEBUG )\n                {\n                    out_poly.print();\n                }\n            } /* End of IT loop*/\n\n            /* Prepare for next scanbeam */\n            for ( var edge= aet.top_node; (edge != null); edge = edge.next)\n            {\n                var next_edge= edge.next;\n                var succ_edge= edge.succ;\n                if ((edge.top.y == yt) && (succ_edge!=null))\n                {\n                    /* Replace AET edge by its successor */\n                    succ_edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    succ_edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    succ_edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    succ_edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    var prev_edge= edge.prev;\n                    if ( prev_edge != null )\n                        prev_edge.next = succ_edge;\n                    else\n                        aet.top_node = succ_edge;\n                    if (next_edge != null)\n                        next_edge.prev= succ_edge;\n                    succ_edge.prev = prev_edge;\n                    succ_edge.next = next_edge;\n                }\n                else\n                {\n                    /* Update this edge */\n                    edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    edge.xb= edge.xt;\n                }\n                edge.outp[Clip.ABOVE]= null;\n            }\n        }\n    } /* === END OF SCANBEAM PROCESSING ================================== */\n\n    /* Generate result polygon from out_poly */\n    result = out_poly.getResult(polyClass);\n\t//console.log(\"result = \"+result);\n\n    return result ;\n}\n\ngpcstatic.EQ = function(a, b) {\n    return (Math.abs(a - b) <= gpcas.geometry.Clip.GPC_EPSILON);\n}\n\ngpcstatic.PREV_INDEX = function( i, n) {\n    return ((i - 1+ n) % n);\n}\n\ngpcstatic.NEXT_INDEX = function(i, n) {\n    return ((i + 1) % n);\n}\n\ngpcstatic.OPTIMAL = function ( p, i) {\n    return (p.getY(gpcas.geometry.Clip.PREV_INDEX (i, p.getNumPoints())) != p.getY(i)) ||\n        (p.getY(gpcas.geometry.Clip.NEXT_INDEX(i, p.getNumPoints())) != p.getY(i)) ;\n}\n\ngpcstatic.create_contour_bboxes = function (p)\n{\n    var box= [] ;\n\n    /* Construct contour bounding boxes */\n    for ( var c= 0; c < p.getNumInnerPoly(); c++)\n    {\n        var inner_poly= p.getInnerPoly(c);\n        box[c] = inner_poly.getBounds();\n    }\n    return box;\n}\n\ngpcstatic.minimax_test = function ( subj, clip, op){\n    var s_bbox= gpcas.geometry.Clip.create_contour_bboxes(subj);\n\tvar c_bbox= gpcas.geometry.Clip.create_contour_bboxes(clip);\n\n\tvar subj_num_poly= subj.getNumInnerPoly();\n\tvar clip_num_poly= clip.getNumInnerPoly();\n\tvar o_table = ArrayHelper.create2DArray(subj_num_poly,clip_num_poly);\n\n\t/* Check all subject contour bounding boxes against clip boxes */\n\tfor( var s= 0; s < subj_num_poly; s++ )\n\t{\n\t    for( var c= 0; c < clip_num_poly ; c++ )\n\t    {\n\t        o_table[s][c] =\n\t            (!((s_bbox[s].getMaxX() < c_bbox[c].getMinX()) ||\n\t                (s_bbox[s].getMinX() > c_bbox[c].getMaxX()))) &&\n\t                (!((s_bbox[s].getMaxY() < c_bbox[c].getMinY()) ||\n\t                    (s_bbox[s].getMinY() > c_bbox[c].getMaxY())));\n\t    }\n\t}\n\n\t/* For each clip contour, search for any subject contour overlaps */\n\tfor( var c= 0; c < clip_num_poly; c++ )\n\t{\n\t    var overlap= false;\n\t    for( var s= 0; !overlap && (s < subj_num_poly) ; s++)\n\t    {\n\t        overlap = o_table[s][c];\n\t    }\n\t    if (!overlap)\n\t    {\n\t        clip.setContributing( c, false ); // Flag non contributing status\n\t    }\n\t}\n\n\tif (op == gpcas.geometry.OperationType.GPC_INT)\n\t{\n\t    /* For each subject contour, search for any clip contour overlaps */\n\t    for ( var s= 0; s < subj_num_poly; s++)\n\t    {\n\t        var overlap= false;\n\t        for ( var c= 0; !overlap && (c < clip_num_poly); c++)\n\t        {\n\t            overlap = o_table[s][c];\n\t        }\n\t        if (!overlap)\n\t        {\n\t            subj.setContributing( s, false ); // Flag non contributing status\n\t        }\n\t    }\n\t}\n}\n\ngpcstatic.bound_list = function( lmt_table, y) {\n    if( lmt_table.top_node == null )\n    {\n        lmt_table.top_node = new LmtNode(y);\n        return lmt_table.top_node ;\n    }\n    else\n    {\n        var prev= null ;\n        var node= lmt_table.top_node ;\n        var done= false ;\n        while( !done )\n        {\n            if( y < node.y )\n            {\n                /* Insert a new LMT node before the current node */\n                var existing_node= node ;\n                node = new LmtNode(y);\n                node.next = existing_node ;\n                if( prev == null )\n                {\n                    lmt_table.top_node = node ;\n                }\n                else\n                {\n                    prev.next = node ;\n                }\n                //               if( existing_node == lmt_table.top_node )\n                //               {\n                //                  lmt_table.top_node = node ;\n                //               }\n                done = true ;\n            }\n            else if ( y > node.y )\n            {\n                /* Head further up the LMT */\n                if( node.next == null )\n                {\n                    node.next = new LmtNode(y);\n                    node = node.next ;\n                    done = true ;\n                }\n                else\n                {\n                    prev = node ;\n                    node = node.next ;\n                }\n            }\n            else\n            {\n                /* Use this existing LMT node */\n                done = true ;\n            }\n        }\n        return node ;\n    }\n}\n\ngpcstatic.insert_bound = function ( lmt_node, e) {\n    if( lmt_node.first_bound == null )\n{\n    /* Link node e to the tail of the list */\n    lmt_node.first_bound = e ;\n}\nelse\n{\n    var done= false ;\n    var prev_bound= null ;\n    var current_bound= lmt_node.first_bound ;\n    while( !done )\n    {\n        /* Do primary sort on the x field */\n        if (e.bot.x <  current_bound.bot.x)\n        {\n            /* Insert a new node mid-list */\n            if( prev_bound == null )\n            {\n                lmt_node.first_bound = e ;\n            }\n            else\n            {\n                prev_bound.next_bound = e ;\n            }\n            e.next_bound = current_bound ;\n\n            //               EdgeNode existing_bound = current_bound ;\n            //               current_bound = e ;\n            //               current_bound.next_bound = existing_bound ;\n            //               if( lmt_node.first_bound == existing_bound )\n            //               {\n            //                  lmt_node.first_bound = current_bound ;\n            //               }\n            done = true ;\n        }\n        else if (e.bot.x == current_bound.bot.x)\n        {\n            /* Do secondary sort on the dx field */\n            if (e.dx < current_bound.dx)\n            {\n                /* Insert a new node mid-list */\n                if( prev_bound == null )\n                {\n                    lmt_node.first_bound = e ;\n                }\n                else\n                {\n                    prev_bound.next_bound = e ;\n                }\n                e.next_bound = current_bound ;\n                //                  EdgeNode existing_bound = current_bound ;\n                //                  current_bound = e ;\n                //                  current_bound.next_bound = existing_bound ;\n                //                  if( lmt_node.first_bound == existing_bound )\n                //                  {\n                //                     lmt_node.first_bound = current_bound ;\n                //                  }\n                done = true ;\n            }\n            else\n            {\n                /* Head further down the list */\n                if( current_bound.next_bound == null )\n                {\n                    current_bound.next_bound = e ;\n                    done = true ;\n                }\n                else\n                {\n                    prev_bound = current_bound ;\n                    current_bound = current_bound.next_bound ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further down the list */\n            if( current_bound.next_bound == null )\n            {\n                current_bound.next_bound = e ;\n                done = true ;\n            }\n            else\n            {\n                prev_bound = current_bound ;\n                current_bound = current_bound.next_bound ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_edge_to_aet = function ( aet, edge) {\n    if ( aet.top_node == null )\n{\n    /* Append edge onto the tail end of the AET */\n    aet.top_node = edge;\n    edge.prev = null ;\n    edge.next= null;\n}\nelse\n{\n    var current_edge= aet.top_node ;\n    var prev= null ;\n    var done= false ;\n    while( !done )\n    {\n        /* Do primary sort on the xb field */\n        if (edge.xb < current_edge.xb)\n        {\n            /* Insert edge here (before the AET edge) */\n            edge.prev= prev;\n            edge.next= current_edge ;\n            current_edge.prev = edge ;\n            if( prev == null )\n            {\n                aet.top_node = edge ;\n            }\n            else\n            {\n                prev.next = edge ;\n            }\n            //               if( current_edge == aet.top_node )\n            //               {\n            //                  aet.top_node = edge ;\n            //               }\n            //               current_edge = edge ;\n            done = true;\n        }\n        else if (edge.xb == current_edge.xb)\n        {\n            /* Do secondary sort on the dx field */\n            if (edge.dx < current_edge.dx)\n            {\n                /* Insert edge here (before the AET edge) */\n                edge.prev= prev;\n                edge.next= current_edge ;\n                current_edge.prev = edge ;\n                if( prev == null )\n                {\n                    aet.top_node = edge ;\n                }\n                else\n                {\n                    prev.next = edge ;\n                }\n                //                  if( current_edge == aet.top_node )\n                //                  {\n                //                     aet.top_node = edge ;\n                //                  }\n                //                  current_edge = edge ;\n                done = true;\n            }\n            else\n            {\n                /* Head further into the AET */\n                prev = current_edge ;\n                if( current_edge.next == null )\n                {\n                    current_edge.next = edge ;\n                    edge.prev = current_edge ;\n                    edge.next = null ;\n                    done = true ;\n                }\n                else\n                {\n                    current_edge = current_edge.next ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further into the AET */\n            prev = current_edge ;\n            if( current_edge.next == null )\n            {\n                current_edge.next = edge ;\n                edge.prev = current_edge ;\n                edge.next = null ;\n                done = true ;\n            }\n            else\n            {\n                current_edge = current_edge.next ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_to_sbtree = function ( sbte, y) {\n    if( sbte.sb_tree == null )\n\t\t{\n\t\t    /* Add a new tree node here */\n\t\t    sbte.sb_tree = new gpcas.geometry.ScanBeamTree( y );\n\t\t    sbte.sbt_entries++ ;\n\t\t    return ;\n\t\t}\n\tvar tree_node= sbte.sb_tree ;\n\tvar done= false ;\n\twhile( !done )\n\t{\n\t    if ( tree_node.y > y)\n\t    {\n\t        if( tree_node.less == null )\n\t        {\n\t            tree_node.less = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.less ;\n\t        }\n\t    }\n\t    else if ( tree_node.y < y)\n\t    {\n\t        if( tree_node.more == null )\n\t        {\n\t            tree_node.more = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.more ;\n\t        }\n\t    }\n\t    else\n\t    {\n\t        done = true ;\n\t    }\n\t}\n}\n\n\ngpcstatic.build_lmt = function( lmt_table,\n\t\t\t\t\t\t\tsbte,\n\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\ttype, //poly type SUBJ/Clip.CLIP\n\t\t\t\t\t\t\top) {\n\t\t\t/* Create the entire input polygon edge table in one go */\n\t\t\tvar edge_table= new gpcas.geometry.EdgeTable();\n\n\t\t\tfor ( var c= 0; c < p.getNumInnerPoly(); c++)\n\t\t\t{\n\t\t\t\tvar ip= p.getInnerPoly(c);\n\t\t\t\tif( !ip.isContributing(0) )\n\t\t\t\t{\n\t\t\t\t\t/* Ignore the non-contributing contour */\n\t\t\t\t\tip.setContributing(0, true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\n\t\t\t\t\t/* Perform contour optimisation */\n\t\t\t\t\tvar num_vertices= 0;\n\t\t\t\t\tvar e_index= 0;\n\t\t\t\t\tedge_table = new gpcas.geometry.EdgeTable();\n\t\t\t\t\tfor ( var i= 0; i < ip.getNumPoints(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( gpcas.geometry.Clip.OPTIMAL(ip, i) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x= ip.getX(i);\n\t\t\t\t\t\t\tvar y= ip.getY(i);\n\t\t\t\t\t\t\tedge_table.addNode( x, y );\n\n\t\t\t\t\t\t\t/* Record vertex in the scanbeam table */\n                            gpcas.geometry.Clip.add_to_sbtree( sbte, ip.getY(i) );\n\n\t\t\t\t\t\t\tnum_vertices++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour forward pass */\n\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a forward local minimum... */\n\t\t\t\t\t\tif( edge_table.FWD_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the next local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.NEXT_INDEX( min, num_vertices );\n\t\t\t\t\t\t\twhile( edge_table.NOT_FMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.NEXT_INDEX( max, num_vertices );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the next edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = gpcas.geometry.BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor ( var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv = gpcas.geometry.Clip.NEXT_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x= ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y= ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx= (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null ;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"fwd\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index += num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour reverse pass */\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a reverse local minimum... */\n\t\t\t\t\t\tif ( edge_table.REV_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the previous local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.PREV_INDEX(min, num_vertices);\n\t\t\t\t\t\t\twhile( edge_table.NOT_RMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.PREV_INDEX(max, num_vertices);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the previous edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor (var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv= gpcas.geometry.Clip.PREV_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y = ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null ;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"rev\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index+= num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn edge_table;\n\t\t}\n\n\ngpcstatic.add_st_edge = function( st, it, edge, dy) {\n    if (st == null)\n    {\n        /* Append edge onto the tail end of the ST */\n        st = new gpcas.geometry.StNode( edge, null );\n    }\n    else\n    {\n        var den= (st.xt - st.xb) - (edge.xt - edge.xb);\n\n        /* If new edge and ST edge don't cross */\n        if( (edge.xt >= st.xt) || (edge.dx == st.dx) || (Math.abs(den) <= gpcas.geometry.Clip.GPC_EPSILON))\n        {\n            /* No intersection - insert edge here (before the ST edge) */\n            var existing_node= st;\n            st = new StNode( edge, existing_node );\n        }\n        else\n        {\n            /* Compute intersection between new edge and ST edge */\n            var r= (edge.xb - st.xb) / den;\n            var x= st.xb + r * (st.xt - st.xb);\n            var y= r * dy;\n\n            /* Insert the edge pointers and the intersection point in the IT */\n            it.top_node = gpcas.geometry.Clip.add_intersection(it.top_node, st.edge, edge, x, y);\n\n            /* Head further into the ST */\n            st.prev = gpcas.geometry.Clip.add_st_edge(st.prev, it, edge, dy);\n        }\n    }\n    return st ;\n}\n\n\n\ngpcstatic.add_intersection = function ( it_node,\n    edge0,\n    edge1,\n    x,\n    y) {\n    if (it_node == null)\n    {\n        /* Append a new node to the tail of the list */\n        it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, null );\n    }\n    else\n    {\n        if ( it_node.point.y > y)\n        {\n            /* Insert a new node mid-list */\n            var existing_node= it_node ;\n            it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, existing_node );\n        }\n        else\n        {\n            /* Head further down the list */\n            it_node.next = gpcas.geometry.Clip.add_intersection( it_node.next, edge0, edge1, x, y);\n        }\n    }\n    return it_node ;\n}\n\n\n/////////// AetTree ////////////////////////////////////\ngpcas.geometry.AetTree = function(){\n    this.top_node = null; //EdgeNode\n};\nAetTree = gpcas.geometry.AetTree;\ngpcas.geometry.AetTree.prototype.print = function() {\n    //console.log(\"aet\");\n    for( var edge= this.top_node ; (edge != null) ; edge = edge.next ) {\n        //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n    }\n}\n\n\n///////////////  BundleState  //////////////////////////////\ngpcas.geometry.BundleState = function(state){\n    this.m_State = state ; //String\n};\ngpcas.geometry.BundleState.UNBUNDLED = new gpcas.geometry.BundleState(\"UNBUNDLED\");\ngpcas.geometry.BundleState.BUNDLE_HEAD = new gpcas.geometry.BundleState(\"BUNDLE_HEAD\");\ngpcas.geometry.BundleState.BUNDLE_TAIL = new gpcas.geometry.BundleState(\"BUNDLE_TAIL\");\ngpcas.geometry.BundleState.prototype.toString = function() {\n    return this.m_State;\n};\nBundleState = gpcas.geometry.BundleState;\n\n/////////////// EdgeNode ////////////////////////////\ngpcas.geometry.EdgeNode = function(){\n\tthis.vertex= new Point(); /* Piggy-backed contour vertex data  */\n\tthis.bot= new Point(); /* Edge lower (x, y) coordinate      */\n\tthis.top= new Point(); /* Edge upper (x, y) coordinate      */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.type;         /* Clip / subject edge flag          */\n\tthis.bundle = ArrayHelper.create2DArray(2,2);      /* Bundle edge flags                 */\n\tthis.bside= [];         /* Bundle left / right indicators    */\n\tthis.bstate= []; /* Edge bundle state                 */\n\tthis.outp= []; /* Output polygon / tristrip pointer */\n\tthis.prev;         /* Previous edge in the AET          */\n\tthis.next;         /* Next edge in the AET              */\n\tthis.pred;         /* Edge connected at the lower end   */\n\tthis.succ;         /* Edge connected at the upper end   */\n\tthis.next_bound;   /* Pointer to next bound in LMT      */\n};\n\n\n\n////////////////   EdgeTable /////////////////////////////////////////\n\n\ngpcas.geometry.EdgeTable = function() {\n\tthis.m_List = new gpcas.util.ArrayList();\n};\ngpcas.geometry.EdgeTable.prototype.addNode = function(x,y){\n\tvar node= new gpcas.geometry.EdgeNode();\n    node.vertex.x = x ;\n    node.vertex.y = y ;\n    this.m_List.add( node );\n\n}\ngpcas.geometry.EdgeTable.prototype.getNode = function (index) {\n\treturn this.m_List.get(index);\n}\ngpcas.geometry.EdgeTable.prototype.FWD_MIN = function(i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n\n    return ((prev.vertex.y >= ith.vertex.y) &&\n                 (next.vertex.y >  ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_FMAX = function ( i) {\n\tvar m_List = this.m_List;\n\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return(next.vertex.y > ith.vertex.y);\n}\ngpcas.geometry.EdgeTable.prototype.REV_MIN = function ( i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return ((prev.vertex.y >  ith.vertex.y) && (next.vertex.y >= ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_RMAX = function (i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return (prev.vertex.y > ith.vertex.y) ;\n}\n\n\n/////////////////////   HState   //////////////////////////////////////\ngpcas.geometry.HState = function(){};\ngpcas.geometry.HState.NH = 0; /* No horizontal edge                */\ngpcas.geometry.HState.BH = 1; /* Bottom horizontal edge            */\ngpcas.geometry.HState.TH = 2; /* Top horizontal edge               */\n\nHState = gpcas.geometry.HState;\n\nvar NH = gpcas.geometry.HState.NH;\nvar BH = gpcas.geometry.HState.BH;\nvar TH = gpcas.geometry.HState.TH;\n\n/* Horizontal edge state transitions within scanbeam boundary */\ngpcas.geometry.HState.next_h_state =\n      [\n      /*        ABOVE     BELOW     CROSS */\n      /*        L   R     L   R     L   R */\n      /* NH */ [BH, TH,   TH, BH,   NH, NH],\n      /* BH */ [NH, NH,   NH, NH,   TH, TH],\n      /* TH */ [NH, NH,   NH, NH,   BH, BH]\n      ];\n\n\n\n///////////////////////    \t  IntersectionPoint /////////////////////////////\ngpcas.geometry.IntersectionPoint = function(p1,p2,p3){\n\tthis.polygonPoint1 = p1; /* of Point */;\n\tthis.polygonPoint2 = p2;  /* of Point */;\n\tthis.intersectionPoint = p3 ;\n};\ngpcas.geometry.IntersectionPoint.prototype.toString = function (){\n\treturn \"P1 :\"+polygonPoint1.toString()+\" P2:\"+polygonPoint2.toString()+\" IP:\"+intersectionPoint.toString();\n}\n\n\n///////////////////////////    ItNode   ///////////////\ngpcas.geometry.ItNode = function(edge0, edge1, x, y, next){\n\tthis.ie= [];     /* Intersecting edge (bundle) pair   */\n\tthis.point= new Point(x,y); /* Point of intersection             */\n\tthis.next=next;                         /* The next intersection table node  */\n\n\tthis.ie[0] = edge0 ;\n    this.ie[1] = edge1 ;\n\n};\n\n\n///////////////////////////    ItNodeTable   ///////////////\ngpcas.geometry.ItNodeTable = function(){\n\tthis.top_node;\n}\nItNodeTable = gpcas.geometry.ItNodeTable;\n\ngpcas.geometry.ItNodeTable.prototype.build_intersection_table = function (aet, dy) {\n    var st= null ;\n\n    /* Process each AET edge */\n    for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n    {\n        if( (edge.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) ||\n                (edge.bundle[Clip.ABOVE][Clip.CLIP] != 0) ||\n                (edge.bundle[Clip.ABOVE][Clip.SUBJ] != 0) )\n        {\n            st = gpcas.geometry.Clip.add_st_edge(st, this, edge, dy);\n        }\n\n\n    }\n}\n\n////////////// Line //////////////////////////\ngpcas.geometry.Line = function(){\n\tthis.start;\n\tthis.end;\n}\n\n////////////   LineHelper /////////////////////\n\ngpcas.geometry.LineHelper = function(){};\ngpcas.geometry.LineHelper.equalPoint = function (p1,p2){\n\treturn ((p1[0]==p2[0])&&(p1[1]==p2[1]));\n}\ngpcas.geometry.LineHelper.equalVertex = function(s1,e1,s2,e2) {\n\treturn (\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,s2))&&(gpcas.geometry.LineHelper.equalPoint(e1,e2)))\n\t\t||\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,e2))&&(gpcas.geometry.LineHelper.equalPoint(e1,s2)))\n\t\t);\n}\ngpcas.geometry.LineHelper.distancePoints = function(p1, p2){\n\treturn Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\n}\ngpcas.geometry.LineHelper.clonePoint = function(p){\n\treturn [p[0],p[1]];\n}\ngpcas.geometry.LineHelper.cloneLine = function(line){\n\tvar res  = [];\n\tfor (var i = 0; i<line.length; i++){\n\t\tres[i]=[line[i][0],line[i][1]];\n\t}\n\treturn res;\n}\ngpcas.geometry.LineHelper.addLineToLine = function(line1,line2) {\n\tfor (var i = 0; i<line2.length; i++){\n\t\tline1.push(clonePoint(line2[i]));\n\t}\n}\ngpcas.geometry.LineHelper.roundPoint = function(p) {\n\tp[0]=Math.round(p[0]);\n\tp[1]=Math.round(p[1]);\n}\n//---------------------------------------------------------------\n//Checks for intersection of Segment if as_seg is true.\n//Checks for intersection of Line if as_seg is false.\n//Return intersection of Segment \"AB\" and Segment \"EF\" as a Point\n//Return null if there is no intersection\n//---------------------------------------------------------------\ngpcas.geometry.LineHelper.lineIntersectLine = function(A,B,E,F,as_seg)\n{\n\tif(as_seg == null) as_seg = true;\n\tvar ip;\n\tvar a1;\n\tvar a2;\n\tvar b1;\n\tvar b2;\n\tvar c1;\n\tvar c2;\n\n\ta1= B.y-A.y;\n\tb1= A.x-B.x;\n\tc1= B.x*A.y - A.x*B.y;\n\ta2= F.y-E.y;\n\tb2= E.x-F.x;\n\tc2= F.x*E.y - E.x*F.y;\n\n\tvar denom=a1*b2 - a2*b1;\n\tif(denom == 0){\n\t\treturn null;\n\t}\n\tip=new Point();\n\tip.x=(b1*c2 - b2*c1)/denom;\n\tip.y=(a2*c1 - a1*c2)/denom;\n\n\t//---------------------------------------------------\n\t//Do checks to see if intersection to endpoints\n\t//distance is longer than actual Segments.\n\t//Return null if it is with any.\n\t//---------------------------------------------------\n\tif(as_seg){\n\t\tif(Math.pow((ip.x - B.x) + (ip.y - B.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - A.x) + (ip.y - A.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\n\t\tif(Math.pow((ip.x - F.x) + (ip.y - F.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - E.x) + (ip.y - E.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn new Point(Math.round(ip.x),Math.round(ip.y));\n}\n\n\n//////////////  LineIntersection  ///////////////////////\ngpcas.geometry.LineIntersection = function(){};\ngpcas.geometry.LineIntersection.iteratePoints = function(points, s1, s2,e1,e2) {\n\tvar direction=true;\n\tvar pl = points.length;\n\tvar s1Ind = points.indexOf(s1);\n\tvar s2Ind = points.indexOf(s2);\n\tvar start = s1Ind;\n\n\tif (s2Ind>s1Ind) direction=false;\n\tvar newPoints  = [];\n\tvar point  ;\n\n\tif (direction){\n\t\tfor (var i =0; i<pl; i++){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var i =pl; i>=0; i--){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newPoints;\n}\n\ngpcas.geometry.LineIntersection.intersectPoly = function(poly, line /* of Points */){\n\tvar res = [];\n\tvar numPoints = poly.getNumPoints();\n\n\t//points\n\tvar ip ;\n\tvar p1 ;\n\tvar p2 ;\n\tvar p3 ;\n\tvar p4 ;\n\tvar firstIntersection  = null;\n\tvar lastIntersection   = null;\n\tvar firstIntersectionLineIndex=-1;\n\tvar lastIntersectionLineIndex=-1;\n\tvar firstFound  = false;\n\n\tfor (var i  = 1; i<line.length; i++){\n\t\tp1=line[i-1];\n\t\tp2=line[i];\n\t\tvar maxDist  = 0;\n\t\tvar minDist\t = Number.MAX_VALUE;\n\t\tvar dist  = -1;\n\t\tfor (var j  = 0; j<numPoints; j++){\n\t\t\tp3=poly.getPoint(j==0?numPoints-1:j-1);\n\t\t\tp4=poly.getPoint(j);\n\t\t\tif ((ip=LineHelper.lineIntersectLine(p1,p2,p3,p4))!=null){\n\t\t\t\tdist=Point.distance(ip,p2);\n\n\t\t\t\tif ((dist>maxDist)&&(!firstFound)){\n\t\t\t\t\tmaxDist=dist;\n\t\t\t\t\tfirstIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tfirstIntersectionLineIndex=i;\n\t\t\t\t}\n\t\t\t\tif (dist<minDist){\n\t\t\t\t\tminDist=dist;\n\t\t\t\t\tlastIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tlastIntersectionLineIndex=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfirstFound=(firstIntersection!=null);\n\t}\n\t\t\t/*\n\t\t\tAlert.show(firstIntersection.toString());\n\t\t\tAlert.show(lastIntersection.toString());*/\n\tif ((firstIntersection!=null)&&(lastIntersection!=null)){\n\t\tvar newLine /* of Point */ = [];\n\t\tnewLine[0]=firstIntersection.intersectionPoint;\n\t\tvar j  = 1;\n\t\tfor (var i = firstIntersectionLineIndex; i<=lastIntersectionLineIndex; i++){\n\t\t\tnewLine[j++] = line[i];\n\t\t}\n\t\tnewLine[newLine.length-1]=lastIntersection.intersectionPoint;\n\t\tif (\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint1))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint2))\n\t\t\t)||\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint2))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint1))\n\t\t\t\t)\n\t\t){\n\t\t\t\tvar poly1 = new gpcas.geometry.PolySimple();\n\t\t\t\tpoly1.add(newLine);\n\t\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\t\tvar finPoly2  = poly.xor(poly1);\n\t\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t} else {\n\t\t\tvar points1 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint1,firstIntersection.polygonPoint2, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints1=points1.concat(newLine.reverse());\n\t\t\tvar points2 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint2,firstIntersection.polygonPoint1, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints2=points2.concat(newLine);\n\t\t\tvar poly1  = new gpcas.geometry.PolySimple();\n\t\t\tpoly1.add(points1);\n\t\t\tvar poly2  = new gpcas.geometry.PolySimple();\n\t\t\tpoly2.add(points2);\n\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\tvar finPoly2  = poly.intersection(poly2);\n\n\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n}\ngpcas.geometry.LineIntersection.checkPoly = function(poly) {\n\tvar noHoles =0;\n\tfor (var i  = 0; i<poly.getNumInnerPoly(); i++){\n\t\tvar innerPoly  = poly.getInnerPoly(i);\n\t\tif (innerPoly.isHole()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\tnoHoles++;\n\t\t}\n\t\tif (noHoles>1) return false;\n\t}\n\treturn true;\n}\n\n\n///////////  LmtNode //////////////////////////\n\ngpcas.geometry.LmtNode = function(yvalue) {\n\tthis.y = yvalue;            /* Y coordinate at local minimum     */\n\tthis.first_bound;  /* Pointer to bound list             */\n\tthis.next;         /* Pointer to next local minimum     */\n};\nLmtNode = gpcas.geometry.LmtNode;\n\n////////////// LmtTable ///////////////\n\ngpcas.geometry.LmtTable = function(){\n\tthis.top_node;\n};\ngpcas.geometry.LmtTable.prototype.print = function() {\n    var n= 0;\n    var lmt= this.top_node ;\n    while( lmt != null )\n    {\n\t\t//console.log(\"lmt(\"+n+\")\");\n\t\tfor( var edge= lmt.first_bound ; (edge != null) ; edge = edge.next_bound )\n\t\t{\n\t\t   //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n\t\t}\n\t\tn++ ;\n\t\tlmt = lmt.next ;\n    }\n}\n\n/////////////   OperationType //////////////////////////////////\ngpcas.geometry.OperationType = function(type){\n\tthis.m_Type = type;\n}\ngpcas.geometry.OperationType.GPC_DIFF= new gpcas.geometry.OperationType( \"Difference\" );\ngpcas.geometry.OperationType.GPC_INT= new gpcas.geometry.OperationType( \"Intersection\" );\ngpcas.geometry.OperationType.GPC_XOR= new gpcas.geometry.OperationType( \"Exclusive or\" );\ngpcas.geometry.OperationType.GPC_UNION= new gpcas.geometry.OperationType( \"Union\" );\n\n//////////// Poly  /////////////////////\n// ---> an interface\n\n\n/////////////// PolyDefault  /////////////////////\n/**\n * <code>PolyDefault</code> is a default <code>Poly</code> implementation.\n * It provides support for both complex and simple polygons.  A <i>complex polygon</i>\n * is a polygon that consists of more than one polygon.  A <i>simple polygon</i> is a\n * more traditional polygon that contains of one inner polygon and is just a\n * collection of points.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty <code>PolyDefault</code>\n * object, it will create an inner polygon of type <code>PolySimple</code>.\n *\n * @see PolySimple\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolyDefault = function(isHole) {\n\tif(isHole == null) isHole = false;\n\n\t   /**\n    * Only applies to the first poly and can only be used with a poly that contains one poly\n    */\n\tthis.m_IsHole= isHole ;\n    this.m_List= new gpcas.util.ArrayList();\n}\n /**\n    * Return true if the given object is equal to this one.\n    */\ngpcas.geometry.PolyDefault.prototype.equals = function ( obj) {\n    if(!(obj instanceof PolyDefault)){\n\t\treturn false;\n    }\n    var that = obj;\n\n    if( this.m_IsHole != that.m_IsHole ) return false ;\n    if( !equals(this.m_List, that.m_List ) ) return false ;\n\n    return true ;\n}\n   /**\n    * Return the hashCode of the object.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    **/\ngpcas.geometry.PolyDefault.prototype.hashCode = function () {\n\tvar m_List = this.m_List;\n\n    var result= 17;\n    result = 37*result + m_List.hashCode();\n    return result;\n}\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.clear = function() {\n    this.m_List.clear();\n}\n\ngpcas.geometry.PolyDefault.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\tif (args.length==2){\n\t\tthis.addPointXY(args[0], args[1]);\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n   \t\t\tthis.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof gpcas.geometry.PolySimple){\n   \t\t\tthis.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n   \t\t\tvar arr  = args[0];\n   \t\t\tif ((arr.length==2)&&(arr[0] instanceof Number)&&(arr[1] instanceof Number)){\n   \t\t\t\tthis.add(arr[0] ,arr[1] )\n   \t\t\t} else {\n   \t\t\t\tfor(var i=0; i<args[0].length ; i++) {\n\t\t\t\t\tthis.add(args[0][i]);\n\t\t\t\t}\n   \t\t\t}\n   \t\t}\n   \t}\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPointXY = function(x, y) {\n    this.addPoint(new Point( x, y ));\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoint = function( p) {\n\n\n\tvar m_List = this.m_List;\n\n    if( m_List.size() == 0)\n    {\n        m_List.add(new gpcas.geometry.PolySimple());\n    }\n    (m_List.get(0)).addPoint(p);\n}\n /**\n    * Add an inner polygon to this polygon - assumes that adding polygon does not\n    * have any inner polygons.\n    *\n    * @throws IllegalStateException if the number of inner polygons is greater than\n    * zero and this polygon was designated a hole.  This would break the assumption\n    * that only simple polygons can be holes.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoly = function( p) {\n\n\tvar m_IsHole = this.m_IsHole;\n\tvar m_List = this.m_List;\n\n    if( (m_List.size() > 0) && m_IsHole )\n      {\n         alert(\"ERROR : Cannot add polys to something designated as a hole.\");\n      }\n    m_List.add( p );\n}\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolyDefault.prototype.isEmpty = function() {\n    return this.m_List.isEmpty();\n}\n /**\n    * Returns the bounding rectangle of this polygon.\n    * <strong>WARNING</strong> Not supported on complex polygons.\n    */\ngpcas.geometry.PolyDefault.prototype.getBounds = function () {\n\tvar m_List = this.m_List;\n    if( m_List.size() == 0)\n    {\n        return new Rectangle();\n    }\n    else if( m_List.size() == 1)\n    {\n         var ip= this.getInnerPoly(0);\n         return ip.getBounds();\n    }\n    else\n    {\n         console.log(\"getBounds not supported on complex poly.\");\n    }\n}\n   /**\n    * Returns the polygon at this index.\n    */\ngpcas.geometry.PolyDefault.prototype.getInnerPoly = function(polyIndex) {\n      return this.m_List.get(polyIndex);\n}\n   /**\n    * Returns the number of inner polygons - inner polygons are assumed to return one here.\n    */\ngpcas.geometry.PolyDefault.prototype.getNumInnerPoly = function() {\n\tvar m_List = this.m_List;\n      return m_List.size();\n}\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getNumPoints = function () {\n    return (this.m_List.get(0)).getNumPoints() ;\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getX = function(index) {\n      return (this.m_List.get(0)).getX(index) ;\n}\ngpcas.geometry.PolyDefault.prototype.getPoint = function(index){\n\t\treturn (this.m_List.get(0)).getPoint(index) ;\n}\n\ngpcas.geometry.PolyDefault.prototype.getPoints = function(){\n\treturn (this.m_List.get(0)).getPoints();\n}\n\n\ngpcas.geometry.PolyDefault.prototype.isPointInside = function (point) {\n\tvar m_List = this.m_List;\n   \tif (!(m_List.get(0)).isPointInside(point)) return false;\n\n\tfor (var i  = 0; i<m_List.size(); i++){\n   \t\tvar poly  = m_List.get(i);\n   \t\t\tif ((poly.isHole())&&(poly.isPointInside(point))) return false;\n   \t\t}\n   \t\treturn true;\n}\n     /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getY = function (index) {\n\tvar m_List = this.m_List;\n      return (m_List.get(0)).getY(index) ;\n}\n\n   /**\n    * Return true if this polygon is a hole.  Holes are assumed to be inner polygons of\n    * a more complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.isHole = function () {\n\tvar m_List = this.m_List;\n\tvar m_IsHole = this.m_IsHole;\n\n      if( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n      return m_IsHole ;\n}\n\n   /**\n    * Set whether or not this polygon is a hole.  Cannot be called on a complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.setIsHole = function(isHole) {\n    var m_List = this.m_List;\n\tif( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n    this.m_IsHole = isHole ;\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    */\ngpcas.geometry.PolyDefault.prototype.isContributing = function( polyIndex) {\n      var m_List = this.m_List;\n\t  return (m_List.get(polyIndex)).isContributing(0);\n}\n\n    /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if called on a complex polygon\n    */\ngpcas.geometry.PolyDefault.prototype.setContributing = function( polyIndex, contributes) {\n    var m_List = this.m_List;\n\tif( m_List.size() != 1)\n      {\n        alert( \"Only applies to polys of size 1\" );\n      }\n     (m_List.get(polyIndex)).setContributing( 0, contributes );\n}\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.union = function(p) {\n\treturn gpcas.geometry.Clip.union( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolyDefault\" );\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolyDefault.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolyDefault\");\n}\n\n   /**\n    * Return the area of the polygon in square units.\n    */\ngpcas.geometry.PolyDefault.prototype.getArea = function() {\n      var area= 0.0;\n      for( var i= 0; i < getNumInnerPoly() ; i++ )\n      {\n         var p= getInnerPoly(i);\n         var tarea = p.getArea() * (p.isHole() ? -1.0: 1.0);\n         area += tarea ;\n      }\n      return area ;\n}\n\n   // -----------------------\n   // --- Package Methods ---\n   // -----------------------\ngpcas.geometry.PolyDefault.prototype.toString = function() {\n    var res  = \"\";\n\tvar m_List = this.m_List;\n    for( var i= 0; i < m_List.size() ; i++ )\n    {\n         var p = this.getInnerPoly(i);\n         res+=(\"InnerPoly(\"+i+\").hole=\"+p.isHole());\n         var points = [];\n         for( var j= 0; j < p.getNumPoints() ; j++ )\n         {\n         \tpoints.push(new Point(p.getX(j),p.getY(j)));\n         }\n         points = ArrayHelper.sortPointsClockwise(points) ;\n\n\t\t for(var k =0 ; k< points.length ; k++) {\n\t\t\tres+=points[k].toString();\n\t\t }\n\n      }\n      return res;\n   }\n\n///////////////  Polygon   /////////////////////////////////\ngpcas.geometry.Polygon = function(){\n\tthis.maxTop ;\n\tthis.maxBottom ;\n\tthis.maxLeft ;\n\tthis.maxRight ;\n\tthis.vertices  /* of Point */;\n};\ngpcas.geometry.Polygon.prototype.fromArray = function(v) {\n\tthis.vertices = [];\n\n\tfor(var i=0 ; i<v.length ; i++) {\n\t\tvar pointArr = v[i];\n\t\tthis.vertices.push(new Point(pointArr[0],pointArr[1]));\n\t}\n}\n\n\t\t/*Normalize vertices in polygon to be ordered clockwise from most left point*/\ngpcas.geometry.Polygon.prototype.normalize = function() {\n\tvar maxLeftIndex ;\n\tvar vertices = this.vertices;\n\tvar newVertices = this.vertices;\n\n\tfor (var i  = 0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\n\t\tif ((maxTop==null)||(maxTop.y>vertex.y)||((maxTop.y==vertex.y)&&(vertex.x<maxTop.x))){\n\t\t\tmaxTop=vertex;\n\t\t}\n\t\tif ((maxBottom==null)||(maxBottom.y<vertex.y)||((maxBottom.y==vertex.y)&&(vertex.x>maxBottom.x))){\n\t\t\tmaxBottom=vertex;\n\t\t}\n \t\tif ((maxLeft==null)||(maxLeft.x>vertex.x)||((maxLeft.x==vertex.x)&&(vertex.y>maxLeft.y))){\n\t\t\tmaxLeft=vertex;\n\t\t\tmaxLeftIndex=i;\n\t\t}\n\t\tif ((maxRight==null)||(maxRight.x<vertex.x)||((maxRight.x==vertex.x)&&(vertex.y<maxRight.y))){\n\t\t\tmaxRight=vertex;\n\t\t}\n\t}\n\n\tif (maxLeftIndex>0){\n\t\tnewVertices = [];\n\t\tvar j = 0;\n\t\tfor (var i=maxLeftIndex; i<vertices.length;i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tfor (var i=0; i<maxLeftIndex; i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n\tvar reverse   = false;\n\tfor(var k=0; k<this.vertices.length ; k++) {\n\t\tvar vertex  =  this.vertices[k];\n\t    if (equals(vertex, maxBottom)){\n\t\t\treverse=true;\n\t\t\tbreak;\n\t\t} else if (equals(vertex, maxTop)){\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reverse){\n\t\tnewVertices= [];\n\t\tnewVertices[0]=vertices[0];\n\t\tvar j =1;\n\t\tfor (var i=vertices.length-1; i>0; i--){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n}\ngpcas.geometry.Polygon.prototype.getVertexIndex = function(vertex){\n\tfor (var i=0; i<this.vertices.length; i++){\n\t\tif (equals(vertices[i], vertex)){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\ngpcas.geometry.Polygon.prototype.insertVertex = function(vertex1,vertex2, newVertex){\n\tvar vertex1Index  = getVertexIndex(vertex1);\n\tvar vertex2Index  = getVertexIndex(vertex2);\n\tif ((vertex1Index==-1)||(vertex2Index==-1)){\n\t\treturn false;\n\t}\n\n\tif (vertex2Index<vertex1Index){\n\t\tvar i  = vertex1Index;\n\t\tvertex1Index=vertex2Index;\n\t\tvertex2Index=i;\n\t}\n\tif (vertex2Index==vertex1Index+1){\n\t\tvar newVertices  = [];\n\t\tfor (var i =0; i<=vertex1Index; i++){\n\t\t\tnewVertices[i]=this.vertices[i];\n\t\t}\n\t\tnewVertices[vertex2Index]=newVertex;\n\t\tfor (var i =vertex2Index; i<this.vertices.length; i++){\n\t\t\tnewVertices[i+1]=this.vertices[i];\n\t\t}\n\t\tthis.vertices=newVertices;\n\t} else if ((vertex2Index==vertices.length-1)&&(vertex1Index==0)){\n\t\tthis.vertices.push(newVertex);\n\t}\n\treturn true;\n}\ngpcas.geometry.Polygon.prototype.clone = function() {\n\tvar res = new gpcas.geometry.Polygon();\n\tres.vertices=vertices.slice(this.vertices.length-1);\n\treturn res;\n}\ngpcas.geometry.Polygon.prototype.toString = function() {\n\tvar vertices = this.vertices;\n\tvar res  = \"[\";\n\tfor (var i  =0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\t\tres+=(i>0?\",\":\"\")+\"[\"+vertex.x+\",\"+vertex.y+\"]\";\n\t}\n\tres+=\"]\";\n\treturn res;\n}\n\n\n////////////////////  PolygonNode ///////////////////////////\ngpcas.geometry.PolygonNode = function(next, x, y) {\n\n\n\tthis.active;                 /* Active flag / vertex count        */\n\tthis.hole;                /* Hole / external contour flag      */\n\tthis.v= [] ; /* Left and right vertex list ptrs   */\n\tthis.next;                   /* Pointer to next polygon contour   */\n\tthis.proxy;                  /* Pointer to actual structure used  */\n\n\t/* Make v[Clip.LEFT] and v[Clip.RIGHT] point to new vertex */\n\tvar vn= new VertexNode( x, y );\n\n\tthis.v[Clip.LEFT ] = vn ;\n\tthis.v[Clip.RIGHT] = vn ;\n\n\tthis.next = next ;\n\tthis.proxy = this ; /* Initialise proxy to point to p itself */\n\tthis.active = 1; //TRUE\n}\ngpcas.geometry.PolygonNode.prototype.add_right = function( x, y) {\n\tvar nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the right end of the polygon's vertex list */\n\t this.proxy.v[Clip.RIGHT].next= nv;\n\n\t /* Update proxy->v[Clip.RIGHT] to point to nv */\n\t this.proxy.v[Clip.RIGHT]= nv;\n}\ngpcas.geometry.PolygonNode.prototype.add_left = function( x, y) {\n\t var proxy = this.proxy;\n\n\t var nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the left end of the polygon's vertex list */\n\t nv.next= proxy.v[Clip.LEFT];\n\n\t /* Update proxy->[Clip.LEFT] to point to nv */\n\t proxy.v[Clip.LEFT]= nv;\n}\n\n\n//////////////////   PolySimple ////////////////\n\n/**\n * <code>PolySimple</code> is a simple polygon - contains only one inner polygon.\n * <p>\n * <strong>WARNING:</strong> This type of <code>Poly</code> cannot be used for an\n * inner polygon that is a hole.\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolySimple = function(){\n\t/**\n    * The list of Point objects in the polygon.\n    */\n   this.m_List= new gpcas.util.ArrayList();\n\n   /** Flag used by the Clip algorithm */\n   this.m_Contributes= true ;\n};\n\n   /**\n    * Return true if the given object is equal to this one.\n    * <p>\n    * <strong>WARNING:</strong> This method failse if the first point\n    * appears more than once in the list.\n    */\ngpcas.geometry.PolySimple.prototype.equals = function(obj) {\n  if( !(obj instanceof PolySimple) )\n  {\n\t return false;\n  }\n\n  var that= obj;\n\n  var this_num= this.m_List.size();\n  var that_num= that.m_List.size();\n  if( this_num != that_num ) return false ;\n\n\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING: This is not the greatest algorithm.  It fails if !!!\n  // !!! the first point in \"this\" poly appears more than once.    !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  if( this_num > 0)\n  {\n\t var this_x= this.getX(0);\n\t var this_y= this.getY(0);\n\t var that_first_index = -1;\n\t for( var that_index= 0; (that_first_index == -1) && (that_index < that_num) ; that_index++ )\n\t {\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\t\tif( (this_x == that_x) && (this_y == that_y) )\n\t\t{\n\t\t   that_first_index = that_index ;\n\t\t}\n\t }\n\t if( that_first_index == -1) return false ;\n\t var that_index= that_first_index ;\n\t for( var this_index= 0; this_index < this_num ; this_index++ )\n\t {\n\t\tthis_x = this.getX(this_index);\n\t\tthis_y = this.getY(this_index);\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\n\t\tif( (this_x != that_x) || (this_y != that_y) ) return false;\n\n\t\tthat_index++ ;\n\t\tif( that_index >= that_num )\n\t\t{\n\t\t   that_index = 0;\n\t\t}\n\t }\n  }\n  return true ;\n}\n\n   /**\n    * Return the hashCode of the object.\n    * <p>\n    * <strong>WARNING:</strong>Hash and Equals break contract.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    */\ngpcas.geometry.PolySimple.prototype.hashCode = function() {\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING:  This hash and equals break the contract. !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  var result= 17;\n  result = 37*result + this.m_List.hashCode();\n  return result;\n}\n\n   /**\n    * Return a string briefly describing the polygon.\n    */\ngpcas.geometry.PolySimple.prototype.toString = function() {\n    return \"PolySimple: num_points=\"+getNumPoints();\n}\n\n   // --------------------\n   // --- Poly Methods ---\n   // --------------------\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolySimple.prototype.clear = function() {\n      this.m_List.clear();\n}\n\n\ngpcas.geometry.PolySimple.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\n   \tif (args.length==2){\n\t\tthis.addPointXY(args[0] , args[1] );\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n               this.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof Poly){\n               this.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n\t\t\tfor(var k=0 ; k<args[0].length ; k++) {\n\t\t\t\tvar val = args[0][k];\n                this.add(val);\n\t\t\t}\n   \t\t}\n   \t}\n}\n\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPointXY = function(x, y) {\n    this.addPoint( new Point( x, y ) );\n}\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPoint = function(p) {\n      this.m_List.add( p );\n}\n\n   /**\n    * Throws IllegalStateexception if called\n    */\ngpcas.geometry.PolySimple.prototype.addPoly = function(p) {\n    alert(\"Cannot add poly to a simple poly.\");\n}\n\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolySimple.prototype.isEmpty = function() {\n      return this.m_List.isEmpty();\n}\n\n   /**\n    * Returns the bounding rectangle of this polygon.\n    */\ngpcas.geometry.PolySimple.prototype.getBounds = function() {\n\t  var xmin=  Number.MAX_VALUE ;\n\t  var ymin=  Number.MAX_VALUE ;\n\t  var xmax= -Number.MAX_VALUE ;\n\t  var ymax= -Number.MAX_VALUE ;\n\n      for( var i= 0; i < this.m_List.size() ; i++ )\n      {\n         var x= this.getX(i);\n         var y= this.getY(i);\n         if( x < xmin ) xmin = x;\n         if( x > xmax ) xmax = x;\n         if( y < ymin ) ymin = y;\n         if( y > ymax ) ymax = y;\n      }\n\n      return new Rectangle( xmin, ymin, (xmax-xmin), (ymax-ymin) );\n   }\n\n   /**\n    * Returns <code>this</code> if <code>polyIndex = 0</code>, else it throws\n    * IllegalStateException.\n    */\ngpcas.geometry.PolySimple.prototype.getInnerPoly = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this ;\n}\n\n   /**\n    * Always returns 1.\n    */\ngpcas.geometry.PolySimple.prototype.getNumInnerPoly = function() {\n    return 1;\n}\n\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getNumPoints = function() {\n      return this.m_List.size();\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getX = function(index) {\n    return (this.m_List.get(index)).x;\n}\n\n   /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getY = function(index) {\n    return (this.m_List.get(index)).y;\n}\n\ngpcas.geometry.PolySimple.prototype.getPoint = function(index){\n\treturn (this.m_List.get(index));\n}\n\ngpcas.geometry.PolySimple.prototype.getPoints = function() {\n\treturn this.m_List.toArray();\n}\n\ngpcas.geometry.PolySimple.prototype.isPointInside = function(point) {\n\t var points  = this.getPoints();\n\t var j  = points.length - 1;\n\t var oddNodes = false;\n\n\t for (var i  = 0; i < points.length; i++)\n\t {\n\t\t if (points[i].y < point.y && points[j].y >= point.y ||\n\t\t\t points[j].y < point.y && points[i].y >= point.y)\n\t\t {\n\t\t\t if (points[i].x +\n\t\t\t\t (point.y - points[i].y)/(points[j].y - points[i].y)*(points[j].x - points[i].x) < point.x)\n\t\t\t {\n\t\t\t\t oddNodes = !oddNodes;\n\t\t\t}\n\t\t }\n\t\t j = i;\n\t }\n\t return oddNodes;\n}\n\n\n   /**\n    * Always returns false since PolySimples cannot be holes.\n    */\ngpcas.geometry.PolySimple.prototype.isHole = function() {\n      return false ;\n}\n\n   /**\n    * Throws IllegalStateException if called.\n    */\ngpcas.geometry.PolySimple.prototype.setIsHole =function(isHole) {\n    alert(\"PolySimple cannot be a hole\");\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.isContributing = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this.m_Contributes ;\n}\n\n   /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.setContributing = function( polyIndex, contributes) {\n      if( polyIndex != 0)\n      {\n         alert(\"PolySimple only has one poly\");\n      }\n      this.m_Contributes = contributes ;\n   }\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( this, p,\"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.union = function(p) {\n      return gpcas.geometry.Clip.union( this, p, \"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolySimple\");\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolySimple.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolySimple\");\n}\n\n   /**\n    * Returns the area of the polygon.\n    * <p>\n    * The algorithm for the area of a complex polygon was take from\n    * code by Joseph O'Rourke author of \" Computational Geometry in C\".\n    */\ngpcas.geometry.PolySimple.prototype.getArea = function() {\n      if( this.getNumPoints() < 3)\n      {\n         return 0.0;\n      }\n      var ax= this.getX(0);\n      var ay= this.getY(0);\n\n      var area= 0.0;\n      for( var i= 1; i < (this.getNumPoints()-1) ; i++ )\n      {\n         var bx= this.getX(i);\n         var by= this.getY(i);\n         var cx= this.getX(i+1);\n         var cy= this.getY(i+1);\n         var tarea= ((cx - bx)*(ay - by)) - ((ax - bx)*(cy - by));\n         area += tarea ;\n      }\n      area = 0.5*Math.abs(area);\n      return area ;\n   }\n\n  /////////////////////// Rectangle  ///////////////////\ngpcas.geometry.Rectangle = function(_x, _y, _w, _h) {\n\tthis.x = _x;\n\tthis.y = _y;\n\tthis.w = _w;\n\tthis.h = _h;\n}\ngpcas.geometry.Rectangle.prototype.getMaxY = function(){\n\treturn this.y+this.h;\n}\ngpcas.geometry.Rectangle.prototype.getMinY = function(){\n\treturn this.y;\n}\ngpcas.geometry.Rectangle.prototype.getMaxX = function() {\n\treturn this.x+this.w;\n}\ngpcas.geometry.Rectangle.prototype.getMinX = function(){\n\treturn this.x;\n}\ngpcas.geometry.Rectangle.prototype.toString = function(){\n\treturn \"[\"+x.toString()+\" \"+y.toString()+\" \"+w.toString()+\" \"+h.toString()+\"]\";\n}\n\n/////////////////// ScanBeamTree //////////////////////\ngpcas.geometry.ScanBeamTree = function(yvalue) {\n\tthis.y = yvalue;         /* Scanbeam node y value             */\n\tthis.less;         /* Pointer to nodes with lower y     */\n\tthis.more;         /* Pointer to nodes with higher y    */\n}\n\n///////////////////////// ScanBeamTreeEntries /////////////////\ngpcas.geometry.ScanBeamTreeEntries = function(){\n\tthis.sbt_entries=0;\n\tthis.sb_tree;\n};\ngpcas.geometry.ScanBeamTreeEntries.prototype.build_sbt = function() {\n\tvar sbt= [];\n\n\tvar entries= 0;\n\tentries = this.inner_build_sbt( entries, sbt, this.sb_tree );\n\n\t//console.log(\"SBT = \"+this.sbt_entries);\n\n\tif( entries != this.sbt_entries )\n\t{\n\t//console.log(\"Something went wrong buildign sbt from tree.\");\n\t}\n\treturn sbt ;\n}\ngpcas.geometry.ScanBeamTreeEntries.prototype.inner_build_sbt = function( entries, sbt, sbt_node) {\n\tif( sbt_node.less != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.less);\n\t }\n\t sbt[entries]= sbt_node.y;\n\t entries++;\n\t if( sbt_node.more != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.more );\n\t }\n\t return entries ;\n}\n\n///////////////////////////  StNode\nStNode = gpcas.geometry.StNode = function( edge, prev) {\n\tthis.edge;         /* Pointer to AET edge               */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.prev;         /* Previous edge in sorted list      */\n\n\tthis.edge = edge ;\n\t this.xb = edge.xb ;\n\t this.xt = edge.xt ;\n\t this.dx = edge.dx ;\n\t this.prev = prev ;\n}\n\n/////////////////////   TopPolygonNode /////////////////\ngpcas.geometry.TopPolygonNode = function(){\n\tthis.top_node;\n};\nTopPolygonNode = gpcas.geometry.TopPolygonNode;\n\ngpcas.geometry.TopPolygonNode.prototype.add_local_min = function( x, y) {\n\t var existing_min= this.top_node;\n\t this.top_node = new gpcas.geometry.PolygonNode( existing_min, x, y );\n\t return this.top_node ;\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_left = function( p, q) {\n /* Label contour as a hole */\n q.proxy.hole = true ;\n var top_node = this.top_node;\n\n if (p.proxy != q.proxy) {\n\t/* Assign p's vertex list to the left end of q's list */\n\tp.proxy.v[Clip.RIGHT].next= q.proxy.v[Clip.LEFT];\n\tq.proxy.v[Clip.LEFT]= p.proxy.v[Clip.LEFT];\n\n\t/* Redirect any p.proxy references to q.proxy */\n\tvar target= p.proxy ;\n\tfor(var node= top_node; (node != null); node = node.next)\n\t{\n\t   if (node.proxy == target)\n\t   {\n\t\t  node.active= 0;\n\t\t  node.proxy= q.proxy;\n\t   }\n\t}\n }\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_right = function( p, q) {\n\t var top_node = this.top_node;\n\t /* Label contour as external */\n\t q.proxy.hole = false ;\n\n\t if (p.proxy != q.proxy)\n\t {\n\t\t/* Assign p's vertex list to the right end of q's list */\n\t\tq.proxy.v[Clip.RIGHT].next= p.proxy.v[Clip.LEFT];\n\t\tq.proxy.v[Clip.RIGHT]= p.proxy.v[Clip.RIGHT];\n\n\t\t/* Redirect any p->proxy references to q->proxy */\n\t\tvar target= p.proxy ;\n\t\tfor (var node = top_node ; (node != null ); node = node.next)\n\t\t{\n\t\t   if (node.proxy == target)\n\t\t   {\n\t\t\t  node.active = 0;\n\t\t\t  node.proxy= q.proxy;\n\t\t   }\n\t\t}\n\t }\n  }\ngpcas.geometry.TopPolygonNode.prototype.count_contours = function() {\nvar nc= 0;\n\nfor ( var polygon= this.top_node; (polygon != null) ; polygon = polygon.next)\n\t {\n\t\tif (polygon.active != 0)\n\t\t{\n\t\t   /* Count the vertices in the current contour */\n\t\t   var nv= 0;\n\t\t   for (var v= polygon.proxy.v[Clip.LEFT]; (v != null); v = v.next)\n\t\t   {\n\t\t\t  nv++;\n\t\t   }\n\n\t\t   /* Record valid vertex counts in the active field */\n\t\t   if (nv > 2)\n\t\t   {\n\t\t\t  polygon.active = nv;\n\t\t\t  nc++;\n\t\t   }\n\t\t   else\n\t\t   {\n\t\t\t  /* Invalid contour: just free the heap */\n//                  VertexNode nextv = null ;\n//                  for (VertexNode v= polygon.proxy.v[Clip.LEFT]; (v != null); v = nextv)\n//                  {\n//                     nextv= v.next;\n//                     v = null ;\n//                  }\n\t\t\t  polygon.active= 0;\n\t\t   }\n\t\t}\n\t }\n\t return nc;\n  }\ngpcas.geometry.TopPolygonNode.prototype.getResult = function(polyClass) {\n\nvar top_node = this.top_node;\nvar result= gpcas.geometry.Clip.createNewPoly( polyClass );\n//console.log(polyClass);\n\n\nvar num_contours = this.count_contours();\n\nif (num_contours > 0)\n\t {\n\t\tvar c= 0;\n\t\tvar npoly_node= null ;\n\t\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t\t{\n\t\t   npoly_node = poly_node.next;\n\t\t   if (poly_node.active != 0)\n\t\t   {\n\n\t\t\t  var poly = result ;\n\n\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t poly = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\t\t  }\n\t\t\t  if( poly_node.proxy.hole )\n\t\t\t  {\n\t\t\t\t poly.setIsHole( poly_node.proxy.hole );\n\t\t\t  }\n\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  // --- This algorithm puts the verticies into the poly in reverse order ---\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t\t  {\n\t\t\t\t poly.add( vtx.x, vtx.y );\n\t\t\t  }\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t result.addPoly( poly );\n\t\t\t  }\n\t\t\t  c++;\n\t\t   }\n\t\t}\n\n\t\t// -----------------------------------------\n\t\t// --- Sort holes to the end of the list ---\n\t\t// -----------------------------------------\n\t\tvar orig= result ;\n\t\tresult = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( !inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t }\n\t return result ;\n  }\ngpcas.geometry.TopPolygonNode.prototype.print = function() {\n    //console.log(\"---- out_poly ----\");\n\tvar top_node = this.top_node;\n    var c= 0;\n    var npoly_node= null ;\n\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t {\n\t\t//console.log(\"contour=\"+c+\"  active=\"+poly_node.active+\"  hole=\"+poly_node.proxy.hole);\n\t\tnpoly_node = poly_node.next;\n\t\tif (poly_node.active != 0)\n\t\t{\n\t\t   var v=0;\n\t\t   for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t   {\n\t\t\t  //console.log(\"v=\"+v+\"  vtx.x=\"+vtx.x+\"  vtx.y=\"+vtx.y);\n\t\t   }\n\t\t   c++;\n\t\t}\n\t }\n}\n\n  ///////////    VertexNode  ///////////////\ngpcas.geometry.VertexNode = function( x, y) {\n\tthis.x;    // X coordinate component\n\tthis.y;    // Y coordinate component\n\tthis.next; // Pointer to next vertex in list\n\n\tthis.x = x ;\n    this.y = y ;\n    this.next = null ;\n}\nVertexNode = gpcas.geometry.VertexNode;\n\n/////////////   VertexType   /////////////\ngpcas.geometry.VertexType = function(){};\ngpcas.geometry.VertexType.NUL=  0; /* Empty non-intersection            */\ngpcas.geometry.VertexType.EMX=  1; /* External maximum                  */\ngpcas.geometry.VertexType.ELI=  2; /* External left intermediate        */\ngpcas.geometry.VertexType.TED=  3; /* Top edge                          */\ngpcas.geometry.VertexType.ERI=  4; /* External right intermediate       */\ngpcas.geometry.VertexType.RED=  5; /* Right edge                        */\ngpcas.geometry.VertexType.IMM=  6; /* Internal maximum and minimum      */\ngpcas.geometry.VertexType.IMN=  7; /* Internal minimum                  */\ngpcas.geometry.VertexType.EMN=  8; /* External minimum                  */\ngpcas.geometry.VertexType.EMM=  9; /* External maximum and minimum      */\ngpcas.geometry.VertexType.LED= 10; /* Left edge                         */\ngpcas.geometry.VertexType.ILI= 11; /* Internal left intermediate        */\ngpcas.geometry.VertexType.BED= 12; /* Bottom edge                       */\ngpcas.geometry.VertexType.IRI= 13; /* Internal right intermediate       */\ngpcas.geometry.VertexType.IMX= 14; /* Internal maximum                  */\ngpcas.geometry.VertexType.FUL= 15; /* Full non-intersection             */\ngpcas.geometry.VertexType.getType = function( tr, tl ,br ,bl) {\n    return tr + (tl << 1) + (br << 2) + (bl << 3);\n}\n\nVertexType = gpcas.geometry.VertexType;\n\n////////////////// WeilerAtherton  /////////////\ngpcas.geometry.WeilerAtherton = function(){};\n\ngpcas.geometry.WeilerAtherton.prototype.merge = function(p1,p2) {\n\tp1=p1.clone();\n\tp2=p2.clone();\n}\n","'use strict';\n\n/*jshint -W072 */\nvar intersect = function (a10, a11, a20, a21, b10, b11, b20, b21) {\n    var ua_t = (b20 - b10) * (a11 - b11) - (b21 - b11) * (a10 - b10);\n    var ub_t = (a20 - a10) * (a11 - b11) - (a21 - a11) * (a10 - b10);\n    var u_b = (b21 - b11) * (a20 - a10) - (b20 - b10) * (a21 - a11);\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\nfunction Cell(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.items = [];\n}\n\nCell.prototype.insert = function(item) {\n    if (\n        (item.fromX >= this.x && item.fromY >= this.y && item.toX <= this.x + this.width && item.toY <= this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x+this.width, this.y) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x+this.width, this.y, this.x+this.width, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y+this.height, this.x+this.width, this.y+this.height)\n    ) {\n        this.items.push(item);\n    }\n};\n\nexports = module.exports = Cell;\n","'use strict';\n\nvar Cell = require('./cell');\nvar DoublyLinkedList = require('../../linkedlist/doublylinkedlist');\n\nfunction Grid(bounds, rows, cols) {\n    this.bounds = bounds;\n    this.rows = rows;\n    this.cols = cols;\n    this.cellX = this.bounds.width / this.cols;\n    this.cellY = this.bounds.height / this.rows;\n    this.cells = [];\n    this.out = new DoublyLinkedList();\n    for( var col = 0;col<this.cols;col++) {\n        this.cells[col] = [];\n        for ( var row=0;row<this.rows;row++) {\n            this.cells[col][row] = new Cell(col*this.cellX, row*this.cellY, this.cellX, this.cellY);\n        }\n    }\n}\n\nGrid.prototype.insert = function(item) {\n    if (item instanceof Array) {\n        var i = 0,\n            n = item.length;\n            while (i<n) {\n                this.insert(item);\n                i++;\n            }\n    } else {\n        for( var col = 0;col<this.cols;col++) {\n            for ( var row=0;row<this.rows;row++) {\n                this.cells[col][row].insert(item);\n            }\n        }\n    }\n};\n\nGrid.prototype.addOut = function(items) {\n    var i = 0,\n        n = items.length;\n    while (i<n) {\n        this.out.add(items[i]);\n        i++;\n    }\n};\n\nGrid.prototype.retrieve = function(item) {\n    // figure out cells\n    var nx = ((item.x%this.cellX) + item.width) > this.cellX ? true : false,\n        ny = ((item.y%this.cellY) + item.height) > this.cellY ? true : false,\n        x = Math.floor(item.x / this.cellX),\n        y = Math.floor(item.y / this.cellY);\n    this.out.clear();\n\n    this.addOut(this.cells[x][y].items);\n    if (nx) {\n        this.addOut(this.cells[x+1][y].items);\n    }\n    if (ny) {\n        this.addOut(this.cells[x][y+1].items);\n    }\n    if (nx && ny) {\n        this.addOut(this.cells[x+1][y+1].items);\n    }\n    return this.out;\n};\n\nexports = module.exports = Grid;\n","module.exports = {\n  Grid: require('./grid'),\n  Cell: require('./cell')\n};\n","module.exports = {\n  Vector2: require('./vector2'),\n  LineSegment2: require('./linesegment2'),\n  Triangle2: require('./triangle2'),\n  Polygon2: require('./polygon2'),\n  RegularPolygon2: require('./regularpolygon2'),\n  gpc: require('./gpc'),\n  VisibilityPolygon: require('./visibilitypolygon'),\n\n  Grid: require('./grid'),\n  QuadTree: require('./quadtree')\n};\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\n\nexports = module.exports = LineSegment2;\n\nvar cache = [];\nvar created = 0;\n\nfunction LineSegment2 (start, end) {\n\tif (!(this instanceof LineSegment2)) {\n\t\tvar l = cache.pop();\n\t\tif (!l) {\n\t\t\tl = new LineSegment2(start, end);\n\t\t\tcreated++;\n\t\t} else {\n\t\t\tl.start.free();\n\t\t\tl.end.free();\n\t\t\tl.set(start, end);\n\t\t}\n\t\treturn l;\n\t}\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n}\n\nLineSegment2.getStats = function() {\n\treturn [cache.length, created];\n};\n\nLineSegment2.prototype.set = function (start, end) {\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n\treturn this;\n};\n\nLineSegment2.prototype.free = function () {\n\tcache.push(this);\n};\n\nLineSegment2.prototype.lengthSq = function () {\n\treturn this.start.distanceSq(this.end);\n};\n\nLineSegment2.prototype.length = function() {\n\treturn this.start.distance(this.end);\n};\n\nLineSegment2.prototype.closestPoint = function (point, full) {\n\tvar l2 = this.lengthSq();\n\tif (l2 === 0) {\n\t\treturn this.start.clone();\n\t}\n\tvar t = ((point.x - this.start.x) * (this.end.x - this.start.x) + (point.y - this.start.y)*(this.end.y - this.start.y)) / l2;\n\tif (!full) {\n\t\tif (t < 0) {\n\t\t\treturn this.start.clone();\n\t\t}\n\t\tif (t > 1) {\n\t\t\treturn this.end.clone();\n\t\t}\n\t}\n\treturn Vector2(this.start.x + t * (this.end.x-this.start.x), this.start.y + t * (this.end.y - this.start.y));\n};\n\nLineSegment2.prototype.distanceSq = function (point, full) {\n\tvar c = this.closestPoint(point, full);\n\tvar d = point.distanceSq(c);\n\tc.free();\n\treturn d;\n};\n\nLineSegment2.prototype.distance = function (point, full) {\n\treturn Math.sqrt(this.distanceSq(point, full));\n};\n\nLineSegment2.prototype.intersect = function (l, full) {\n\tvar u_b = (l.end.y - l.start.y) * (this.end.x - this.start.x) - (l.end.x - l.start.x) * (this.end.y - this.start.y);\n\tif (u_b !== 0) {\n\t\tvar ua_t = (l.end.x - l.start.x) * (this.start.y - l.start.y) - (l.end.y - l.start.y) * (this.start.x - l.start.x);\n\t\tvar ub_t = (this.end.x - this.start.x) * (this.start.y - l.start.y) - (this.end.y - this.start.y) * (this.start.x - l.start.x);\n\t\tvar ua = ua_t / u_b;\n\t\tvar ub = ub_t / u_b;\n\t\tif (full || (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)) {\n\t\t\treturn Vector2(this.start.x - ua * (this.start.x - this.end.x), this.start.y - ua * (this.start.y - this.end.y));\n\t\t}\n\t} else {\n\t\treturn null; // perpendicular\n\t}\n\treturn false;\n};\n\nLineSegment2.prototype.intersectCircle = function (point, radius, full) {\n\tvar r2 = radius*radius;\n\tvar closest = this.closestPoint(point, full);\n\tvar dist_v = point.clone().subtract(closest);\n\tvar len2 = dist_v.distanceSq();\n\tdist_v.free();\n\tif (len2 < r2) {\n\t\treturn closest;\n\t} else {\n\t\tclosest.free();\n\t\treturn false;\n\t}\n};\n\nLineSegment2.prototype.equals = function(other) {\n\treturn (this.start === other.start && this.end === other.end);\n};\n\nLineSegment2.prototype.inverse = function() {\n\treturn LineSegment2(this.end.clone(), this.start.clone());\n};\n\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\nvar LineSegment2 = require('./linesegment2');\nvar epsilon = 0.0000001;\n\nexports = module.exports = Polygon2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Polygon2 (points) {\n    if (!(this instanceof Polygon2)) {\n        var p = cache.pop();\n        if (!p) {\n            p = new Polygon2(points);\n            created++;\n        } else {\n            p.freePoints();\n            p.set(points);\n        }\n        return p;\n    }\n    this.points = points || [];\n}\n\nPolygon2.fromArray = function (points)\n{\n    var p = Polygon2();\n    for (var i = 0;i<points.length; i++) {\n        p.add(Vector2.fromArray(points[i]));\n    }\n    return p;\n};\n\nPolygon2.getStats = function() {\n    return [cache.length, created];\n};\n\nPolygon2.prototype.free = function ()\n{\n    this.freePoints();\n    cache.push(this);\n};\n\nPolygon2.prototype.freePoints = function ()\n{\n    var p = this.points.pop();\n    while (p) {\n        p.free();\n        p = this.points.pop();\n    }\n    return this;\n};\n\nPolygon2.prototype.set = function (points)\n{\n    this.points = points || [];\n    return this;\n};\n\nPolygon2.prototype.add = function (point)\n{\n    this.points.push(point);\n    return this;\n};\n\nPolygon2.prototype.translate = function (vec)\n{\n    for ( var i = 0; i<this.points.length;i++) {\n        this.points[i].add(vec);\n    }\n    return this;\n};\n\nPolygon2.prototype.rotate = function (angle, origin)\n{\n    for (var i = 0; i<this.points.length;i++) {\n        this.points[i].rotate(angle, origin);\n    }\n    return this;\n};\n\nPolygon2.prototype.containsPoint = function (point)\n{\n    var inside = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n\n        var intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n\nPolygon2.prototype.intersectsLine = function (line, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    var intersect = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n        tempLine.start.set(xi, yi);\n        tempLine.end.set(xj, yj);\n        var is = tempLine.intersect(line);\n        if (is) {\n            if (ignorePoints && (this.points[i].isEqualEpsilon(is) || this.points[j].isEqualEpsilon(is) || line.start.isEqualEpsilon(is) || line.end.isEqualEpsilon(is) )) {\n                // special perpendicular test\n                var a = this.points[i].clone().subtract(this.points[j]).normalize();\n                var aa = a.angle();\n                a.copy(line.start).subtract(line.end).normalize();\n                var bb = a.angle();\n                a.free();\n                is.free();\n                if (Math.abs(aa - bb) < epsilon) {\n                    intersect = true;\n                    break;\n                }\n                continue;\n            }\n            is.free();\n            intersect = true;\n            break;\n        }\n    }\n    tempLine.free();\n    return intersect;\n};\n\n\nPolygon2.prototype.intersectsTriangle = function (triangle, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    tempLine.start.copy(triangle.v0);\n    tempLine.end.copy(triangle.v1);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v1);\n    tempLine.end.copy(triangle.v2);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v2);\n    tempLine.end.copy(triangle.v0);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n    return false;\n};\n\nPolygon2.prototype.AABB = function()\n{\n    var min = this.points[0].clone();\n    var max = this.points[0].clone();\n\n    for (var i = 1; i< this.points.length; i++) {\n        var p = this.points[i];\n        if ( p.x < min.x ) {\n            min.x = p.x;\n        } else if ( p.x > max.x ) {\n            max.x = p.x;\n        }\n        if ( p.y < min.y ) {\n            min.y = p.y;\n        } else if ( p.y > max.y ) {\n            max.y = p.y;\n        }\n    }\n    return [min, max];\n};\n\n// negative = CCW\nPolygon2.prototype.winding = function() {\n    return this.area() > 0;\n};\n\nPolygon2.prototype.rewind = function(cw) {\n    cw = !!cw;\n    var winding = this.winding();\n    if (winding !== cw) {\n        this.points.reverse();\n    }\n    return this;\n};\n\nPolygon2.prototype.area = function() {\n    var area = 0;\n    var first = this.points[0];\n    var p1 = Vector2();\n    var p2 = Vector2();\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        p1.copy(first).subtract(this.points[i]);\n        p2.copy(first).subtract(this.points[j]);\n        area += p1.cross(p2);\n    }\n    p1.free();\n    p2.free();\n    return area/2;\n};\n\nPolygon2.prototype.clean = function(distance)\n{\n    var p1 = Vector2();\n    var newpoints = [];\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var length = p1.copy(this.points[i]).subtract(this.points[j]).length();\n        if (length > distance) {\n            newpoints.push(this.points[i]);\n        } else {\n            this.points[i].free();\n        }\n    }\n    this.points = newpoints;\n};\n\nPolygon2.prototype.toArray = function ()\n{\n    var ret = [];\n    for (var i = 0; i< this.points.length; i++) {\n        ret.push(this.points[i].toArray());\n    }\n    return ret;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\nvar PointNode = require('./pointnode');\n\nfunction BoundsNode(bounds, depth, maxChildren, maxDepth) {\n    PointNode.call(this, bounds, depth, maxChildren, maxDepth);\n    this._stuckChildren = [];\n}\n\nBoundsNode.prototype = new PointNode();\nBoundsNode.prototype._classConstructor = BoundsNode;\nBoundsNode.prototype._stuckChildren = null;\n\n//we use this to collect and conctenate items being retrieved. This way\n//we dont have to continuously create new Array instances.\n//Note, when returned from QuadTree.retrieve, we then copy the array\nBoundsNode.prototype._out = [];\n\nBoundsNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        //todo: make _bounds bounds\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            this.nodes[index].insert(item);\n\n        } else {\n            this._stuckChildren.push(item);\n        }\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nBoundsNode.prototype.getChildren = function () {\n    return this.children.concat(this._stuckChildren);\n};\n\nBoundsNode.prototype.retrieve = function (item) {\n    var out = this._out;\n    out.length = 0;\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            out.push.apply(out, this.nodes[index].retrieve(item));\n        } else {\n            //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n            if (item.x <= this.nodes[PointNode.TOP_RIGHT]._bounds.x) {\n                if (item.y <= this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_LEFT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_LEFT].retrieve(item));\n                }\n            }\n\n            if (item.x + item.width > this.nodes[PointNode.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                if (item.y <= this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_RIGHT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_RIGHT].retrieve(item));\n                }\n            }\n        }\n    }\n\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n\n    return out;\n};\n\n//Returns all contents of node.\nBoundsNode.prototype.getAllContent = function () {\n    var out = this._out;\n    if (this.nodes.length) {\n\n        var i;\n        for (i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].getAllContent();\n        }\n    }\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n    return out;\n};\n\nBoundsNode.prototype.clear = function () {\n\n    this._stuckChildren.length = 0;\n\n    //array\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    if (!len) {\n        return;\n    }\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    //array\n    this.nodes.length = 0;\n\n    //we could call the super clear function but for now, im just going to inline it\n    //call the hidden super.clear, and make sure its called with this = this instance\n    //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n};\n\nexports = module.exports = BoundsNode;\n","module.exports = {\n  QuadTree: require('./quadtree'),\n  PointNode: require('./pointnode'),\n  BoundsNode: require('./boundsnode')  \n};\n","'use strict';\n\nfunction PointNode(bounds, depth, maxDepth, maxChildren) {\n    this._bounds = bounds;\n    this.children = [];\n    this.nodes = [];\n\n    if (maxChildren) {\n        this._maxChildren = maxChildren;\n    }\n\n    if (maxDepth) {\n        this._maxDepth = maxDepth;\n    }\n\n    if (depth) {\n        this._depth = depth;\n    }\n}\n\n//subnodes\nPointNode.prototype.nodes = null;\nPointNode.prototype._classConstructor = PointNode;\n\n//children contained directly in the node\nPointNode.prototype.children = null;\nPointNode.prototype._bounds = null;\n\n//read only\nPointNode.prototype._depth = 0;\n\nPointNode.prototype._maxChildren = 4;\nPointNode.prototype._maxDepth = 4;\n\nPointNode.TOP_LEFT = 0;\nPointNode.TOP_RIGHT = 1;\nPointNode.BOTTOM_LEFT = 2;\nPointNode.BOTTOM_RIGHT = 3;\n\n\nPointNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        this.nodes[index].insert(item);\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nPointNode.prototype.retrieve = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        return this.nodes[index].retrieve(item);\n    }\n\n    return this.children;\n};\n\nPointNode.prototype._findIndex = function (item) {\n    var b = this._bounds;\n    var left = (item.x > b.x + b.width / 2) ? false : true;\n    var top = (item.y > b.y + b.height / 2) ? false : true;\n\n    //top left\n    var index = PointNode.TOP_LEFT;\n    if (left) {\n        //left side\n        if (!top) {\n            //bottom left\n            index = PointNode.BOTTOM_LEFT;\n        }\n    } else {\n        //right side\n        if (top) {\n            //top right\n            index = PointNode.TOP_RIGHT;\n        } else {\n            //bottom right\n            index = PointNode.BOTTOM_RIGHT;\n        }\n    }\n\n    return index;\n};\n\n\nPointNode.prototype.subdivide = function () {\n    var depth = this._depth + 1;\n\n    var bx = this._bounds.x;\n    var by = this._bounds.y;\n\n    //floor the values\n    var b_w_h = (this._bounds.width / 2) | 0; //todo: Math.floor?\n    var b_h_h = (this._bounds.height / 2) | 0;\n    var bx_b_w_h = bx + b_w_h;\n    var by_b_h_h = by + b_h_h;\n\n    //top left\n    this.nodes[PointNode.TOP_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //top right\n    this.nodes[PointNode.TOP_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //bottom left\n    this.nodes[PointNode.BOTTOM_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n\n    //bottom right\n    this.nodes[PointNode.BOTTOM_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n};\n\nPointNode.prototype.clear = function () {\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    this.nodes.length = 0;\n};\n\n\nexports = module.exports = PointNode;\n","'use strict';\n\nvar PointNode = require('./pointnode'),\n    BoundsNode = require('./boundsnode');\n\n/**\n* QuadTree data structure.\n* @class QuadTree\n* @constructor\n* @param {Object} An object representing the bounds of the top level of the QuadTree. The object\n* should contain the following properties : x, y, width, height\n* @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds\n* (width / height)(false). Default value is false.\n* @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n* @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n**/\nfunction QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n    var node;\n    if (pointQuad) {\n        node = new PointNode(bounds, 0, maxDepth, maxChildren);\n    } else {\n        node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n    }\n\n    this.root = node;\n}\n\n/**\n* The root node of the QuadTree which covers the entire area being segmented.\n* @property root\n* @type Node\n**/\nQuadTree.prototype.root = null;\n\n\n/**\n* Inserts an item into the QuadTree.\n* @method insert\n* @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y\n* properties that represents its position in 2D space.\n**/\nQuadTree.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            len = item.length;\n        while (i<len) {\n            this.root.insert(item[i]);\n            i++;\n        }\n    } else {\n        this.root.insert(item);\n    }\n};\n\n/**\n* Clears all nodes and children from the QuadTree\n* @method clear\n**/\nQuadTree.prototype.clear = function () {\n    this.root.clear();\n};\n\n/**\n* Retrieves all items / points in the same node as the specified item / point. If the specified item\n* overlaps the bounds of a node, then all children in both nodes will be returned.\n* @method retrieve\n* @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n* with dimensions (x, y, width, height) properties.\n**/\nQuadTree.prototype.retrieve = function (item) {\n    //get a copy of the array of items\n    return this.root.retrieve(item);\n    // var out = this.root.retrieve(item).slice(0);\n    // return out;\n};\n\nexports = module.exports = QuadTree;\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2'),\n    Polygon2 = require('./polygon2');\n\nexports = module.exports = RegularPolygon2;\n\nfunction RegularPolygon2 (radius,sides, center)\n{\n    center = center || Vector2();\n\n    if (!sides || sides < 2) {\n        sides = 3;\n    }\n    if (!radius || radius <= 0) {\n        radius = 1;\n    }\n\n    var p = Polygon2();\n    for ( var i = 0; i < sides; i++) {\n        p.add(Vector2( center.x + radius * Math.cos( (i * 2 * Math.PI / sides) + 0.25*Math.PI), center.y + radius * Math.sin((i * 2 * Math.PI / sides) + 0.25*Math.PI)));\n    }\n    return p;\n}\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nexports = module.exports = Triangle2;\n\nvar epsilon = 0.0000001;\nvar cache = [];\nvar created = 0;\n\nfunction Triangle2 (v0, v1, v2) {\n    if (!(this instanceof Triangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Triangle2(v0, v1, v2);\n            created++;\n        } else {\n            v.set(v0, v1, v2);\n            //v.calcCircumcircle();\n        }\n        return v;\n    }\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    /*\n    this.center = Vector2();\n    this.radius = 0;\n    this.radius_squared = 0;\n\n    this.calcCircumcircle();\n    */\n}\n\nTriangle2.getStats = function() {\n    return [cache.length, created];\n};\n\nTriangle2.prototype.free = function ()\n{\n    cache.push(this);\n};\n\n\nTriangle2.prototype.set = function (v0, v1, v2)\n{\n    this.v0.free();\n    this.v1.free();\n    this.v2.free();\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    return this;\n};\n\nTriangle2.prototype.translate = function (vec)\n{\n    this.v0.add(vec);\n    this.v1.add(vec);\n    this.v2.add(vec);\n    return this;\n};\n\nTriangle2.prototype.calcCircumcircle = function() {\n    // From: http://www.exaflop.org/docs/cgafaq/cga1.html\n\n    var A = this.v1.x - this.v0.x;\n    var B = this.v1.y - this.v0.y;\n    var C = this.v2.x - this.v0.x;\n    var D = this.v2.y - this.v0.y;\n\n    var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);\n    var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);\n\n    var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));\n\n    var dx, dy;\n\n    if (Math.abs(G) < epsilon) {\n        // Collinear - find extremes and use the midpoint\n\n        var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);\n        var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);\n        var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);\n        var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);\n\n        this.center.set((minx + maxx) / 2, (miny + maxy) / 2);\n\n        dx = this.center.x - minx;\n        dy = this.center.y - miny;\n    } else {\n        var cx = (D * E - B * F) / G;\n        var cy = (A * F - C * E) / G;\n\n        this.center.set(cx, cy);\n\n        dx = this.center.x - this.v0.x;\n        dy = this.center.y - this.v0.y;\n    }\n\n    this.radius_squared = dx * dx + dy * dy;\n    this.radius = Math.sqrt(this.radius_squared);\n};\n\nTriangle2.prototype.inCircumcircle = function(v) {\n    var dx = this.center.x - v.x;\n    var dy = this.center.y - v.y;\n    var dist_squared = dx * dx + dy * dy;\n\n    return (dist_squared <= this.radius_squared);\n};\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\nexports = module.exports = Vector2;\n\nvar epsilon = 0.0000001;\nvar degrees = 180 / Math.PI;\n\nvar cache = [];\nvar created = 0;\n\nfunction Vector2 (x, y) {\n    if (!(this instanceof Vector2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Vector2(x || 0, y || 0);\n            created++;\n        } else {\n            v.set(x, y);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n}\n\nVector2.getStats = function() {\n    return [cache.length, created];\n};\n\nVector2.fromArray = function (arr) {\n    return Vector2(arr[0] || 0, arr[1] || 0);\n};\n\nVector2.fromObject = function (obj) {\n    return Vector2(obj.x || 0, obj.y || 0);\n};\n\nVector2.prototype.set = function (x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n};\n\nVector2.prototype.free = function () {\n    cache.push(this);\n};\n\nVector2.prototype.add = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nVector2.prototype.addScalar = function (scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    return this;\n};\n\n\nVector2.prototype.subtract = function (vec) {\n    this.x -= vec.x;\n    this.y -= vec.y;\n    return this;\n};\n\nVector2.prototype.subtractScalar = function (scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n};\n\n\nVector2.prototype.divide = function (vec) {\n    this.x /= vec.x;\n    this.y /= vec.y;\n    return this;\n};\n\nVector2.prototype.multiply = function (vec) {\n    this.x *= vec.x;\n    this.y *= vec.y;\n    return this;\n};\n\nVector2.prototype.multiplyScalar = function (scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n};\n\nVector2.prototype.normalize = function () {\n    var length = this.length();\n\n    if (length === 0) {\n        this.x = 0;\n        this.y = 0;\n    } else {\n        this.x /= length;\n        this.y /= length;\n    }\n    return this;\n};\n\nVector2.prototype.clone = function () {\n    return Vector2(this.x, this.y);\n};\n\nVector2.prototype.copy = function (vec) {\n    this.x = vec.x;\n    this.y = vec.y;\n    return this;\n};\n\nVector2.prototype.zero = function () {\n    this.x = this.y = 0;\n    return this;\n};\n\nVector2.prototype.dot = function (vec) {\n    return this.x * vec.x + this.y * vec.y;\n};\n\nVector2.prototype.cross = function (vec) {\n    return (this.x * vec.y ) - (this.y * vec.x );\n};\n\nVector2.prototype.projectOnto = function (vec) {\n    var coeff = ( (this.x * vec.x)+(this.y * vec.y) ) / ((vec.x*vec.x)+(vec.y*vec.y));\n    this.x = coeff * vec.x;\n    this.y = coeff * vec.y;\n    return this;\n};\n\n\nVector2.prototype.horizontalAngle = function () {\n    return Math.atan2(this.y, this.x);\n};\n\nVector2.prototype.horizontalAngleDeg = function () {\n    return radian2degrees(this.horizontalAngle());\n};\n\nVector2.prototype.verticalAngle = function () {\n    return Math.atan2(this.x, this.y);\n};\n\nVector2.prototype.verticalAngleDeg = function () {\n    return radian2degrees(this.verticalAngle());\n};\n\nVector2.prototype.angle = Vector2.prototype.horizontalAngle;\nVector2.prototype.angleDeg = Vector2.prototype.horizontalAngleDeg;\nVector2.prototype.direction = Vector2.prototype.horizontalAngle;\n\nVector2.prototype.rotate = function (angle, origin) {\n    var ox = 0,\n        oy = 0;\n    if (origin) {\n        ox = origin.x || 0;\n        oy = origin.y || 0;\n    }\n\n    var nx = ox + (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));\n    var ny = oy + (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));\n\n    this.x = nx;\n    this.y = ny;\n\n    return this;\n};\n\nVector2.prototype.rotateDeg = function (angle) {\n    angle = degrees2radian(angle);\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateBy = function (rotation) {\n    var angle = this.angle() + rotation;\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateByDeg = function (rotation) {\n    rotation = degrees2radian(rotation);\n    return this.rotateBy(rotation);\n};\n\nVector2.prototype.distance = function (vec) {\n    return Math.sqrt(this.distanceSq(vec));\n};\n\nVector2.prototype.distanceSq = function (vec) {\n    var dx = this.x - vec.x,\n    dy = this.y - vec.y;\n    return dx * dx + dy * dy;\n};\n\nVector2.prototype.length = function () {\n    return Math.sqrt(this.lengthSq());\n};\n\nVector2.prototype.lengthSq = function () {\n    return this.x * this.x + this.y * this.y;\n};\n\nVector2.prototype.magnitude = Vector2.prototype.length;\n\nVector2.prototype.isZero = function() {\n    return this.x === 0 && this.y === 0;\n};\nVector2.prototype.isEqualTo = function(vec) {\n    return this.x === vec.x && this.y === vec.y;\n};\n\nVector2.prototype.isEqualEpsilon = function(vec) {\n    return Math.abs(this.x - vec.x) < epsilon && Math.abs(this.y - vec.y) < epsilon;\n};\n\nVector2.prototype.toString = function () {\n    return 'x: ' + this.x + ', y: ' + this.y;\n};\n\nVector2.prototype.toArray = function () {\n    return [ this.x, this.y ];\n};\n\nVector2.prototype.toObject = function () {\n    return { x: this.x, y: this.y };\n};\n\nfunction radian2degrees (rad) {\n    return rad * degrees;\n}\n\nfunction degrees2radian (deg) {\n    return deg / degrees;\n}\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\n/*\n    Based upon https://code.google.com/p/visibility-polygon-js/\n    Made by Byron Knoll in 2013/2014.\n*/\n\nvar Polygon2 = require('./polygon2'),\n    Vector2 = require('./vector2'),\n    LineSegment2 = require('./linesegment2');\n\nvar PI = Math.PI;\nvar PI2 = PI*2;\nvar PImin = -1*PI;\nvar epsilon = 0.0000001;\n\nvar segmentIter = ['start', 'end'];\nfunction pointsorter(a,b) {\n    return a[2] - b[2];\n}\n\nfunction VisibilityPolygon(segments)\n{\n    this.polygon = Polygon2();\n    this.segments = segments;\n    this.heap = [];\n    this.map = new Array(this.segments.length);\n    this.points = new Array(this.segments.length * 2);\n    this.position = Vector2();\n}\n\nVisibilityPolygon.prototype.angle = function (p1, p2)\n{\n    var p = p2.clone().subtract(p1);\n    var a = p.angle();\n    p.free();\n    return a;\n};\n\nVisibilityPolygon.prototype.angle2 = function (a, b, c) {\n    var a1 = this.angle(a, b);\n    var a2 = this.angle(b, c);\n    var a3 = a1 - a2;\n    if (a3 < 0) { a3 += PI2; }\n    if (a3 > PI2) { a3 -= PI2; }\n    return a3;\n};\n\n\nVisibilityPolygon.prototype.compute = function (position)\n{\n    this.position.copy(position);\n    this.reset();\n    this.sortPoints();\n\n    var start = this.position.clone();\n    start.x +=1; // why?\n\n    var i = 0,\n        n = this.segments.length;\n    while (i < n) {\n        var a1 = this.angle(this.segments[i].start, this.position);\n        var a2 = this.angle(this.segments[i].end, this.position);\n        if (\n            ( a1 > PImin && a1 <= 0 && a2 <= PI && a2 >= 0 && a2 - a1 > PI) ||\n            (a2 > PImin && a2 <= 0 && a1 <= PI && a1 >= 0 && a1 - a2 > PI)\n        ) {\n            this.insert(i, start);\n        }\n        i += 1;\n    }\n    i = 0;\n    n = this.segments.length*2;\n    while (i < n) {\n        var extend = false;\n        var shorten = false;\n        var orig = i;\n        var vertex = this.segments[this.points[i][0]][this.points[i][1]];\n        var old_segment = this.heap[0];\n        do {\n            if (this.map[this.points[i][0]] !== -1) {\n                if (this.points[i][0] === old_segment) {\n                    extend = true;\n                    vertex = this.segments[this.points[i][0]][this.points[i][1]];\n                }\n                this.remove(this.map[this.points[i][0]], vertex);\n            } else {\n                this.insert(this.points[i][0], vertex);\n                if (this.heap[0] !== old_segment) {\n                    shorten = true;\n                }\n            }\n            ++i;\n            if (i === n) { break; }\n        } while (this.points[i][2] < this.points[orig][2] + epsilon);\n\n        var l = LineSegment2(position.clone(), vertex.clone());\n        if (extend) {\n            this.polygon.add(vertex.clone());\n            var cur = this.segments[this.heap[0]].intersect(l, true);\n            if (cur ) {\n                if (!cur.isEqualEpsilon(vertex)) {\n                    this.polygon.add(cur);\n                } else {\n                    cur.free();\n                }\n            }\n        } else if (shorten) {\n            this.polygon.add(this.segments[old_segment].intersect(l, true));\n            this.polygon.add(this.segments[this.heap[0]].intersect(l, true));\n        }\n    }\n    return this.polygon;\n};\n\n\nVisibilityPolygon.prototype.insert = function (index, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var intersect = this.segments[index].intersect(l, true);\n    if (intersect === false) {\n        l.free();\n        return;\n    }\n    intersect.free();\n\n    var cur = this.heap.length;\n    this.heap.push(index);\n    this.map[index] = cur;\n    while (cur > 0) {\n        var parent = this.parent(cur);\n        if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n            break;\n        }\n        this.map[this.heap[parent]] = cur;\n        this.map[this.heap[cur]] = parent;\n        var temp = this.heap[cur];\n        this.heap[cur] = this.heap[parent];\n        this.heap[parent] = temp;\n        cur = parent;\n    }\n};\n\nVisibilityPolygon.prototype.remove = function (index, destination) {\n    this.map[this.heap[index]] = -1;\n    if (index === this.heap.length - 1) {\n        this.heap.pop();\n        return;\n    }\n    this.heap[index] = this.heap.pop();\n    this.map[this.heap[index]] = index;\n    var cur = index;\n    var parent = this.parent(cur);\n    if (cur !== 0 && this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n        while (cur > 0) {\n            parent = this.parent(cur);\n            if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n                break;\n            }\n            this.swap(cur, parent);\n            cur = parent;\n        }\n    } else {\n        while (true) {\n            var left = this.child(cur);\n            var right = left + 1;\n            if (left < this.heap.length && this.lessThan(this.heap[left], this.heap[cur], destination) &&\n                (right === this.heap.length || this.lessThan(this.heap[left], this.heap[right], destination))) {\n                    this.swap(cur, left);\n                    cur = left;\n                } else if (right < this.heap.length && this.lessThan(this.heap[right], this.heap[cur], destination)) {\n                    this.swap(cur, right);\n                    cur = right;\n                } else {\n                    break;\n                }\n            }\n        }\n    };\n\n\n\nVisibilityPolygon.prototype.lessThan = function (index1, index2, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var inter1 = this.segments[index1].intersect(l, true);\n    var inter2 = this.segments[index2].intersect(l, true);\n    if (!inter1.isEqualEpsilon(inter2)) {\n        var d1 = inter1.distanceSq(this.position);\n        var d2 = inter2.distanceSq(this.position);\n        inter1.free();\n        inter2.free();\n        l.free();\n        return d1 < d2;\n    }\n    var end1 = this.segments[index1].start;\n    if (inter1.isEqualEpsilon(this.segments[index1].start)) {\n        end1 = this.segments[index1].end;\n    }\n    var end2 = this.segments[index2].start;\n    if (inter2.isEqualEpsiolon(this.segments[index2].start)) {\n        end2 = this.segments[index2].end;\n    }\n    var a1 = this.angle2(end1, inter1, this.position);\n    var a2 = this.angle2(end2, inter2, this.position);\n    inter1.free();\n    inter2.free();\n    if (a1 < PI) {\n        if (a2 > PI) {\n            return true;\n        }\n        return a2 < a1;\n    }\n    return a1 < a2;\n};\n\nVisibilityPolygon.prototype.parent = function (index) {\n    return Math.floor((index - 1) / 2);\n};\n\nVisibilityPolygon.prototype.child = function (index) {\n    return 2 * index + 1;\n};\n\nVisibilityPolygon.prototype.swap = function (c, l) {\n    this.map[this.heap[l]] = c;\n    this.map[this.heap[c]] = l;\n    var temp = this.heap[l];\n    this.heap[l] = this.heap[c];\n    this.heap[c] = temp;\n};\n\n\nVisibilityPolygon.prototype.sortPoints = function ()\n{\n    var i = 0,\n    n = this.segments.length,\n    p = null,\n    pp = Vector2();\n    while (i < n) {\n        for (var j = 0; j < 2; ++j) {\n            if (j === 0) {\n                p = this.segments[i][segmentIter[j]];\n            } else {\n                p = this.segments[i][segmentIter[j]];\n            }\n            pp.copy(this.position).subtract(p);\n            var nr = 2 * i + j;\n            if (this.points[nr]) {\n                this.points[nr][0] = i;\n                this.points[nr][1] = segmentIter[j];\n                this.points[nr][2] = pp.angle();\n            } else {\n                this.points[nr] = [i, segmentIter[j], pp.angle()];\n            }\n        }\n        i += 1;\n    }\n    pp.free();\n    this.points = this.points.sort(pointsorter);\n};\n\nVisibilityPolygon.prototype.reset = function ()\n{\n    this.polygon.freePoints();\n    var i = 0,\n    n = this.map.length;\n    while (i < n) {\n        this.map[i] = -1;\n        i += 1;\n    }\n    while (this.heap.length > 0) {\n        this.heap.pop();\n    }\n};\n/* jshint +W064 */\n","var core = {};\n\n\ncore.geometry = require('./geometry');\ncore.linkedlist = require('./linkedlist');\ncore.procedural = require('./procedural');\ncore.timer = require('./timer');\ncore.input = require('./input');\ncore.game = require('./game');\n\nmodule.exports = core;\n\nglobal.ULTRON = core;\n","module.exports = {\n  Unified: require('./unified')\n};\n","//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\n// taken from game-shell\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif ( window.addEventListener ) {\n  _addEventListener = \"addEventListener\";\n} else {\n  _addEventListener = \"attachEvent\";\n  prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\n  elem[ _addEventListener ]( prefix + eventName, support === \"wheel\" ? callback : function( originalEvent ) {\n    !originalEvent && ( originalEvent = window.event );\n\n    // create a normalized event object\n    var event = {\n      // keep a ref to the original event object\n      originalEvent: originalEvent,\n      target: originalEvent.target || originalEvent.srcElement,\n      type: \"wheel\",\n      deltaMode: originalEvent.type === \"MozMousePixelScroll\" ? 0 : 1,\n      deltaX: 0,\n      delatZ: 0,\n      preventDefault: function() {\n        originalEvent.preventDefault ?\n          originalEvent.preventDefault() :\n          originalEvent.returnValue = false;\n      }\n    };\n\n    // calculate deltaY (and deltaX) according to the event\n    if ( support === \"mousewheel\" ) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n      // Webkit also support wheelDeltaX\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n    } else {\n      event.deltaY = originalEvent.detail;\n    }\n\n    // it's time to fire the callback\n    return callback( event );\n  }, useCapture || false );\n}\n\nmodule.exports = function( elem, callback, useCapture ) {\n  _addWheelListener( elem, support, callback, useCapture );\n\n  // handle MozMousePixelScroll in older Firefox\n  if( support === \"DOMMouseScroll\" ) {\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\n  }\n};\n","'use strict';\n\n// taken from https://github.com/andyhall/game-inputs\n\nvar vkey = require('vkey');\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\nvar EventEmitter = require('eventemitter3');\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = require('./mousewheel-polyfill');\n\nmodule.exports = Inputs;\n\n// map button index to name\nvar gamepadButtonNames = [\n    'a',\n    'b',\n    'x',\n    'y',\n    'left-shoulder',\n    'right-shoulder',\n    'left-trigger',\n    'right-trigger',\n    'select',\n    'start',\n    'left-stick',\n    'right-stick',\n    'dpad-up',\n    'dpad-down',\n    'dpad-left',\n    'dpad-right'\n];\nvar gamepadAxesNames = [\n    'left-stick-x',\n    'left-stick-y',\n    'right-stick-x',\n    'right-stick-y'\n];\nvar hasGamepadEvents = 'GamepadEvent' in window;\n\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from)\n *        game-shell: https://github.com/mikolalysenko/game-shell\n *\n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *\n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n*/\n\n\nfunction Inputs(element, opts) {\n\n  // settings\n  this.element = element || document;\n  opts = opts || {};\n  this.preventDefaults = !!opts.preventDefaults;\n  this.stopPropagation = !!opts.stopPropagation;\n\n  // emitters\n  this.down = new EventEmitter();\n  this.up = new EventEmitter();\n  this.gamepadconnected = new EventEmitter();\n  this.gamepaddisconnected = new EventEmitter();\n\n  // state object to be queried\n  this.state = {\n    dx: 0, dy: 0,\n    scrollx: 0, scrolly: 0, scrollz: 0\n  };\n\n  // internal state\n  this._keybindmap = {};       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n  this._keyStates = {};        // { 'vkeycode' : boolean }\n  this._bindPressCounts = {};  // { 'binding' : int }\n  this._gamepads = {}; // { 'index' : gamepad }\n  this._gamepadButtonStates = {}; // { 'vcode' : int }\n\n  // raf handle\n  this._gamepadRaf = false;\n\n  // register for dom events\n  this.initEvents();\n}\n\n\n/*\n *\n *   PUBLIC API\n *\n*/\n\nInputs.prototype.initEvents = function() {\n  // keys\n  window.addEventListener( 'keydown', onKeyEvent.bind(undefined,this,true), false );\n  window.addEventListener( 'keyup', onKeyEvent.bind(undefined,this,false), false );\n  // mouse buttons\n  this.element.addEventListener('mousedown', onMouseEvent.bind(undefined,this,true), false);\n  this.element.addEventListener('mouseup', onMouseEvent.bind(undefined,this,false), false);\n  this.element.oncontextmenu = onContextMenu.bind(undefined,this);\n  // mouse other\n  this.element.addEventListener('mousemove', onMouseMove.bind(undefined,this), false);\n  addMouseWheel(this.element, onMouseWheel.bind(undefined,this), false);\n\n  // gamepads\n  if ( hasGamepadEvents ) {\n      window.addEventListener('gamepadconnected', onGamepadConnected.bind(undefined,this), false);\n      window.addEventListener('gamepaddisconnected', onGamepadDisconnected.bind(undefined,this), false);\n  } else {\n      window.setInterval(scanGamepads.bind(undefined, this), 500);\n  }\n};\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function(binding) {\n  for (var i=1; i<arguments.length; ++i) {\n    var vkeyCode = arguments[i];\n    var arr = this._keybindmap[vkeyCode] || [];\n    if (arr.indexOf(binding) === -1) {\n      arr.push(binding);\n    }\n    this._keybindmap[vkeyCode] = arr;\n  }\n  this.state[binding] = !!this.state[binding];\n};\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function(binding) {\n  for (var b in this._keybindmap) {\n    var arr = this._keybindmap[b];\n    var i = arr.indexOf(binding);\n    if (i>-1) { arr.splice(i,1); }\n  }\n};\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function() {\n  this.state['mouse-dx'] = this.state['mouse-dy'] = 0;\n  this.state['mouse-scrollx'] = this.state['mouse-scrolly'] = this.state['mouse-scrollz'] = 0;\n};\n\n\n\nInputs.prototype.getBoundKeys = function() {\n  var arr = [];\n  for (var b in this._keybindmap) { arr.push(b); }\n  return arr;\n};\n\n\n/*\n *   INTERNALS - DOM EVENT HANDLERS\n*/\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n  handleKeyEvent( ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev );\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n  // simulate a code out of range of vkey\n  var keycode = -1 - ev.button;\n  var vkeycode = '<mouse '+ (ev.button+1) +'>';\n  handleKeyEvent( keycode, vkeycode, wasDown, inputs, ev );\n  return false;\n}\n\nfunction onContextMenu(inputs) {\n  // cancel context menu if there's a binding for right mousebutton\n  var arr = inputs._keybindmap['<mouse 3>'];\n  if (arr) { return false; }\n}\n\nfunction onMouseMove(inputs, ev) {\n  // for now, just populate the state object with mouse movement\n  var dx = ev.movementX || ev.mozMovementX || ev.webkitMovementX || 0,\n      dy = ev.movementY || ev.mozMovementY || ev.webkitMovementY || 0;\n  inputs.state['mouse-dx'] += dx;\n  inputs.state['mouse-dy'] += dy;\n  // TODO: verify if this is working/useful during pointerlock?\n}\n\nfunction onMouseWheel(inputs, ev) {\n  // basically borrowed from game-shell\n  var scale = 1;\n  switch(ev.deltaMode) {\n    case 0: scale=1;   break;  // Pixel\n    case 1: scale=12;  break;  // Line\n    case 2:  // page\n      // TODO: investigagte when this happens, what correct handling is\n      scale = inputs.element.clientHeight || window.innerHeight;\n      break;\n  }\n  // accumulate state\n  inputs.state['mouse-scrollx'] += ev.deltaX * scale;\n  inputs.state['mouse-scrolly'] += ev.deltaY * scale;\n  inputs.state['mouse-scrollz'] += (ev.deltaZ * scale) || 0;\n  return false;\n}\n\n\n/*\n *   KEY BIND HANDLING\n*/\n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n  var arr = inputs._keybindmap[vcode];\n  // don't prevent defaults if there's no binding\n  if (!arr) { return; }\n  if (inputs.preventDefaults) { ev.preventDefault(); }\n  if (inputs.stopPropagation) { ev.stopPropagation(); }\n\n  // if the key's state has changed, handle an event for all bindings\n  var currstate = inputs._keyStates[keycode];\n  if ( XOR(currstate, wasDown) ) {\n    // for each binding: emit an event, and update cached state information\n    for (var i=0; i<arr.length; ++i) {\n      handleBindingEvent( arr[i], wasDown, inputs, ev );\n    }\n  }\n  inputs._keyStates[keycode] = wasDown;\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n  // keep count of presses mapped by binding\n  // (to handle two keys with the same binding pressed at once)\n  var ct = inputs._bindPressCounts[binding] || 0;\n  ct += wasDown ? 1 : -1;\n  if (ct<0) { ct = 0; } // shouldn't happen\n  inputs._bindPressCounts[binding] = ct;\n\n  // emit event if binding's state has changed\n  var currstate = inputs.state[binding];\n  if ( XOR(currstate, ct) ) {\n    var emitter = wasDown ? inputs.down : inputs.up;\n    emitter.emit(binding, binding, ev);\n  }\n  inputs.state[binding] = !!ct;\n}\n\n/**\nGamepad HANDLERS\n*/\n\nfunction handleGamePadButtonEvent(val, vcode, inputs) {\n    var arr = inputs._keybindmap[vcode];\n    if (!arr) { return; }\n\n    var pressed = val === 1.0;\n    var isPerc = false;\n    if (typeof(val) === 'object') {\n        pressed = val.pressed;\n        val = val.value;\n        isPerc = true;\n        inputs.state[vcode] = val;\n    } else {\n        var currstate = inputs._buttonStates[vcode];\n        if (XOR(currstate, val)) {\n            var i = 0;\n            for (i=0; i<arr.length; ++i) {\n                handleBindingEvent( arr[i], pressed, inputs, null); // pass null as fake event\n            }\n        }\n    }\n}\n\nfunction updateGamepads(inputs) {\n    var found = scanGamepads(inputs);\n    if (!found) {\n        if (inputs._gamepadRaf) {\n            cancel(inputs._gamepadRaf);\n            inputs._gamepadRaf = false;\n        }\n        return;\n    }\n\n    var vcode = '';\n    for (var j in inputs._gamepads) {\n        var gamepad = inputs._gamepads[j];\n\n        for (var i=0;i<gamepad.buttons.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadButtonNames[i] + '>';\n            handleGamePadButtonEvent(gamepad.buttons[i], vcode, inputs);\n        }\n\n        for (i=0;i<gamepad.axes.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadAxesNames[i] + '>';\n            inputs.state[vcode] = gamepad.axes[i];\n        }\n    }\n    inputs._gamepadRaf = request(updateGamepads);\n}\n\nfunction onGamepadConnected(inputs, ev) {\n    addGamepad(inputs, ev.gamepad);\n}\n\nfunction onGamepadDisconnected(inputs, ev) {\n    removeGamepad(inputs, ev.gamepad);\n}\n\n\nfunction addGamepad(inputs, gamepad) {\n    inputs._gamepads[gamepad.index] = gamepad;\n    inputs.gamepadconnected.emit(gamepad);\n    if (!inputs._gamepadRaf) {\n        inputs._gamepadRaf = request(updateGamepads);\n    }\n}\n\nfunction removeGamepad(inputs, gamepad) {\n    delete inputs._gamepads[gamepad.index];\n    inputs.gamepaddisconnected.emit(gamepad);\n    for (var j in inputs._gamepads) {\n        if (inputs._gamepads.hasOwnProperty(j)) {\n            return;\n        }\n    }\n    if (inputs._gamepadRaf) {\n        cancel(inputs._gamepadRaf);\n        inputs._gamepadRaf = false;\n    }\n}\n\n\nfunction scanGamepads(inputs) {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n    var found = false;\n    for (var i = 0; i < gamepads.length; i++) {\n        if (gamepads[i]) {\n            found = true;\n            if (!(gamepads[i].index in inputs._gamepads)) {\n                addGamepad(inputs, gamepads[i]);\n            } else {\n                inputs._gamepads[gamepads[i].index] = gamepads[i];\n            }\n        }\n    }\n    return found;\n}\n\n/*\n *    HELPERS\n *\n*/\n\n\n// how is this not part of Javascript?\nfunction XOR(a,b) {\n  return a ? !b : b;\n}\n","/*\n * Doubly Linked List implementation in JavaScript\n * Copyright (c) 2009 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n /*\n  * Optimizations and data reuse by Wouter Commandeur\n */\n\n'use strict';\n\n/**\n * A linked list implementation in JavaScript.\n * @class DoublyLinkedList\n * @constructor\n */\nfunction DoublyLinkedList() {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    this._head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    this._tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type int\n     * @private\n     */\n    this._length = 0;\n\n    this._nodeCache = [];\n\n}\n\nDoublyLinkedList.prototype = {\n\n    //restore constructor\n    constructor: DoublyLinkedList,\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {variant} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    add: function (data) {\n        //create a new item object, place data in\n        var node = this._allocate(data);\n\n        //special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n        } else {\n            //attach to the tail node\n            this._tail.next = node;\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        //don't forget to update the count\n        this._length++;\n\n    },\n\n\n    set: function(index, data) {\n        // update data at index\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            current.data = data;\n        }\n    },\n\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {int} index The zero-based index of the item whose value\n     *      should be returned.\n     * @return {variant} The value in the \"data\" portion of the given item\n     *      or null if the item doesn't exist.\n     * @method item\n     */\n    item: function(index){\n\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            return current.data;\n        } else {\n            return null;\n        }\n    },\n\n    pop: function() {\n        return this.remove(this._length -1);\n    },\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {variant} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    remove: function(index){\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n\n            var current = this._head,\n                i = 0;\n\n            //special case: removing first item\n            if (index === 0){\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head){\n                    this._tail = null;\n                } else {\n                    this._head.prev = null;\n                }\n\n            //special case: removing last item\n            } else if (index === this._length -1){\n                current = this._tail;\n                this._tail = current.prev;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while(i++ < index){\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.prev.next = current.next;\n            }\n\n            //decrement the length\n            this._length--;\n\n            // release into object pool\n            this._free(current);\n\n            //return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    },\n\n    clear: function() {\n        while (this._length > 0) {\n            this.remove(0);\n        }\n    },\n\n   /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    size: function(){\n        return this._length;\n    },\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    toArray: function(){\n        var result = [],\n            current = this._head;\n\n        while(current){\n            result.push(current.data);\n            current = current.next;\n        }\n\n        return result;\n    },\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    toString: function(){\n        return this.toArray().toString();\n    },\n\n    _free: function(node) {\n        this._nodeCache.push(node);\n    },\n\n    _allocate: function(data) {\n        var node = this._nodeCache.pop();\n        if (!node) {\n            node = {};\n        }\n        node.data = data;\n        node.prev = null;\n        node.next = null;\n        return node;\n    }\n};\n\nexports = module.exports = DoublyLinkedList;\n","module.exports = {\n  DoublyLinkedList: require('./doublylinkedlist')\n};\n","'use strict';\n\n/* jshint -W064 */\nvar RegularPolygon2 = require('../geometry/regularpolygon2');\nvar Polygon2 = require('../geometry/polygon2');\nvar Vector2 = require('../geometry/vector2');\nvar LineSegment2 = require('../geometry/linesegment2');\nvar gpc = require('../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('./graph');\n\nexports = module.exports = Building;\n\nvar createPoly = function(points) {\n\tvar res  = new gpc.geometry.PolyDefault();\n\tfor(var i=0 ; i < points.length ; i++) {\n\t\tres.addPoint(new gpc.geometry.Point(points[i][0],points[i][1]));\n\t}\n\treturn res;\n};\n\nvar getPolygonVertices = function(poly) {\n\tvar vertices=[];\n\tvar numPoints = poly.getNumPoints();\n\tvar i;\n\n\tfor(i=0;i<numPoints;i++) {\n\t\tvertices.push([poly.getX(i) , poly.getY(i)]);\n\t}\n\treturn vertices;\n};\n\nfunction Building( chance, iterations, minRadius, maxRadius, maxSides, noRotate)\n{\n\tvar end, l;\n\tthis.centers = [];\n\titerations = iterations || 1;\n//\tif ( iterations < 3 ) {\n//\t\titerations = 3;\n//\t}\n\tmaxSides = maxSides || 6;\n\tif ( maxSides < 4 ) {\n\t\tmaxSides = 4;\n\t}\n\tvar sidesChanceObj = { min: 4, max: maxSides };\n\tvar radiusChanceObj = { min: minRadius, max: maxRadius };\n\n\tvar sides = chance.integer(sidesChanceObj);\n\tvar polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\tvar gpcPoly = createPoly(polygon.toArray());\n\tpolygon.free();\n\tvar vec, gpcPoly2, num;\n\tthis.centers.push(Vector2());\n\n\tfor (var i = 1; i < iterations;i++) {\n\t\t// new random polygon\n\t\tsides = chance.integer(sidesChanceObj);\n\t\tpolygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\n\t\t// rotate random\n\t\tif (!noRotate) {\n\t\t\tpolygon.rotate(chance.floating({min: 0, max: 2 * Math.PI / sides}));\n\t\t}\n\n\t\t// random point on prev poly\n\t\tnum = chance.integer({min: 0, max:gpcPoly.getNumPoints()-1});\n\t\tvec = Vector2(gpcPoly.getX(num), gpcPoly.getY(num));\n\t\tthis.centers.push(vec);\n\n\t\t// center the polygon on a random point of the previous polygon\n\t\tpolygon.translate(vec);\n\t\tgpcPoly2 = createPoly(polygon.toArray());\n\t\tgpcPoly = gpcPoly.union(gpcPoly2);\n\n\t\t// free our stuff for reuse\n\t\tpolygon.free();\n\t}\n\tvar arr = getPolygonVertices(gpcPoly);\n\n\t// generate final polygon\n\tpolygon = Polygon2.fromArray(arr);\n\tthis.polygon = polygon;\n\n\t// this.polygon.clean(30);\n\n\t// add outer doors\n\tvar nrdoors = Math.ceil(iterations/2);\n\tthis.doors = [];\n\n\tvar nr;\n\tvar dooredges = {};\n\tfor ( i=0;i<nrdoors;i++) {\n\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\twhile (dooredges[nr]) {\n\t\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\t}\n\t\tdooredges[nr] = true;\n\t\tend = nr + 1;\n\t\tif (end === this.polygon.points.length) {\n\t\t\tend = 0;\n\t\t}\n\t\tl = LineSegment2(this.polygon.points[nr].clone(), this.polygon.points[end].clone());\n\t\tvar p2 = l.end.clone();\n\t\tvar p1 = l.start.clone();\n\t\tvar length = l.length(); // p2.subtract(l.start).length();\n\t\tp2.subtract(l.start).normalize().multiplyScalar(length/2);\n\t\tp1.add(p2);\n\t\t// this.centers.push(p1);\n\t\tthis.doors.push(p1);\n\t\tp2.free();\n\t\tl.free();\n\t}\n\n\n\n\tvar c = [];\n\tfor (i = 0; i < this.centers.length; i++) {\n\t\tc.push(this.centers[i].toArray());\n\t}\n\n\tthis.graph = new Graph();\n\tthis.delaunay_used = {};\n\n\t// delaunay the centers\n\tthis.delaunay = Delaunay.triangulate(c);\n\n\tfor (i = 0; i < this.delaunay.length; i += 1) {\n\t\tif (!this.delaunay_used[this.delaunay[i]]) {\n\t\t\tthis.graph.addNode(this.delaunay[i]);\n\t\t\tthis.delaunay_used[this.delaunay[i]] = true;\n\t\t}\n\t}\n\n\n\tthis.delaunay_exists = {};\n\n\tthis.delaunay_triangles = [];\n\tthis.delaunay_lines = [];\n\tfor (i = 0; i < this.delaunay.length; i += 3) {\n\t\t// line 1\n\t\tthis.addDelaunayLine(i, i+1);\n\t\tthis.addDelaunayLine(i+1, i+2);\n\t\tthis.addDelaunayLine(i+2, i);\n\t}\n\n\t// connect the doors;\n\tnr = this.centers.length;\n\tfor (i = 0; i < this.doors.length; i++) {\n\t\tthis.connectDoor(this.doors[i], nr);\n\t}\n\n\n\n\t// calculate the minimal spanning tree\n\tvar edges = this.graph.prim(); // Prim(this.graph);\n\t// console.log(edges);\n\tthis.mst_lines = [];\n\n\tfor (i = 0; i < edges.length; i ++) {\n\t\tvar start = edges[i].source;\n\t\tend = edges[i].sink;\n\t\tl = LineSegment2(this.centers[start].clone(), this.centers[end].clone());\n\t\tthis.mst_lines.push(l);\n\t\t//var l = LineSegment2()\n\t}\n\n\n\tthis.outside = this.polygon.AABB();\n\n\tthis.outside[0].subtractScalar(50);\n\tthis.outside[1].addScalar(50);\n\n}\n\nBuilding.prototype.connectDoor = function(door, nr)\n{\n\tvar min = 9999999;\n\tvar l,d;\n\tvar point = false;\n\tfor (var i= 0;i<nr;i++) {\n\t\tl = LineSegment2(this.centers[i].clone(), door.clone());\n\t\tif (!this.polygon.intersectsLine(l, true)) {\n\t\t\td = l.length();\n\t\t\tif ( d < min ) {\n\t\t\t\tmin = d;\n\t\t\t\tpoint = i;\n\t\t\t}\n\t\t}\n\t\tl.free();\n\t}\n\tif (point !== false) {\n\t\tthis.centers.push(door.clone());\n\t\tthis.graph.addNode(this.centers.length - 1);\n\t\tthis.graph.addEdge(point, this.centers.length - 1, min);\n\t\tthis.delaunay_lines.push(LineSegment2(this.centers[point].clone(), door.clone()));\n\t} else {\n\t\tl.free();\n\t}\n\n};\n\nBuilding.prototype.addDelaunayLine = function(start, end)\n{\n\tvar key1 = start + ':' + end;\n\tvar key2 = end + ':' + start;\n\tif (this.delaunay_exists[key1] || this.delaunay_exists[key2]) {\n\t\treturn;\n\t}\n\tthis.delaunay_exists[key1] = true;\n\tthis.delaunay_exists[key2] = true;\n\tvar l = LineSegment2(this.centers[this.delaunay[start]].clone(), this.centers[this.delaunay[end]].clone());\n\tif (this.polygon.intersectsLine(l)) {\n\t\tl.free();\n\t} else {\n\t\tthis.graph.addEdge(this.delaunay[start], this.delaunay[end], l.length());\n\t\tthis.delaunay_lines.push(l);\n\t}\n};\n\n\nBuilding.prototype.translate = function (vec)\n{\n\tthis.polygon.translate(vec);\n\tfor (var i=0;i<this.centers.length;i++) {\n\t\tthis.centers[i].add(vec);\n\t}\n\tfor (i =0;i<this.delaunay_triangles.length;i++) {\n\t\tthis.delaunay_triangles[i].translate(vec);\n\t}\n\treturn this;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\n\n\n// Represents an edge from source to sink with capacity\nvar Edge = function(source, sink, capacity) {\n    this.source = source;\n    this.sink = sink;\n    this.capacity = capacity;\n};\n\n// Main class to manage the network\nvar Graph = function() {\n    this.edges = {};\n    this.nodes = [];\n    this.nodeMap = {};\n\n    // Add a node to the graph\n    this.addNode = function(node) {\n        this.nodes.push(node);\n        this.nodeMap[node] = this.nodes.length-1;\n        this.edges[node] = [];\n    };\n\n    // Add an edge from source to sink with capacity\n    this.addEdge = function(source, sink, capacity) {\n        // Create the two edges = one being the reverse of the other\n        this.edges[source].push(new Edge(source, sink, capacity));\n        this.edges[sink].push(new Edge(sink, source, capacity));\n    };\n\n    // Does edge from source to sink exist?\n    this.edgeExists = function(source, sink) {\n        if(this.edges[source] !== undefined) {\n            for(var i=0;i<this.edges[source].length;i++) {\n                if(this.edges[source][i].sink === sink) {\n                    return this.edges[source][i];\n                }\n            }\n        }\n        return null;\n    };\n\n\n    this.prim = function() {\n        var result = [];\n        var resultEdges = [];\n        var usedNodes = {};\n\n        function findMin(g) {\n            var min = [999999,null];\n            for(var i=0;i<result.length;i++) {\n                for(var n=0;n<g.edges[result[i]].length;n++) {\n                    if(g.edges[result[i]][n].capacity < min[0] && usedNodes[g.edges[result[i]][n].sink] === undefined) {\n                        min = [g.edges[result[i]][n].capacity, g.edges[result[i]][n]];\n                    }\n                }\n            }\n            return min;\n        }\n\n        // Pick random start point\n        var node = this.nodes[Math.round(Math.random()*(this.nodes.length-1))];\n        result.push(node);\n        usedNodes[node] = true;\n\n        var min = findMin(this);\n        while(min[1] !== null) {\n            resultEdges.push(min[1]);\n            result.push(min[1].sink);\n            usedNodes[min[1].sink] = true;\n            min = findMin(this);\n        }\n\n        return resultEdges;\n    };\n\n};\n\nmodule.exports = Graph;\n","module.exports = {\n  Graph: require('./graph'),\n  Building: require('./building')\n};\n","'use strict';\n\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\n\nvar NOOP = function(){};\n\nexports = module.exports = GameLoop;\n\nfunction GameLoop () {\n  this.simulationTimestep = 1000 / 60;\n  this.frameDelta = 0;\n  this.lastFrameTimeMs = 0;\n  this.fps = 60;\n  this.lastFpsUpdate = 0;\n  this.framesThisSecond = 0;\n  this.numUpdateSteps = 0;\n  this.minFrameDelay = 0;\n  this.running = false;\n  this.started = false;\n  this.panic = false;\n  this.rafHandle = false;\n  this.boundAnimate = this.animate.bind(this);\n}\n\nGameLoop.prototype.begin = NOOP;\nGameLoop.prototype.update = NOOP;\nGameLoop.prototype.render = NOOP;\nGameLoop.prototype.end = NOOP;\n\nGameLoop.prototype.getSimulationTimestep = function() {\n  return this.simulationTimestep;\n};\n\nGameLoop.prototype.setSimulationTimestep = function(timestep) {\n  this.simulationTimestep = timestep;\n  return this;\n};\n\nGameLoop.prototype.getFPS = function () {\n  return this.fps;\n};\n\nGameLoop.prototype.getMaxAllowedFPS = function() {\n  return 1000 / this.minFrameDelay;\n};\n\nGameLoop.prototype.setMaxAllowedFPS =  function(fps) {\n  if (typeof fps === 'undefined') {\n    fps = Infinity;\n  }\n  if (fps === 0) {\n    this.stop();\n  }\n  else {\n    // Dividing by Infinity returns zero.\n    this.minFrameDelay = 1000 / fps;\n  }\n  return this;\n};\n\nGameLoop.prototype.resetFrameDelta = function() {\n  var oldFrameDelta = this.frameDelta;\n  this.frameDelta = 0;\n  return oldFrameDelta;\n};\n\nGameLoop.prototype.setBegin = function(fun) {\n  this.begin = fun || this.begin;\n  return this;\n};\n\nGameLoop.prototype.setUpdate = function(fun) {\n  this.update = fun || this.update;\n  return this;\n};\n\nGameLoop.prototype.setRender = function(fun) {\n  this.render = fun || this.render;\n  return this;\n};\n\nGameLoop.prototype.setEnd = function(fun) {\n  this.end = fun || this.end;\n  return this;\n};\n\nGameLoop.prototype.start = function() {\n  if (!this.started) {\n    this.started = true;\n    var self = this;\n    this.rafHandle = request(function(timestamp) {\n      self.render(1);\n      self.running = true;\n      self.lastFrameTimeMs = timestamp;\n      self.lastFpsUpdate = timestamp;\n      self.framesThisSecond = 0;\n      self.rafHandle = request(self.boundAnimate);\n    });\n  }\n  return this;\n};\n\nGameLoop.prototype.stop = function() {\n  this.running = false;\n  this.started = false;\n  cancel(this.rafHandle);\n  return this;\n};\n\nGameLoop.prototype.isRunning = function() {\n  return this.running;\n};\n\nGameLoop.prototype.animate = function animate(timestamp) {\n\n    if (timestamp < this.lastFrameTimeMs + this.minFrameDelay) {\n        this.rafHandle = request(this.boundAnimate);\n        return;\n    }\n\n    this.frameDelta += timestamp - this.lastFrameTimeMs;\n    this.lastFrameTimeMs = timestamp;\n\n    this.begin(timestamp, this.frameDelta);\n\n    if (timestamp > this.lastFpsUpdate + 1000) {\n        this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;\n        this.lastFpsUpdate = timestamp;\n        this.framesThisSecond = 0;\n    }\n    this.framesThisSecond++;\n\n     /* - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    this.numUpdateSteps = 0;\n    while (this.frameDelta >= this.simulationTimestep) {\n        this.update(this.simulationTimestep);\n        this.frameDelta -= this.simulationTimestep;\n\n        if (++this.numUpdateSteps >= 240) {\n            this.panic = true;\n            break;\n        }\n    }\n\n    this.render(this.frameDelta / this.simulationTimestep);\n\n    this.end(this.fps, this.panic);\n\n    this.panic = false;\n\n    this.rafHandle = request(this.boundAnimate);\n};\n","module.exports = {\n  GameLoop: require('./gameloop')\n};\n"],"sourceRoot":"./"}