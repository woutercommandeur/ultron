{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/delaunay-fast/delaunay.js","ultron.min.js","node_modules/eventemitter3/index.js","node_modules/request-frame/dist/request-frame.js","node_modules/vkey/index.js","src/ai/steering.js","src/game/game.js","src/game/index.js","src/game/state.js","src/game/statelist.js","src/game/statestack.js","src/geometry/gpc.js","src/geometry/grid/cell.js","src/geometry/grid/grid.js","src/geometry/grid/index.js","src/geometry/index.js","src/geometry/linesegment2.js","src/geometry/polygon2.js","src/geometry/quadtree/boundsnode.js","src/geometry/quadtree/index.js","src/geometry/quadtree/pointnode.js","src/geometry/quadtree/quadtree.js","src/geometry/rectangle2.js","src/geometry/regularpolygon2.js","src/geometry/triangle2.js","src/geometry/vector2.js","src/geometry/visibilitypolygon.js","src/src/index.js","src/input/index.js","src/input/mousewheel-polyfill.js","src/input/unified.js","src/linkedlist/doublylinkedlist.js","src/linkedlist/index.js","src/procedural/building/index.js","src/procedural/dungeon/index.js","src/procedural/graph.js","src/procedural/index.js","src/timer/gameloop.js","src/timer/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","ULTRON","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"Delaunay","supertriangle","vertices","dx","dy","dmax","xmid","ymid","xmin","Number","POSITIVE_INFINITY","ymin","xmax","NEGATIVE_INFINITY","ymax","Math","max","circumcircle","j","k","xc","yc","m1","m2","mx1","mx2","my1","my2","x1","y1","x2","y2","x3","y3","fabsy1y2","abs","fabsy2y3","EPSILON","x","y","dedup","edges","b","m","splice","triangulate","key","indices","st","open","closed","c","slice","Array","sort","push","contains","tri","p","d","v",2,"EE","fn","context","once","EventEmitter","prefix","Object","create","prototype","_events","undefined","listeners","event","exists","evt","available","ee","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","apply","on","listener","events","removeAllListeners","off","addListener","setMaxListeners","prefixed",3,"requestFrame","type","hasIOS6RequestAnimationFrameBug","bugCheckresults","timingFnA","timingFnB","notice","console","warn","displayResults","hasIOS6Bug","webkitRAF","rAF","iOS6Notice","webkitRequestAnimationFrame","requestAnimationFrame","hasMobileDeviceWidth","screen","width","requiresWebkitprefix","hasNoNavigationTiming","performance","clearTimeoutWithId","id","clearTimeout","setTimeoutWithTimestamp","callback","immediateTime","Date","now","lapsedTime","previousTime","setTimeout","queryRequestAnimationFrame","filter","assignedRequestAnimationFrame","aF","vendors","vendor","rqAF","queryCancelAnimationFrame","prefixedCancelAnimationFrame","prefixedNames","cancellationFunction","cancellationNames","map","cancellationNamePrefix","assignedCancelAnimationFrame","getRequestFn","hasMozMismatch","getCancelFn","setNativeFn","cancelAnimationFrame","func","mozRAF","mozRequestAnimationFrame","mozCAF","mozCancelAnimationFrame","getTime",4,"ua","navigator","userAgent","isOSX","test","isOpera","maybeFirefox","output",0,5,6,8,9,12,13,16,17,18,19,20,21,23,24,25,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,91,92,93,95,106,107,108,109,110,111,144,145,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,186,187,188,189,190,191,192,219,220,221,222,223,224,226,229,231,246,247,248,249,250,251,252,253,254,"String","fromCharCode","straight","target","position","clone","subtract","normalize","seek","currentVelocity","maxVelocity","slowingRadius","desired","distance","multipyScalar","flee","multiplyScalar","wander","wanderDistance","wanderRadius","wanderAngle","force","displacement","Vector2","multiplyScaler","setAngle","add","free","evade","targetVelocity","updatesNeeded","tv","targetFuturePosition","pursuit","avoidance","velocity","maxAvoidAhead","avoidanceForce","../geometry/vector2","Game","states","statestack","StateStack","gameloop","GameLoop","setBegin","timestamp","frameDelta","begin","setUpdate","simulationTimestep","update","setRender","percentageTimestepRemaining","render","setEnd","fps","panic","end","NOOP","start","stop","addState","state","game","name","startState","stateName","stopState","pop","../timer/gameloop","./statestack",7,"State","StateList","./game","./state","./statelist","onEnter","onExit","top","depth",10,11,"equals","toString","gpcas","util","geometry","Clip","BundleState","LmtNode","TopPolygonNode","AetTree","HState","VertexType","VertexNode","ItNodeTable","StNode","Point","ArrayHelper","gpcstatic","create2DArray","valueEqual","obj1","obj2","sortPointsClockwise","isArrayList","ArrayList","toArray","maxLeftIndex","maxTop","maxBottom","maxLeft","maxRight","newVertices","vertex","reverse","arr","_array","value","get","index","size","clear","list","hashCode","isEmpty","DEBUG","GPC_EPSILON","GPC_VERSION","LEFT","RIGHT","ABOVE","BELOW","CLIP","SUBJ","intersection","p1","p2","polyClass","clip","OperationType","GPC_INT","union","GPC_UNION","xor","GPC_XOR","difference","GPC_DIFF","createNewPoly","PolySimple","PolyDefault","op","subj","result","minimax_test","lmt_table","LmtTable","sbte","ScanBeamTreeEntries","s_heap","c_heap","build_lmt","print","top_node","sbt","build_sbt","parity","local_min","out_poly","aet","scanbeam","yb","yt","edge","first_bound","next_bound","add_edge_to_aet","next","px","MAX_VALUE","e0","e1","bundle","bstate","UNBUNDLED","next_edge","ne_type","ne_type_opp","EQ","xb","BUNDLE_HEAD","BUNDLE_TAIL","horiz","NH","cf","bside","contributing","br","bl","tr","tl","next_h_state","vclass","getType","EMN","IMN","outp","add_local_min","ERI","add_right","ELI","add_left","EMX","merge_right","ILI","IRI","IMX","merge_left","IMM","EMM","LED","bot","RED","prev_edge","prev","xt","sbt_entries","it_table","build_intersection_table","intersect","ie","q","ix","point","iy","in_clip","in_subj","search","succ_edge","succ","getResult","PREV_INDEX","NEXT_INDEX","OPTIMAL","getY","getNumPoints","create_contour_bboxes","box","getNumInnerPoly","inner_poly","getInnerPoly","getBounds","s_bbox","c_bbox","subj_num_poly","clip_num_poly","o_table","getMaxX","getMinX","getMaxY","getMinY","overlap","setContributing","bound_list","node","done","existing_node","insert_bound","lmt_node","prev_bound","current_bound","current_edge","add_to_sbtree","sb_tree","ScanBeamTree","tree_node","less","more","edge_table","EdgeTable","ip","isContributing","num_vertices","e_index","getX","addNode","min","FWD_MIN","num_edges","NOT_FMAX","getNode","ei","ev","pred","REV_MIN","NOT_RMAX","add_st_edge","it","den","add_intersection","it_node","edge0","edge1","ItNode","m_State","EdgeNode","m_List","ith","BH","TH","IntersectionPoint","p3","polygonPoint1","polygonPoint2","intersectionPoint","Line","LineHelper","equalPoint","equalVertex","s1","s2","e2","distancePoints","sqrt","clonePoint","cloneLine","line","res","addLineToLine","line1","line2","roundPoint","round","lineIntersectLine","A","B","E","F","as_seg","b1","b2","c1","c2","denom","pow","LineIntersection","iteratePoints","points","direction","pl","s1Ind","indexOf","s2Ind","newPoints","intersectPoly","poly","p4","numPoints","firstIntersection","lastIntersection","firstIntersectionLineIndex","lastIntersectionLineIndex","firstFound","maxDist","minDist","dist","getPoint","newLine","poly1","finPoly1","finPoly2","checkPoly","points1","getPoints","concat","points2","poly2","noHoles","innerPoly","isHole","yvalue","lmt","m_Type","m_IsHole","obj","that","arg0","arg1","addPointXY","addPoint","addPoly","alert","Rectangle","log","polyIndex","isPointInside","setIsHole","contributes","getArea","area","tarea","Polygon","fromArray","pointArr","getVertexIndex","insertVertex","vertex1","vertex2","newVertex","vertex1Index","vertex2Index","PolygonNode","active","hole","proxy","vn","nv","m_Contributes","this_num","that_num","this_x","this_y","that_first_index","that_index","that_x","that_y","this_index","Poly","val","oddNodes","ax","ay","bx","by","cx","cy","_x","_y","_w","_h","w","h","entries","inner_build_sbt","sbt_node","existing_min","count_contours","nc","polygon","num_contours","npoly_node","poly_node","vtx","orig","inner","NUL","TED","BED","FUL","WeilerAtherton","merge","Cell","height","items","a10","a11","a20","a21","b10","b11","b20","b21","ua_t","ub_t","u_b","ub","insert","item","fromX","fromY","toX","toY","Grid","bounds","rows","cols","cellX","cellY","cells","out","DoublyLinkedList","col","row","addOut","retrieve","nx","ny","floor","../../linkedlist/doublylinkedlist","./cell",14,"./grid",15,"LineSegment2","Triangle2","Polygon2","RegularPolygon2","gpc","VisibilityPolygon","QuadTree","./gpc","./linesegment2","./polygon2","./quadtree","./regularpolygon2","./triangle2","./vector2","./visibilitypolygon","cache","set","created","getStats","lengthSq","distanceSq","closestPoint","full","l2","intersectCircle","radius","r2","closest","dist_v","len2","other","inverse","freePoints","epsilon","translate","vec","rotate","angle","origin","containsPoint","inside","xi","yi","xj","yj","intersectsLine","ignorePoints","tempLine","is","isEqualEpsilon","aa","copy","bb","intersectsTriangle","triangle","v0","v1","v2","AABB","winding","rewind","cw","first","cross","clean","newpoints","ret","BoundsNode","maxChildren","maxDepth","PointNode","_stuckChildren","_classConstructor","_out","nodes","_findIndex","_bounds","children","_depth","_maxDepth","_maxChildren","subdivide","getChildren","TOP_RIGHT","BOTTOM_LEFT","TOP_LEFT","BOTTOM_RIGHT","getAllContent","./pointnode","./boundsnode","left","b_w_h","b_h_h","bx_b_w_h","by_b_h_h","pointQuad","root",22,"Rectangle2","fromObject","intersects","toObject","sides","center","cos","PI","sin","calcCircumcircle","C","D","G","minx","miny","maxx","maxy","radius_squared","inCircumcircle","dist_squared","radian2degrees","rad","degrees","degrees2radian","deg","warmup","amount","addScalar","scalar","subtractScalar","divide","multiply","zero","dot","projectOnto","coeff","horizontalAngle","atan2","horizontalAngleDeg","verticalAngle","verticalAngleDeg","angleDeg","ox","oy","rotateDeg","rotateBy","rotation","rotateByDeg","magnitude","isZero","isEqualTo",26,"pointsorter","segments","heap","PI2","PImin","segmentIter","angle2","compute","reset","sortPoints","extend","shorten","old_segment","remove","cur","destination","parent","lessThan","temp","swap","child","right","index1","index2","inter1","inter2","d1","d2","end1","end2","isEqualEpsiolon","pp","nr","core","linkedlist","procedural","timer","input","./geometry","./input","./linkedlist","./procedural","./timer","Unified","./unified","_addWheelListener","elem","eventName","useCapture","_addEventListener","support","originalEvent","srcElement","deltaMode","deltaX","delatZ","preventDefault","returnValue","deltaY","wheelDelta","wheelDeltaX","detail","addEventListener","document","createElement","onmousewheel","Inputs","element","opts","preventDefaults","stopPropagation","down","up","gamepadconnected","gamepaddisconnected","scrollx","scrolly","scrollz","_keybindmap","_keyStates","_bindPressCounts","_gamepads","_gamepadButtonStates","_gamepadRaf","initEvents","onKeyEvent","inputs","wasDown","handleKeyEvent","keyCode","vkey","onMouseEvent","keycode","button","vkeycode","onContextMenu","onMouseMove","movementX","mozMovementX","webkitMovementX","movementY","mozMovementY","webkitMovementY","onMouseWheel","scale","clientHeight","innerHeight","deltaZ","vcode","currstate","XOR","handleBindingEvent","binding","ct","emitter","handleGamePadButtonEvent","pressed","isPerc","_buttonStates","updateGamepads","found","scanGamepads","cancel","gamepad","buttons","gamepadButtonNames","axes","gamepadAxesNames","request","onGamepadConnected","addGamepad","onGamepadDisconnected","removeGamepad","hasOwnProperty","gamepads","getGamepads","webkitGetGamepads","addMouseWheel","hasGamepadEvents","bind","oncontextmenu","setInterval","vkeyCode","unbind","tick","getBoundKeys","./mousewheel-polyfill","eventemitter3","request-frame","_head","_tail","_length","_nodeCache","constructor","data","_allocate","current","_free","./doublylinkedlist","Building","chance","iterations","minRadius","maxRadius","maxSides","noRotate","centers","sidesChanceObj","radiusChanceObj","integer","floating","gpcPoly","createPoly","gpcPoly2","num","getPolygonVertices","nrdoors","ceil","doors","dooredges","graph","Graph","delaunay_used","delaunay","delaunay_exists","delaunay_triangles","delaunay_lines","addDelaunayLine","connectDoor","prim","mst_lines","source","sink","outside","door","addEdge","key1","key2","../../geometry/gpc","../../geometry/linesegment2","../../geometry/polygon2","../../geometry/regularpolygon2","../../geometry/vector2","../graph","delaunay-fast","Dungeon","minSide","maxSide","sizeChance","posChance","rooms","vectors","GENERATE_ROOMS","EVADE_ROOMS","SELECT_ROOMS","step","addRoom","evadeRooms","room","rr","avoided","oneAvoided","../../ai/steering","../../geometry/rectangle2","Edge","capacity","nodeMap","edgeExists","findMin","usedNodes","resultEdges","random","./building","./dungeon","./graph","lastFrameTimeMs","lastFpsUpdate","framesThisSecond","numUpdateSteps","minFrameDelay","running","started","rafHandle","boundAnimate","animate","getSimulationTimestep","setSimulationTimestep","timestep","getFPS","getMaxAllowedFPS","setMaxAllowedFPS","Infinity","resetFrameDelta","oldFrameDelta","fun","isRunning","./gameloop"],"mappings":"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","file":"ultron.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var Delaunay;\n\n(function() {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i, dx, dy, dmax, xmid, ymid;\n\n    for(i = vertices.length; i--; ) {\n      if(vertices[i][0] < xmin) xmin = vertices[i][0];\n      if(vertices[i][0] > xmax) xmax = vertices[i][0];\n      if(vertices[i][1] < ymin) ymin = vertices[i][1];\n      if(vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n\n    return [\n      [xmid - 20 * dmax, ymid -      dmax],\n      [xmid            , ymid + 20 * dmax],\n      [xmid + 20 * dmax, ymid -      dmax]\n    ];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;\n\n    /* Check for coincident points */\n    if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)\n      throw new Error(\"Eek! Coincident points!\");\n\n    if(fabsy1y2 < EPSILON) {\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (x2 + x1) / 2.0;\n      yc  = m2 * (xc - mx2) + my2;\n    }\n\n    else if(fabsy2y3 < EPSILON) {\n      m1  = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc  = (x3 + x2) / 2.0;\n      yc  = m1 * (xc - mx1) + my1;\n    }\n\n    else {\n      m1  = -((x2 - x1) / (y2 - y1));\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc  = (fabsy1y2 > fabsy2y3) ?\n        m1 * (xc - mx1) + my1 :\n        m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for(j = edges.length; j; ) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for(i = j; i; ) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if((a === m && b === n) || (a === n && b === m)) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function(vertices, key) {\n      var n = vertices.length,\n          i, j, indices, st, open, closed, edges, dx, dy, a, b, c;\n\n      /* Bail if there aren't enough vertices to form any triangles. */\n      if(n < 3)\n        return [];\n\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n      vertices = vertices.slice(0);\n\n      if(key)\n        for(i = n; i--; )\n          vertices[i] = vertices[i][key];\n\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n      indices = new Array(n);\n\n      for(i = n; i--; )\n        indices[i] = i;\n\n      indices.sort(function(i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      \n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n      open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges  = [];\n\n      /* Incrementally add each vertex to the mesh. */\n      for(i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n        for(j = open.length; j--; ) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n          if(dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n\n          /* If we're outside the circumcircle, skip this triangle. */\n          dy = vertices[c][1] - open[j].y;\n          if(dx * dx + dy * dy - open[j].r > EPSILON)\n            continue;\n\n          /* Remove the triangle and add it's edges to the edge list. */\n          edges.push(\n            open[j].i, open[j].j,\n            open[j].j, open[j].k,\n            open[j].k, open[j].i\n          );\n          open.splice(j, 1);\n        }\n\n        /* Remove any doubled edges. */\n        dedup(edges);\n\n        /* Add a new triangle for each edge. */\n        for(j = edges.length; j; ) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n      for(i = open.length; i--; )\n        closed.push(open[i]);\n      open.length = 0;\n\n      for(i = closed.length; i--; )\n        if(closed[i].i < n && closed[i].j < n && closed[i].k < n)\n          open.push(closed[i].i, closed[i].j, closed[i].k);\n\n      /* Yay, we're done! */\n      return open;\n    },\n    contains: function(tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||\n         (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||\n         (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||\n         (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))\n        return null;\n\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n\n      /* Degenerate tri. */\n      if(i === 0.0)\n        return null;\n\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n\n      /* If we're outside the tri, fail. */\n      if(u < 0.0 || v < 0.0 || (u + v) > 1.0)\n        return null;\n\n      return [u, v];\n    }\n  };\n\n  if(typeof module !== \"undefined\")\n    module.exports = Delaunay;\n})();\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.ULTRON = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar Delaunay;\n\n(function() {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i, dx, dy, dmax, xmid, ymid;\n\n    for(i = vertices.length; i--; ) {\n      if(vertices[i][0] < xmin) xmin = vertices[i][0];\n      if(vertices[i][0] > xmax) xmax = vertices[i][0];\n      if(vertices[i][1] < ymin) ymin = vertices[i][1];\n      if(vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n\n    return [\n      [xmid - 20 * dmax, ymid -      dmax],\n      [xmid            , ymid + 20 * dmax],\n      [xmid + 20 * dmax, ymid -      dmax]\n    ];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;\n\n    /* Check for coincident points */\n    if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)\n      throw new Error(\"Eek! Coincident points!\");\n\n    if(fabsy1y2 < EPSILON) {\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (x2 + x1) / 2.0;\n      yc  = m2 * (xc - mx2) + my2;\n    }\n\n    else if(fabsy2y3 < EPSILON) {\n      m1  = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc  = (x3 + x2) / 2.0;\n      yc  = m1 * (xc - mx1) + my1;\n    }\n\n    else {\n      m1  = -((x2 - x1) / (y2 - y1));\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc  = (fabsy1y2 > fabsy2y3) ?\n        m1 * (xc - mx1) + my1 :\n        m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for(j = edges.length; j; ) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for(i = j; i; ) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if((a === m && b === n) || (a === n && b === m)) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function(vertices, key) {\n      var n = vertices.length,\n          i, j, indices, st, open, closed, edges, dx, dy, a, b, c;\n\n      /* Bail if there aren't enough vertices to form any triangles. */\n      if(n < 3)\n        return [];\n\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n      vertices = vertices.slice(0);\n\n      if(key)\n        for(i = n; i--; )\n          vertices[i] = vertices[i][key];\n\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n      indices = new Array(n);\n\n      for(i = n; i--; )\n        indices[i] = i;\n\n      indices.sort(function(i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      \n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n      open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges  = [];\n\n      /* Incrementally add each vertex to the mesh. */\n      for(i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n        for(j = open.length; j--; ) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n          if(dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n\n          /* If we're outside the circumcircle, skip this triangle. */\n          dy = vertices[c][1] - open[j].y;\n          if(dx * dx + dy * dy - open[j].r > EPSILON)\n            continue;\n\n          /* Remove the triangle and add it's edges to the edge list. */\n          edges.push(\n            open[j].i, open[j].j,\n            open[j].j, open[j].k,\n            open[j].k, open[j].i\n          );\n          open.splice(j, 1);\n        }\n\n        /* Remove any doubled edges. */\n        dedup(edges);\n\n        /* Add a new triangle for each edge. */\n        for(j = edges.length; j; ) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n      for(i = open.length; i--; )\n        closed.push(open[i]);\n      open.length = 0;\n\n      for(i = closed.length; i--; )\n        if(closed[i].i < n && closed[i].j < n && closed[i].k < n)\n          open.push(closed[i].i, closed[i].j, closed[i].k);\n\n      /* Yay, we're done! */\n      return open;\n    },\n    contains: function(tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||\n         (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||\n         (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||\n         (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))\n        return null;\n\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n\n      /* Degenerate tri. */\n      if(i === 0.0)\n        return null;\n\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n\n      /* If we're outside the tri, fail. */\n      if(u < 0.0 || v < 0.0 || (u + v) > 1.0)\n        return null;\n\n      return [u, v];\n    }\n  };\n\n  if(typeof module !== \"undefined\")\n    module.exports = Delaunay;\n})();\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n},{}],3:[function(require,module,exports){\n/**\n *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for\n *   optimal cross-browser development.\n *    Version:  v1.4.0\n *     License:  MIT\n *      Copyright Julien Etienne 2015 All Rights Reserved.\n *        github:  https://github.com/julienetie/request-frame\n *\n */\n(function (window) {\n\n/**\n * @param  {String} type - request | cancel | native.\n * @return {Function} Timing function.\n */\nfunction requestFrame(type) {\n    // The only vendor prefixes required.\n    var vendors = ['moz', 'webkit'],\n\n        // Disassembled timing function abbreviations.\n        aF = 'AnimationFrame',\n        rqAF = 'Request' + aF,\n\n        // Final assigned functions.\n        assignedRequestAnimationFrame,\n        assignedCancelAnimationFrame,\n\n        // Initial time of the timing lapse.\n        previousTime = 0,\n\n        mozRAF = window.mozRequestAnimationFrame,\n        mozCAF = window.mozCancelAnimationFrame,\n\n        // Checks for firefox 4 - 10 function pair mismatch.\n        hasMozMismatch = mozRAF && !mozCAF,\n\n        func;\n\n    // Date.now polyfill, mainly for legacy IE versions.\n    if (!Date.now) {\n        Date.now = function() {\n            return new Date().getTime();\n        };\n    }\n\n    /**\n     * hasIOS6RequestAnimationFrameBug.\n     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}\n     * - for Commentary.\n     * @Copyright 2015 - Julien Etienne. \n     * @License: MIT.\n     */\n    function hasIOS6RequestAnimationFrameBug() {\n        var webkitRAF = window.webkitRequestAnimationFrame,\n            rAF = window.requestAnimationFrame,\n\n            // CSS/ Device with max for iOS6 Devices.\n            hasMobileDeviceWidth = screen.width <= 768 ? true : false,\n\n            // Only supports webkit prefixed requestAnimtionFrane.\n            requiresWebkitprefix = !(webkitRAF && rAF),\n\n            // iOS6 webkit browsers don't support performance now.\n            hasNoNavigationTiming = window.performance ? false : true,\n\n            iOS6Notice = 'setTimeout is being used as a substitiue for' +\n            'requestAnimationFrame due to a bug within iOS 6 builds',\n\n            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&\n            hasNoNavigationTiming;\n\n        function bugCheckresults(timingFnA, timingFnB, notice) {\n            if (timingFnA || timingFnB) {\n                console.warn(notice);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function displayResults() {\n            if (hasIOS6Bug) {\n                return bugCheckresults(webkitRAF, rAF, iOS6Notice);\n            } else {\n                return false;\n            }\n        }\n\n        return displayResults();\n    }\n\n    /**\n     * Native clearTimeout function.\n     * @return {Function}\n     */\n    function clearTimeoutWithId(id) {\n        clearTimeout(id);\n    }\n\n    /**\n     * Based on a polyfill by Erik, introduced by Paul Irish & \n     * further improved by Darius Bacon.\n     * @see  {@link http://www.paulirish.com/2011/\n     * requestanimationframe-for-smart-animating}\n     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/\n     * master/requestAnimationFrame.js}\n     * @callback {Number} Timestamp.\n     * @return {Function} setTimeout Function.\n     */\n    function setTimeoutWithTimestamp(callback) {\n        var immediateTime = Date.now(),\n            lapsedTime = Math.max(previousTime + 16, immediateTime);\n        return setTimeout(function() {\n                callback(previousTime = lapsedTime);\n            },\n            lapsedTime - immediateTime);\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the setTimeoutWithTimestamp function.\n     * @return {Function}\n     */\n    function queryRequestAnimationFrame() {\n        if (Array.prototype.filter) {\n            assignedRequestAnimationFrame = window['request' + aF] ||\n                window[vendors.filter(function(vendor) {\n                    if (window[vendor + rqAF] !== undefined)\n                        return vendor;\n                }) + rqAF] || setTimeoutWithTimestamp;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedRequestAnimationFrame;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the clearTimeoutWithId function.\n     * @return {Function}\n     */\n    function queryCancelAnimationFrame() {\n        var cancellationNames = [];\n        if (Array.prototype.map) {\n            vendors.map(function(vendor) {\n                return ['Cancel', 'CancelRequest'].map(\n                    function(cancellationNamePrefix) {\n                        cancellationNames.push(vendor +\n                            cancellationNamePrefix + aF);\n                    });\n            });\n        } else {\n            return clearTimeoutWithId;\n        }\n\n        /**\n         * Checks for the prefixed cancelAnimationFrame implementation.\n         * @param  {Array} prefixedNames - An array of the prefixed names. \n         * @param  {Number} i - Iteration start point.\n         * @return {Function} prefixed cancelAnimationFrame function.\n         */\n        function prefixedCancelAnimationFrame(prefixedNames, i) {\n            var cancellationFunction;\n            for (; i < prefixedNames.length; i++) {\n                if (window[prefixedNames[i]]) {\n                    cancellationFunction = window[prefixedNames[i]];\n                    break;\n                }\n            }\n            return cancellationFunction;\n        }\n\n        // Use truthly function\n        assignedCancelAnimationFrame = window['cancel' + aF] ||\n            prefixedCancelAnimationFrame(cancellationNames, 0) ||\n            clearTimeoutWithId;\n\n        // Check for iOS 6 bug\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedCancelAnimationFrame;\n        } else {\n            return clearTimeoutWithId;\n        }\n    }\n\n    function getRequestFn() {\n        if (hasMozMismatch) {\n            return setTimeoutWithTimestamp;\n        } else {\n            return queryRequestAnimationFrame();\n        }\n    }\n\n    function getCancelFn() {\n        return queryCancelAnimationFrame();\n    }\n\n    function setNativeFn() {\n        if (hasMozMismatch) {\n            window.requestAnimationFrame = setTimeoutWithTimestamp;\n            window.cancelAnimationFrame = clearTimeoutWithId;\n        } else {\n            window.requestAnimationFrame = queryRequestAnimationFrame();\n            window.cancelAnimationFrame = queryCancelAnimationFrame();\n        }\n    }\n\n    /**\n     * The type value \"request\" singles out firefox 4 - 10 and \n     * assigns the setTimeout function if plausible.\n     */\n\n    switch (type) {\n        case 'request':\n        case '':\n            func = getRequestFn();\n            break;\n\n        case 'cancel':\n            func = getCancelFn();\n            break;\n\n        case 'native':\n            setNativeFn();\n            break;\n        default:\n            throw new Error('RequestFrame parameter is not a type.');\n    }\n    return func;\n}\n\n\n// Node.js/ CommonJS\nif (typeof module === 'object' && typeof module.exports === 'object') {\nmodule.exports = exports = requestFrame;\n}\n\n// AMD\nelse if (typeof define === 'function' && define.amd) {\ndefine(function() {\n  return requestFrame;\n});\n}\n\n// Default to window as global\nelse if (typeof window === 'object') {\nwindow.requestFrame = requestFrame;\n}\n/* global -module, -exports, -define */\n\n}((typeof window === \"undefined\" ? {} : window)));\n\n},{}],4:[function(require,module,exports){\nvar ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n\n},{}],5:[function(require,module,exports){\nvar Vector2 = require('../geometry/vector2');\n\nfunction straight(target, position) {\n    return target.clone().subtract(position).normalize();\n}\n\nfunction seek(target, position, currentVelocity, maxVelocity, slowingRadius) {\n    var desired = target.clone().subtract(position);\n    var distance = desired.length();\n    desired = desired.normalize();\n\n    if (distance <= slowingRadius) {\n        desired = desired.multipyScalar(maxVelocity * (distance / slowingRadius));\n    } else {\n        desired = desired.multipyScalar(maxVelocity);\n    }\n\n    return desired.subtract(currentVelocity);\n}\n\nfunction flee(target, position, currentVelocity, maxVelocity) {\n    // chaining madness\n    return position.clone().subtract(target).normalize().multiplyScalar(maxVelocity).subtract(currentVelocity);\n}\n\nfunction wander(currentVelocity, wanderDistance, wanderRadius, wanderAngle) {\n    // wanderAngle should be something like:\n    // wanderAngle += Math.random() * angleChange - angleChange * .5;\n    var force = currentVelocity.clone().normalize().multiplyScalar(wanderDistance);\n    /* jshint -W064 */\n    var displacement = Vector2(0, -1).multiplyScaler(wanderRadius).setAngle(wanderAngle);\n    /* jshint +W064 */\n    force = force.add(displacement);\n    displacement.free();\n    return force; // force applied\n}\n\nfunction evade(target, position, maxVelocity, currentVelocity, targetVelocity) {\n    var distance = target.clone().subtract(position);\n    var updatesNeeded = distance.length() / maxVelocity;\n    distance.free();\n    var tv = targetVelocity.clone().multiplyScalar(updatesNeeded);\n    var targetFuturePosition = targetVelocity.clone().add(tv);\n    tv.free();\n    var force = flee(targetFuturePosition, position, currentVelocity, maxVelocity);\n    targetFuturePosition.free();\n    return force;\n}\n\nfunction pursuit(target, position, maxVelocity, currentVelocity, targetVelocity) {\n    var distance = target.clone().subtract(position);\n    var updatesNeeded = distance.length() / maxVelocity;\n    distance.free();\n    var tv = targetVelocity.clone().multiplyScaler(updatesNeeded);\n    var targetFuturePosition = targetVelocity.clone().add(tv);\n    tv.free();\n    var force = seek(targetFuturePosition, position, currentVelocity, maxVelocity, 0);\n    targetFuturePosition.free();\n    return force;\n}\n\nfunction avoidance(target, position, velocity, maxAvoidAhead, maxVelocity, avoidanceForce) {\n    var tv = velocity.clone().normalize().multiplyScalar((maxAvoidAhead * velocity.length()) / maxVelocity);\n    var force = position.clone().add(tv).subtract(target).normalize().multiplyScalar(avoidanceForce);\n    tv.free();\n    return force;\n}\n\nexports = module.exports = {\n    straight: straight,\n    evade: evade,\n    seek: seek,\n    flee: flee,\n    wander: wander,\n    pursuit: pursuit,\n    avoidance: avoidance\n};\n\n},{\"../geometry/vector2\":25}],6:[function(require,module,exports){\n'use strict';\n\nvar StateStack = require('./statestack');\nvar GameLoop = require('../timer/gameloop');\nvar NOOP = function () {\n};\n\nmodule.exports = Game;\n\nfunction Game() {\n    this.states = {};\n    this.statestack = new StateStack();\n    this.gameloop = new GameLoop();\n\n    var self = this;\n\n    this.gameloop.setBegin(\n        function (timestamp, frameDelta) {\n            self.begin(timestamp, frameDelta);\n            self.statestack.begin(timestamp, frameDelta);\n        }\n    );\n\n    this.gameloop.setUpdate(\n        function (simulationTimestep) {\n            self.update(simulationTimestep);\n            self.statestack.update(simulationTimestep);\n        }\n    );\n\n    this.gameloop.setRender(\n        function (percentageTimestepRemaining) {\n            // render -> game is last.\n            self.statestack.render(percentageTimestepRemaining);\n            self.render(percentageTimestepRemaining);\n        }\n    );\n\n    this.gameloop.setEnd(\n        function (fps, panic) {\n            self.end(fps.panic);\n            self.statestack.end(fps, panic);\n        }\n    );\n\n}\n\n/* GAMELOOP HANDLING */\n\nGame.prototype.start = function () {\n    return this.gameloop.start();\n};\n\nGame.prototype.stop = function () {\n    return this.gameloop.stop();\n};\n\nGame.prototype.begin = NOOP;\nGame.prototype.end = NOOP;\nGame.prototype.update = NOOP;\nGame.prototype.render = NOOP;\n\n\n/* STATE HANDLING */\n\nGame.prototype.addState = function (state) {\n    state.game = this;\n    this.states[state.name] = state;\n    state.create();\n    return this;\n};\n\nGame.prototype.startState = function (stateName) {\n    var state = this.states[stateName];\n    if (!state) {\n        return;\n    }\n    return this.statestack.push(this.states[stateName]);\n};\n\nGame.prototype.stopState = function (stateName) {\n    var state = this.states[stateName];\n    if (!state) {\n        return;\n    }\n    return this.statestack.pop(state);\n};\n\n},{\"../timer/gameloop\":37,\"./statestack\":10}],7:[function(require,module,exports){\nmodule.exports = {\n    Game: require('./game'),\n    State: require('./state'),\n    StateList: require('./statelist'),\n    StateStack: require('./statestack')\n};\n\n},{\"./game\":6,\"./state\":8,\"./statelist\":9,\"./statestack\":10}],8:[function(require,module,exports){\n'use strict';\n\nmodule.exports = State;\n\nvar NOOP = function () {\n};\n\nfunction State(name) {\n    this.name = name;\n}\n\nState.prototype.create = NOOP;\nState.prototype.begin = NOOP;\nState.prototype.update = NOOP;\nState.prototype.render = NOOP;\nState.prototype.end = NOOP;\nState.prototype.onEnter = NOOP;\nState.prototype.onExit = NOOP;\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = StateList;\n\nfunction StateList() {\n    this.states = [];\n}\n\nStateList.prototype.pop = function () {\n    return this.states.pop();\n};\n\nStateList.prototype.push = function (state) {\n    return this.states.push(state);\n};\n\nStateList.prototype.top = function (depth) {\n    depth = depth || 0;\n    return this.states[this.states.length - (depth + 1)];\n};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nvar StateList = require('./statelist');\n\nmodule.exports = StateStack;\n\nfunction StateStack() {\n    this.states = new StateList();\n}\n\nStateStack.prototype.begin = function (timestamp, frameDelta) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.begin(timestamp, frameDelta)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.update = function (simulationTimestep) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.update(simulationTimestep)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.render = function (percentageTimestepRemaining) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.render(percentageTimestepRemaining)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.end = function (fps, panic) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.end(fps, panic)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.pop = function () {\n    var state = this.states.pop();\n    state.onExit();\n    return state;\n};\n\nStateStack.prototype.push = function (state) {\n    this.states.push(state);\n    return state.onEnter();\n};\n\n},{\"./statelist\":9}],11:[function(require,module,exports){\n'use strict';\n\nvar gpcas = gpcas || {};\ngpcas.util = {};\ngpcas.geometry = {};\n\nmodule.exports = gpcas;\n\n//////////\nvar Clip, BundleState, LmtNode, TopPolygonNode, AetTree, HState, VertexType, VertexNode, ItNodeTable, StNode;\n\n//Object.prototype.equals = function(x) {\nfunction equals(x1, x) {\n\n    var p;\n    for (p in x1) {\n        if (typeof(x[p]) === 'undefined') {\n            return false;\n        }\n    }\n\n    for (p in x1) {\n        if (x1[p]) {\n            switch (typeof(x1[p])) {\n                case 'object':\n                    if (!equals(x1[p], x[p])) {\n                        return false;\n                    }\n                    break;\n                case 'function':\n                    if (typeof(x[p]) === 'undefined' ||\n                        (p !== 'equals' && x1[p].toString() !== x[p].toString()))\n                        return false;\n                    break;\n                default:\n                    if (x1[p] !== x[p]) {\n                        return false;\n                    }\n            }\n        } else {\n            if (x[p])\n                return false;\n        }\n    }\n\n    for (p in x) {\n        if (typeof(x1[p]) === 'undefined') {\n            return false;\n        }\n    }\n\n    return true;\n}\n///point\nvar Point = function (x, y) {\n    this.x = x;\n    this.y = y;\n};\ngpcas.geometry.Point = Point;\n\n////////////// CLASS ArrayHelper ////////////////////////////////////\ngpcas.util.ArrayHelper = function () {\n};\nvar gpcstatic = gpcas.util.ArrayHelper;\n\ngpcstatic.create2DArray = function (x, y) {\n    var a = [];\n    for (var i = 0; i < x; i++) {\n        a[i] = [];\n    }\n    return a;\n};\ngpcstatic.valueEqual = function (obj1, obj2) {\n    if (obj1 === obj2) return true;\n    if (equals(obj1, obj2)) return true;\n\n    return false;\n}\ngpcstatic.sortPointsClockwise = function (vertices) {\n    var isArrayList = false;\n\n    if (vertices instanceof gpcas.util.ArrayList) {\n        vertices = vertices.toArray();\n        isArrayList = true;\n    }\n\n    //point\n    var maxTop = null;\n    var maxBottom = null;\n    var maxLeft = null;\n    var maxRight = null;\n\n\n    var maxLeftIndex;\n    var newVertices = vertices;\n\n\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n\n        if ((maxTop === null) || (maxTop.y > vertex.y) || ((maxTop.y === vertex.y) && (vertex.x < maxTop.x))) {\n            maxTop = vertex;\n        }\n        if ((maxBottom === null) || (maxBottom.y < vertex.y) || ((maxBottom.y === vertex.y) && (vertex.x > maxBottom.x))) {\n            maxBottom = vertex;\n        }\n        if ((maxLeft === null) || (maxLeft.x > vertex.x) || ((maxLeft.x === vertex.x) && (vertex.y > maxLeft.y))) {\n            maxLeft = vertex;\n            maxLeftIndex = i;\n        }\n        if ((maxRight === null) || (maxRight.x < vertex.x) || ((maxRight.x === vertex.x) && (vertex.y < maxRight.y))) {\n            maxRight = vertex;\n        }\n    }\n\n    if (maxLeftIndex > 0) {\n        newVertices = []\n        var j = 0;\n        for (var i = maxLeftIndex; i < vertices.length; i++) {\n            newVertices[j++] = vertices[i];\n        }\n        for (var i = 0; i < maxLeftIndex; i++) {\n            newVertices[j++] = vertices[i];\n        }\n        vertices = newVertices;\n    }\n\n\n    var reverse = false;\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n        if (equals(vertex, maxBottom)) {\n            reverse = true;\n            break;\n        } else if (equals(vertex, maxTop)) {\n            break;\n        }\n    }\n    if (reverse) {\n        newVertices = []\n        newVertices[0] = vertices[0];\n        var j = 1;\n        for (var i = vertices.length - 1; i > 0; i--) {\n            newVertices[j++] = vertices[i];\n        }\n        vertices = newVertices;\n    }\n\n    return (isArrayList ? (new gpcas.util.ArrayList(vertices)) : (vertices));\n}\n\n/////////////// END ArrayHelper  ////////////////////////////////////////////////\n\nvar ArrayHelper = gpcas.util.ArrayHelper;\n////////////////// CLASS ArrayList  /////////////////////////\n\ngpcas.util.ArrayList = function (arr) {\n    this._array = [];\n    if (arr != null) {\n        this._array = arr;\n    }\n\n};\nvar p = gpcas.util.ArrayList.prototype;\n\np.add = function (value) {\n    this._array.push(value);\n};\np.get = function (index) {\n    return this._array[index];\n};\np.size = function () {\n    return this._array.length;\n};\np.clear = function () {\n    this._array = [];\n\n};\np.equals = function (list) {\n    if (this._array.length != list.size()) return false;\n\n    for (var i = 0; i < this._array.length; i++) {\n        var obj1 = this._array[i];\n        var obj2 = list.get(i);\n\n        if (!ArrayHelper.valueEqual(obj1, obj2)) {\n            return false;\n        }\n    }\n    return true;\n}\np.hashCode = function () {\n    return 0;\n};\np.isEmpty = function () {\n    return (this._array.length == 0);\n}\np.toArray = function () {\n    return this._array;\n}\n///////////////// END ArrayList ////////////////////////\n\n\ngpcas.geometry.Clip = function () {\n};\ngpcas.geometry.Clip.DEBUG = false;\ngpcas.geometry.Clip.GPC_EPSILON = 2.2204460492503131e-016;\ngpcas.geometry.Clip.GPC_VERSION = \"2.31\";\ngpcas.geometry.Clip.LEFT = 0;\ngpcas.geometry.Clip.RIGHT = 1;\ngpcas.geometry.Clip.ABOVE = 0;\ngpcas.geometry.Clip.BELOW = 1;\ngpcas.geometry.Clip.CLIP = 0;\ngpcas.geometry.Clip.SUBJ = 1;\nClip = gpcas.geometry.Clip;\n\n\nvar p = gpcas.geometry.Clip.prototype;\nvar gpcstatic = gpcas.geometry.Clip;\n\n// ----------------------\n// --- gpcstatic Methods ---\n// ----------------------\n\n/**\n * Return the intersection of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he intersection with\n * @param p2        One of the polygons to performt he intersection with\n * @param polyClass The type of <code>Poly</code> to return\n */\n\ngpcstatic.intersection = function (p1, p2, polyClass) {\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, polyClass);\n};\n\n\n/**\n * Return the union of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he union with\n * @param p2        One of the polygons to performt he union with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.union = function (p1, p2, polyClass) {\n\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_UNION, p1, p2, polyClass);\n};\n\n\n/**\n * Return the xor of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he xor with\n * @param p2        One of the polygons to performt he xor with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.xor = function (p1, p2, polyClass) {\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_XOR, p1, p2, polyClass);\n};\n\n\n/**\n * Return the difference of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        Polygon from which second polygon will be substracted\n * @param p2        Second polygon\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.difference = function (p1, p2, polyClass) {\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_DIFF, p2, p1, polyClass);\n}\ngpcstatic.intersection = function (p1, p2) {\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, \"PolyDefault.class\");\n}\n\n\n// -----------------------\n// --- Private Methods ---\n// -----------------------\n\n/**\n * Create a new <code>Poly</code> type object using <code>polyClass</code>.\n */\ngpcstatic.createNewPoly = function (polyClass) {\n    /* TODO :\n     try\n     {\n     return (Poly)polyClass.newInstance();\n     }\n     catch( var e:Exception)\n     {\n     throw new RuntimeException(e);\n     }*/\n    if (polyClass == \"PolySimple\") {\n        return new gpcas.geometry.PolySimple();\n    }\n    if (polyClass == \"PolyDefault\") {\n        return new gpcas.geometry.PolyDefault();\n    }\n    if (polyClass == \"PolyDefault.class\") {\n        return new gpcas.geometry.PolyDefault();\n    }\n\n    return null;\n}\n\n/**\n * <code>clip()</code> is the main method of the clipper algorithm.\n * This is where the conversion from really begins.\n */\ngpcstatic.clip = function (op, subj, clip, polyClass) {\n    var result = gpcas.geometry.Clip.createNewPoly(polyClass);\n\n    /* Test for trivial NULL result cases */\n    if ((subj.isEmpty() && clip.isEmpty()) ||\n        (subj.isEmpty() && ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF))) ||\n        (clip.isEmpty() && (op == gpcas.geometry.OperationType.GPC_INT))) {\n        return result;\n    }\n\n\n    /* Identify potentialy contributing contours */\n    if (((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF)) && !subj.isEmpty() && !clip.isEmpty()) {\n        gpcas.geometry.Clip.minimax_test(subj, clip, op);\n    }\n\n    //console.log(\"SUBJ \" + subj);\n    //console.log(\"CLIP \" + clip);\n\n\n    /* Build LMT */\n    var lmt_table = new gpcas.geometry.LmtTable();\n    var sbte = new gpcas.geometry.ScanBeamTreeEntries();\n    var s_heap = null;\n    var c_heap = null;\n\n\n    if (!subj.isEmpty()) {\n        s_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, subj, gpcas.geometry.Clip.SUBJ, op);\n    }\n    if (gpcas.geometry.Clip.DEBUG) {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for subj ---------\");\n        lmt_table.print();\n    }\n    if (!clip.isEmpty()) {\n        c_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, clip, gpcas.geometry.Clip.CLIP, op);\n    }\n    if (gpcas.geometry.Clip.DEBUG) {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for clip ---------\");\n        lmt_table.print();\n    }\n\n    /* Return a NULL result if no contours contribute */\n    if (lmt_table.top_node == null) {\n        return result;\n    }\n\n    /* Build scanbeam table from scanbeam tree */\n    var sbt = sbte.build_sbt();\n\n\n    var parity = [];\n    parity[0] = gpcas.geometry.Clip.LEFT;\n    parity[1] = gpcas.geometry.Clip.LEFT;\n\n    /* Invert clip polygon for difference operation */\n    if (op == gpcas.geometry.OperationType.GPC_DIFF) {\n        parity[Clip.CLIP] = gpcas.geometry.Clip.RIGHT;\n    }\n\n    if (gpcas.geometry.Clip.DEBUG) {\n        //console.log(sbt);\n    }\n\n    var local_min = lmt_table.top_node;\n\n    var out_poly = new TopPolygonNode(); // used to create resulting Poly\n\n    var aet = new AetTree();\n    var scanbeam = 0;\n\n\n    /* Process each scanbeam */\n    while (scanbeam < sbt.length) {\n        /* Set yb and yt to the bottom and top of the scanbeam */\n        var yb = sbt[scanbeam++];\n        var yt = 0.0;\n        var dy = 0.0;\n        if (scanbeam < sbt.length) {\n            yt = sbt[scanbeam];\n            dy = yt - yb;\n        }\n\n\n        /* === SCANBEAM BOUNDARY PROCESSING ================================ */\n\n        /* If LMT node corresponding to yb exists */\n        if (local_min != null) {\n            if (local_min.y == yb) {\n                /* Add edges starting at this local minimum to the AET */\n                for (var edge = local_min.first_bound; (edge != null); edge = edge.next_bound) {\n                    gpcas.geometry.Clip.add_edge_to_aet(aet, edge);\n                }\n\n                local_min = local_min.next;\n            }\n        }\n\n        if (gpcas.geometry.Clip.DEBUG) {\n            aet.print();\n        }\n        /* Set dummy previous x value */\n        var px = -Number.MAX_VALUE;\n\n        /* Create bundles within AET */\n        var e0 = aet.top_node;\n        var e1 = aet.top_node;\n\n\n        /* Set up bundle fields of first edge */\n        aet.top_node.bundle[Clip.ABOVE][aet.top_node.type] = (aet.top_node.top.y != yb) ? 1 : 0;\n        aet.top_node.bundle[Clip.ABOVE][((aet.top_node.type == 0) ? 1 : 0)] = 0;\n        aet.top_node.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n        for (var next_edge = aet.top_node.next; (next_edge != null); next_edge = next_edge.next) {\n            var ne_type = next_edge.type;\n            var ne_type_opp = ((next_edge.type == 0) ? 1 : 0); //next edge type opposite\n\n            /* Set up bundle fields of next edge */\n            next_edge.bundle[Clip.ABOVE][ne_type] = (next_edge.top.y != yb) ? 1 : 0;\n            next_edge.bundle[Clip.ABOVE][ne_type_opp] = 0;\n            next_edge.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n            /* Bundle edges above the scanbeam boundary if they coincide */\n            if (next_edge.bundle[Clip.ABOVE][ne_type] == 1) {\n                if (Clip.EQ(e0.xb, next_edge.xb) && gpcas.geometry.Clip.EQ(e0.dx, next_edge.dx) && (e0.top.y != yb)) {\n                    next_edge.bundle[Clip.ABOVE][ne_type] ^= e0.bundle[Clip.ABOVE][ne_type];\n                    next_edge.bundle[Clip.ABOVE][ne_type_opp] = e0.bundle[Clip.ABOVE][ne_type_opp];\n                    next_edge.bstate[Clip.ABOVE] = BundleState.BUNDLE_HEAD;\n                    e0.bundle[Clip.ABOVE][Clip.CLIP] = 0;\n                    e0.bundle[Clip.ABOVE][Clip.SUBJ] = 0;\n                    e0.bstate[Clip.ABOVE] = BundleState.BUNDLE_TAIL;\n                }\n                e0 = next_edge;\n\n            }\n        }\n\n        var horiz = [];\n        horiz[Clip.CLIP] = HState.NH;\n        horiz[Clip.SUBJ] = HState.NH;\n\n        var exists = [];\n        exists[Clip.CLIP] = 0;\n        exists[Clip.SUBJ] = 0;\n\n        var cf = null;\n\n        /* Process each edge at this scanbeam boundary */\n        for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n            exists[Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP] + (edge.bundle[Clip.BELOW][Clip.CLIP] << 1);\n            exists[Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ] + (edge.bundle[Clip.BELOW][Clip.SUBJ] << 1);\n\n            if ((exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0)) {\n                /* Set bundle side */\n                edge.bside[Clip.CLIP] = parity[Clip.CLIP];\n                edge.bside[Clip.SUBJ] = parity[Clip.SUBJ];\n\n                var contributing = false;\n                var br = 0;\n                var bl = 0;\n                var tr = 0;\n                var tl = 0;\n                /* Determine contributing status and quadrant occupancies */\n                if ((op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT)) {\n                    contributing = ((exists[Clip.CLIP] != 0) && ((parity[Clip.SUBJ] != 0) || (horiz[Clip.SUBJ] != 0))) ||\n                    ((exists[Clip.SUBJ] != 0) && ((parity[Clip.CLIP] != 0) || (horiz[Clip.CLIP] != 0))) ||\n                    ((exists[Clip.CLIP] != 0) && (exists[Clip.SUBJ] != 0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP] != 0) && (parity[Clip.SUBJ] != 0)) ? 1 : 0;\n                    bl = ( ((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) != 0) &&\n                    ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]) != 0) ) ? 1 : 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0)) != 0) &&\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0)) != 0) ) ? 1 : 0;\n                    tl = (((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.CLIP]) != 0) &&\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]) != 0)) ? 1 : 0;\n                }\n                else if (op == gpcas.geometry.OperationType.GPC_XOR) {\n                    contributing = (exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0);\n                    br = (parity[Clip.CLIP]) ^ (parity[Clip.SUBJ]);\n                    bl = (parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) ^ (parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    tr = (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0)) ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0));\n                    tl = (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])\n                    ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]);\n                }\n                else if (op == gpcas.geometry.OperationType.GPC_UNION) {\n                    contributing = ((exists[Clip.CLIP] != 0) && (!(parity[Clip.SUBJ] != 0) || (horiz[Clip.SUBJ] != 0))) ||\n                    ((exists[Clip.SUBJ] != 0) && (!(parity[Clip.CLIP] != 0) || (horiz[Clip.CLIP] != 0))) ||\n                    ((exists[Clip.CLIP] != 0) && (exists[Clip.SUBJ] != 0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP] != 0) || (parity[Clip.SUBJ] != 0)) ? 1 : 0;\n                    bl = (((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) != 0) || ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0)) != 0) ||\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0)) != 0) ) ? 1 : 0;\n                    tl = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.CLIP]) != 0) ||\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]) != 0) ) ? 1 : 0;\n                }\n                else {\n                    //console.log(\"ERROR : Unknown op\");\n                }\n\n                /* Update parity */\n                parity[Clip.CLIP] ^= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                parity[Clip.SUBJ] ^= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n\n                /* Update horizontal state */\n                if (exists[Clip.CLIP] != 0) {\n                    horiz[Clip.CLIP] = HState.next_h_state[horiz[Clip.CLIP]][((exists[Clip.CLIP] - 1) << 1) + parity[Clip.CLIP]];\n                }\n                if (exists[Clip.SUBJ] != 0) {\n                    horiz[Clip.SUBJ] = HState.next_h_state[horiz[Clip.SUBJ]][((exists[Clip.SUBJ] - 1) << 1) + parity[Clip.SUBJ]];\n                }\n\n                if (contributing) {\n                    var xb = edge.xb;\n\n\n                    var vclass = VertexType.getType(tr, tl, br, bl);\n                    switch (vclass) {\n                        case VertexType.EMN:\n                        case VertexType.IMN:\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (xb != px) {\n                                cf.add_right(xb, yb);\n                                px = xb;\n                            }\n                            edge.outp[Clip.ABOVE] = cf;\n                            cf = null;\n                            break;\n                        case VertexType.ELI:\n                            edge.outp[Clip.BELOW].add_left(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.BELOW];\n                            break;\n                        case VertexType.EMX:\n                            if (xb != px) {\n                                cf.add_left(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            cf = null;\n                            break;\n                        case VertexType.ILI:\n                            if (xb != px) {\n                                cf.add_left(xb, yb);\n                                px = xb;\n                            }\n                            edge.outp[Clip.ABOVE] = cf;\n                            cf = null;\n                            break;\n                        case VertexType.IRI:\n                            edge.outp[Clip.BELOW].add_right(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.BELOW];\n                            edge.outp[Clip.BELOW] = null;\n                            break;\n                        case VertexType.IMX:\n                            if (xb != px) {\n                                cf.add_right(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            cf = null;\n                            edge.outp[Clip.BELOW] = null;\n                            break;\n                        case VertexType.IMM:\n                            if (xb != px) {\n                                cf.add_right(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW] = null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.EMM:\n                            if (xb != px) {\n                                cf.add_left(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW] = null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.LED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_left(xb, yb);\n                            edge.outp[Clip.ABOVE] = edge.outp[Clip.BELOW];\n                            px = xb;\n                            break;\n                        case VertexType.RED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_right(xb, yb);\n                            edge.outp[Clip.ABOVE] = edge.outp[Clip.BELOW];\n                            px = xb;\n                            break;\n                        default:\n                            break;\n                    }\n                    /* End of switch */\n                }\n                /* End of contributing conditional */\n            }\n            /* End of edge exists conditional */\n            if (gpcas.geometry.Clip.DEBUG) {\n                out_poly.print();\n            }\n            out_poly.print();\n        }\n        /* End of AET loop */\n\n\n        /* Delete terminating edges from the AET, otherwise compute xt */\n        for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n            if (edge.top.y == yb) {\n                var prev_edge = edge.prev;\n                var next_edge = edge.next;\n\n                if (prev_edge != null)\n                    prev_edge.next = next_edge;\n                else\n                    aet.top_node = next_edge;\n\n                if (next_edge != null)\n                    next_edge.prev = prev_edge;\n\n                /* Copy bundle head state to the adjacent tail edge if required */\n                if ((edge.bstate[Clip.BELOW] == BundleState.BUNDLE_HEAD) && (prev_edge != null)) {\n                    if (prev_edge.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL) {\n                        prev_edge.outp[Clip.BELOW] = edge.outp[Clip.BELOW];\n                        prev_edge.bstate[Clip.BELOW] = BundleState.UNBUNDLED;\n                        if (prev_edge.prev != null) {\n                            if (prev_edge.prev.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL) {\n                                prev_edge.bstate[Clip.BELOW] = BundleState.BUNDLE_HEAD;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                if (edge.top.y == yt)\n                    edge.xt = edge.top.x;\n                else\n                    edge.xt = edge.bot.x + edge.dx * (yt - edge.bot.y);\n            }\n        }\n\n        if (scanbeam < sbte.sbt_entries) {\n            /* === SCANBEAM INTERIOR PROCESSING ============================== */\n\n            /* Build intersection table for the current scanbeam */\n            var it_table = new ItNodeTable();\n            it_table.build_intersection_table(aet, dy);\n\n\n            /* Process each node in the intersection table */\n\n            for (var intersect = it_table.top_node; (intersect != null); intersect = intersect.next) {\n\n\n                e0 = intersect.ie[0];\n                e1 = intersect.ie[1];\n\n                /* Only generate output for contributing intersections */\n\n                if (((e0.bundle[Clip.ABOVE][Clip.CLIP] != 0) || (e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0)) &&\n                    ((e1.bundle[Clip.ABOVE][Clip.CLIP] != 0) || (e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0))) {\n                    var p = e0.outp[Clip.ABOVE];\n                    var q = e1.outp[Clip.ABOVE];\n                    var ix = intersect.point.x;\n                    var iy = intersect.point.y + yb;\n\n                    var in_clip = ( ( (e0.bundle[Clip.ABOVE][Clip.CLIP] != 0) && !(e0.bside[Clip.CLIP] != 0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.CLIP] != 0) && (e1.bside[Clip.CLIP] != 0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.CLIP] != 0) && !(e1.bundle[Clip.ABOVE][Clip.CLIP] != 0) &&\n                    (e0.bside[Clip.CLIP] != 0) && (e1.bside[Clip.CLIP] != 0) ) ) ? 1 : 0;\n\n                    var in_subj = ( ( (e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0) && !(e0.bside[Clip.SUBJ] != 0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0) && (e1.bside[Clip.SUBJ] != 0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0) && !(e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0) &&\n                    (e0.bside[Clip.SUBJ] != 0) && (e1.bside[Clip.SUBJ] != 0) ) ) ? 1 : 0;\n\n                    var tr = 0\n                    var tl = 0;\n                    var br = 0;\n                    var bl = 0;\n                    /* Determine quadrant occupancies */\n                    if ((op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT)) {\n                        tr = ((in_clip != 0) && (in_subj != 0)) ? 1 : 0;\n                        tl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) != 0) && ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        br = (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) && ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        bl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) &&\n                        ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0) ) ? 1 : 0;\n                    }\n                    else if (op == gpcas.geometry.OperationType.GPC_XOR) {\n                        tr = in_clip ^ in_subj;\n                        tl = (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        br = (in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        bl = (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])\n                        ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    }\n                    else if (op == gpcas.geometry.OperationType.GPC_UNION) {\n                        tr = ((in_clip != 0) || (in_subj != 0)) ? 1 : 0;\n                        tl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) != 0) || ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        br = (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) || ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        bl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) ||\n                        ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                    }\n                    else {\n                        //console.log(\"ERROR : Unknown op type, \"+op);\n                    }\n\n                    var vclass = VertexType.getType(tr, tl, br, bl);\n                    switch (vclass) {\n                        case VertexType.EMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (p != null) {\n                                p.add_right(ix, iy);\n                                e1.outp[Clip.ABOVE] = p;\n                                e0.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.ELI:\n                            if (q != null) {\n                                q.add_left(ix, iy);\n                                e0.outp[Clip.ABOVE] = q;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.EMX:\n                            if ((p != null) && (q != null)) {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = null;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ILI:\n                            if (p != null) {\n                                p.add_left(ix, iy);\n                                e1.outp[Clip.ABOVE] = p;\n                                e0.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IRI:\n                            if (q != null) {\n                                q.add_right(ix, iy);\n                                e0.outp[Clip.ABOVE] = q;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IMX:\n                            if ((p != null) && (q != null)) {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = null;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IMM:\n                            if ((p != null) && (q != null)) {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        case VertexType.EMM:\n                            if ((p != null) && (q != null)) {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                    /* End of switch */\n                }\n                /* End of contributing intersection conditional */\n\n                /* Swap bundle sides in response to edge crossing */\n                if (e0.bundle[Clip.ABOVE][Clip.CLIP] != 0)\n                    e1.bside[Clip.CLIP] = (e1.bside[Clip.CLIP] == 0) ? 1 : 0;\n                if (e1.bundle[Clip.ABOVE][Clip.CLIP] != 0)\n                    e0.bside[Clip.CLIP] = (e0.bside[Clip.CLIP] == 0) ? 1 : 0;\n                if (e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0)\n                    e1.bside[Clip.SUBJ] = (e1.bside[Clip.SUBJ] == 0) ? 1 : 0;\n                if (e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0)\n                    e0.bside[Clip.SUBJ] = (e0.bside[Clip.SUBJ] == 0) ? 1 : 0;\n\n                /* Swap e0 and e1 bundles in the AET */\n                var prev_edge = e0.prev;\n                var next_edge = e1.next;\n                if (next_edge != null) {\n                    next_edge.prev = e0;\n                }\n\n                if (e0.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) {\n                    var search = true;\n                    while (search) {\n                        prev_edge = prev_edge.prev;\n                        if (prev_edge != null) {\n                            if (prev_edge.bstate[Clip.ABOVE] != BundleState.BUNDLE_TAIL) {\n                                search = false;\n                            }\n                        }\n                        else {\n                            search = false;\n                        }\n                    }\n                }\n                if (prev_edge == null) {\n                    aet.top_node.prev = e1;\n                    e1.next = aet.top_node;\n                    aet.top_node = e0.next;\n                }\n                else {\n                    prev_edge.next.prev = e1;\n                    e1.next = prev_edge.next;\n                    prev_edge.next = e0.next;\n                }\n                e0.next.prev = prev_edge;\n                e1.next.prev = e1;\n                e0.next = next_edge;\n                if (gpcas.geometry.Clip.DEBUG) {\n                    out_poly.print();\n                }\n            }\n            /* End of IT loop*/\n\n            /* Prepare for next scanbeam */\n            for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n                var next_edge = edge.next;\n                var succ_edge = edge.succ;\n                if ((edge.top.y == yt) && (succ_edge != null)) {\n                    /* Replace AET edge by its successor */\n                    succ_edge.outp[Clip.BELOW] = edge.outp[Clip.ABOVE];\n                    succ_edge.bstate[Clip.BELOW] = edge.bstate[Clip.ABOVE];\n                    succ_edge.bundle[Clip.BELOW][Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    succ_edge.bundle[Clip.BELOW][Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    var prev_edge = edge.prev;\n                    if (prev_edge != null)\n                        prev_edge.next = succ_edge;\n                    else\n                        aet.top_node = succ_edge;\n                    if (next_edge != null)\n                        next_edge.prev = succ_edge;\n                    succ_edge.prev = prev_edge;\n                    succ_edge.next = next_edge;\n                }\n                else {\n                    /* Update this edge */\n                    edge.outp[Clip.BELOW] = edge.outp[Clip.ABOVE];\n                    edge.bstate[Clip.BELOW] = edge.bstate[Clip.ABOVE];\n                    edge.bundle[Clip.BELOW][Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    edge.bundle[Clip.BELOW][Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    edge.xb = edge.xt;\n                }\n                edge.outp[Clip.ABOVE] = null;\n            }\n        }\n    }\n    /* === END OF SCANBEAM PROCESSING ================================== */\n\n    /* Generate result polygon from out_poly */\n    result = out_poly.getResult(polyClass);\n    //console.log(\"result = \"+result);\n\n    return result;\n}\n\ngpcstatic.EQ = function (a, b) {\n    return (Math.abs(a - b) <= gpcas.geometry.Clip.GPC_EPSILON);\n}\n\ngpcstatic.PREV_INDEX = function (i, n) {\n    return ((i - 1 + n) % n);\n}\n\ngpcstatic.NEXT_INDEX = function (i, n) {\n    return ((i + 1) % n);\n}\n\ngpcstatic.OPTIMAL = function (p, i) {\n    return (p.getY(gpcas.geometry.Clip.PREV_INDEX(i, p.getNumPoints())) != p.getY(i)) ||\n    (p.getY(gpcas.geometry.Clip.NEXT_INDEX(i, p.getNumPoints())) != p.getY(i));\n}\n\ngpcstatic.create_contour_bboxes = function (p) {\n    var box = [];\n\n    /* Construct contour bounding boxes */\n    for (var c = 0; c < p.getNumInnerPoly(); c++) {\n        var inner_poly = p.getInnerPoly(c);\n        box[c] = inner_poly.getBounds();\n    }\n    return box;\n}\n\ngpcstatic.minimax_test = function (subj, clip, op) {\n    var s_bbox = gpcas.geometry.Clip.create_contour_bboxes(subj);\n    var c_bbox = gpcas.geometry.Clip.create_contour_bboxes(clip);\n\n    var subj_num_poly = subj.getNumInnerPoly();\n    var clip_num_poly = clip.getNumInnerPoly();\n    var o_table = ArrayHelper.create2DArray(subj_num_poly, clip_num_poly);\n\n    /* Check all subject contour bounding boxes against clip boxes */\n    for (var s = 0; s < subj_num_poly; s++) {\n        for (var c = 0; c < clip_num_poly; c++) {\n            o_table[s][c] =\n                (!((s_bbox[s].getMaxX() < c_bbox[c].getMinX()) ||\n                (s_bbox[s].getMinX() > c_bbox[c].getMaxX()))) &&\n                (!((s_bbox[s].getMaxY() < c_bbox[c].getMinY()) ||\n                (s_bbox[s].getMinY() > c_bbox[c].getMaxY())));\n        }\n    }\n\n    /* For each clip contour, search for any subject contour overlaps */\n    for (var c = 0; c < clip_num_poly; c++) {\n        var overlap = false;\n        for (var s = 0; !overlap && (s < subj_num_poly); s++) {\n            overlap = o_table[s][c];\n        }\n        if (!overlap) {\n            clip.setContributing(c, false); // Flag non contributing status\n        }\n    }\n\n    if (op == gpcas.geometry.OperationType.GPC_INT) {\n        /* For each subject contour, search for any clip contour overlaps */\n        for (var s = 0; s < subj_num_poly; s++) {\n            var overlap = false;\n            for (var c = 0; !overlap && (c < clip_num_poly); c++) {\n                overlap = o_table[s][c];\n            }\n            if (!overlap) {\n                subj.setContributing(s, false); // Flag non contributing status\n            }\n        }\n    }\n}\n\ngpcstatic.bound_list = function (lmt_table, y) {\n    if (lmt_table.top_node == null) {\n        lmt_table.top_node = new LmtNode(y);\n        return lmt_table.top_node;\n    }\n    else {\n        var prev = null;\n        var node = lmt_table.top_node;\n        var done = false;\n        while (!done) {\n            if (y < node.y) {\n                /* Insert a new LMT node before the current node */\n                var existing_node = node;\n                node = new LmtNode(y);\n                node.next = existing_node;\n                if (prev == null) {\n                    lmt_table.top_node = node;\n                }\n                else {\n                    prev.next = node;\n                }\n                //               if( existing_node == lmt_table.top_node )\n                //               {\n                //                  lmt_table.top_node = node ;\n                //               }\n                done = true;\n            }\n            else if (y > node.y) {\n                /* Head further up the LMT */\n                if (node.next == null) {\n                    node.next = new LmtNode(y);\n                    node = node.next;\n                    done = true;\n                }\n                else {\n                    prev = node;\n                    node = node.next;\n                }\n            }\n            else {\n                /* Use this existing LMT node */\n                done = true;\n            }\n        }\n        return node;\n    }\n}\n\ngpcstatic.insert_bound = function (lmt_node, e) {\n    if (lmt_node.first_bound == null) {\n        /* Link node e to the tail of the list */\n        lmt_node.first_bound = e;\n    }\n    else {\n        var done = false;\n        var prev_bound = null;\n        var current_bound = lmt_node.first_bound;\n        while (!done) {\n            /* Do primary sort on the x field */\n            if (e.bot.x < current_bound.bot.x) {\n                /* Insert a new node mid-list */\n                if (prev_bound == null) {\n                    lmt_node.first_bound = e;\n                }\n                else {\n                    prev_bound.next_bound = e;\n                }\n                e.next_bound = current_bound;\n\n                //               EdgeNode existing_bound = current_bound ;\n                //               current_bound = e ;\n                //               current_bound.next_bound = existing_bound ;\n                //               if( lmt_node.first_bound == existing_bound )\n                //               {\n                //                  lmt_node.first_bound = current_bound ;\n                //               }\n                done = true;\n            }\n            else if (e.bot.x == current_bound.bot.x) {\n                /* Do secondary sort on the dx field */\n                if (e.dx < current_bound.dx) {\n                    /* Insert a new node mid-list */\n                    if (prev_bound == null) {\n                        lmt_node.first_bound = e;\n                    }\n                    else {\n                        prev_bound.next_bound = e;\n                    }\n                    e.next_bound = current_bound;\n                    //                  EdgeNode existing_bound = current_bound ;\n                    //                  current_bound = e ;\n                    //                  current_bound.next_bound = existing_bound ;\n                    //                  if( lmt_node.first_bound == existing_bound )\n                    //                  {\n                    //                     lmt_node.first_bound = current_bound ;\n                    //                  }\n                    done = true;\n                }\n                else {\n                    /* Head further down the list */\n                    if (current_bound.next_bound == null) {\n                        current_bound.next_bound = e;\n                        done = true;\n                    }\n                    else {\n                        prev_bound = current_bound;\n                        current_bound = current_bound.next_bound;\n                    }\n                }\n            }\n            else {\n                /* Head further down the list */\n                if (current_bound.next_bound == null) {\n                    current_bound.next_bound = e;\n                    done = true;\n                }\n                else {\n                    prev_bound = current_bound;\n                    current_bound = current_bound.next_bound;\n                }\n            }\n        }\n    }\n}\n\ngpcstatic.add_edge_to_aet = function (aet, edge) {\n    if (aet.top_node == null) {\n        /* Append edge onto the tail end of the AET */\n        aet.top_node = edge;\n        edge.prev = null;\n        edge.next = null;\n    }\n    else {\n        var current_edge = aet.top_node;\n        var prev = null;\n        var done = false;\n        while (!done) {\n            /* Do primary sort on the xb field */\n            if (edge.xb < current_edge.xb) {\n                /* Insert edge here (before the AET edge) */\n                edge.prev = prev;\n                edge.next = current_edge;\n                current_edge.prev = edge;\n                if (prev == null) {\n                    aet.top_node = edge;\n                }\n                else {\n                    prev.next = edge;\n                }\n                //               if( current_edge == aet.top_node )\n                //               {\n                //                  aet.top_node = edge ;\n                //               }\n                //               current_edge = edge ;\n                done = true;\n            }\n            else if (edge.xb == current_edge.xb) {\n                /* Do secondary sort on the dx field */\n                if (edge.dx < current_edge.dx) {\n                    /* Insert edge here (before the AET edge) */\n                    edge.prev = prev;\n                    edge.next = current_edge;\n                    current_edge.prev = edge;\n                    if (prev == null) {\n                        aet.top_node = edge;\n                    }\n                    else {\n                        prev.next = edge;\n                    }\n                    //                  if( current_edge == aet.top_node )\n                    //                  {\n                    //                     aet.top_node = edge ;\n                    //                  }\n                    //                  current_edge = edge ;\n                    done = true;\n                }\n                else {\n                    /* Head further into the AET */\n                    prev = current_edge;\n                    if (current_edge.next == null) {\n                        current_edge.next = edge;\n                        edge.prev = current_edge;\n                        edge.next = null;\n                        done = true;\n                    }\n                    else {\n                        current_edge = current_edge.next;\n                    }\n                }\n            }\n            else {\n                /* Head further into the AET */\n                prev = current_edge;\n                if (current_edge.next == null) {\n                    current_edge.next = edge;\n                    edge.prev = current_edge;\n                    edge.next = null;\n                    done = true;\n                }\n                else {\n                    current_edge = current_edge.next;\n                }\n            }\n        }\n    }\n}\n\ngpcstatic.add_to_sbtree = function (sbte, y) {\n    if (sbte.sb_tree == null) {\n        /* Add a new tree node here */\n        sbte.sb_tree = new gpcas.geometry.ScanBeamTree(y);\n        sbte.sbt_entries++;\n        return;\n    }\n    var tree_node = sbte.sb_tree;\n    var done = false;\n    while (!done) {\n        if (tree_node.y > y) {\n            if (tree_node.less == null) {\n                tree_node.less = new gpcas.geometry.ScanBeamTree(y);\n                sbte.sbt_entries++;\n                done = true;\n            }\n            else {\n                tree_node = tree_node.less;\n            }\n        }\n        else if (tree_node.y < y) {\n            if (tree_node.more == null) {\n                tree_node.more = new gpcas.geometry.ScanBeamTree(y);\n                sbte.sbt_entries++;\n                done = true;\n            }\n            else {\n                tree_node = tree_node.more;\n            }\n        }\n        else {\n            done = true;\n        }\n    }\n}\n\n\ngpcstatic.build_lmt = function (lmt_table,\n                                sbte,\n                                p,\n                                type, //poly type SUBJ/Clip.CLIP\n                                op) {\n    /* Create the entire input polygon edge table in one go */\n    var edge_table = new gpcas.geometry.EdgeTable();\n\n    for (var c = 0; c < p.getNumInnerPoly(); c++) {\n        var ip = p.getInnerPoly(c);\n        if (!ip.isContributing(0)) {\n            /* Ignore the non-contributing contour */\n            ip.setContributing(0, true);\n        }\n        else {\n\n\n            /* Perform contour optimisation */\n            var num_vertices = 0;\n            var e_index = 0;\n            edge_table = new gpcas.geometry.EdgeTable();\n            for (var i = 0; i < ip.getNumPoints(); i++) {\n                if (gpcas.geometry.Clip.OPTIMAL(ip, i)) {\n                    var x = ip.getX(i);\n                    var y = ip.getY(i);\n                    edge_table.addNode(x, y);\n\n                    /* Record vertex in the scanbeam table */\n                    gpcas.geometry.Clip.add_to_sbtree(sbte, ip.getY(i));\n\n                    num_vertices++;\n                }\n            }\n\n            /* Do the contour forward pass */\n\n            for (var min = 0; min < num_vertices; min++) {\n                /* If a forward local minimum... */\n                if (edge_table.FWD_MIN(min)) {\n                    /* Search for the next local maximum... */\n                    var num_edges = 1;\n                    var max = gpcas.geometry.Clip.NEXT_INDEX(min, num_vertices);\n                    while (edge_table.NOT_FMAX(max)) {\n                        num_edges++;\n                        max = gpcas.geometry.Clip.NEXT_INDEX(max, num_vertices);\n                    }\n\n                    /* Build the next edge list */\n                    var v = min;\n                    var e = edge_table.getNode(e_index);\n                    e.bstate[gpcas.geometry.Clip.BELOW] = gpcas.geometry.BundleState.UNBUNDLED;\n                    e.bundle[gpcas.geometry.Clip.BELOW][Clip.CLIP] = 0;\n                    e.bundle[gpcas.geometry.Clip.BELOW][Clip.SUBJ] = 0;\n\n                    for (var i = 0; i < num_edges; i++) {\n                        var ei = edge_table.getNode(e_index + i);\n                        var ev = edge_table.getNode(v);\n\n                        ei.xb = ev.vertex.x;\n                        ei.bot.x = ev.vertex.x;\n                        ei.bot.y = ev.vertex.y;\n\n                        v = gpcas.geometry.Clip.NEXT_INDEX(v, num_vertices);\n                        ev = edge_table.getNode(v);\n\n                        ei.top.x = ev.vertex.x;\n                        ei.top.y = ev.vertex.y;\n                        ei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n                        ei.type = type;\n                        ei.outp[gpcas.geometry.Clip.ABOVE] = null;\n                        ei.outp[gpcas.geometry.Clip.BELOW] = null;\n                        ei.next = null;\n                        ei.prev = null;\n                        ei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index + i + 1) : null;\n                        ei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index + i - 1) : null;\n                        ei.next_bound = null;\n                        ei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n                        ei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n                    }\n                    Clip.insert_bound(gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n                    if (gpcas.geometry.Clip.DEBUG) {\n                        //console.log(\"fwd\");\n                        lmt_table.print();\n                    }\n                    e_index += num_edges;\n                }\n            }\n\n            /* Do the contour reverse pass */\n            for (var min = 0; min < num_vertices; min++) {\n                /* If a reverse local minimum... */\n                if (edge_table.REV_MIN(min)) {\n                    /* Search for the previous local maximum... */\n                    var num_edges = 1;\n                    var max = gpcas.geometry.Clip.PREV_INDEX(min, num_vertices);\n                    while (edge_table.NOT_RMAX(max)) {\n                        num_edges++;\n                        max = gpcas.geometry.Clip.PREV_INDEX(max, num_vertices);\n                    }\n\n                    /* Build the previous edge list */\n                    var v = min;\n                    var e = edge_table.getNode(e_index);\n                    e.bstate[gpcas.geometry.Clip.BELOW] = BundleState.UNBUNDLED;\n                    e.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.CLIP] = 0;\n                    e.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.SUBJ] = 0;\n\n                    for (var i = 0; i < num_edges; i++) {\n                        var ei = edge_table.getNode(e_index + i);\n                        var ev = edge_table.getNode(v);\n\n                        ei.xb = ev.vertex.x;\n                        ei.bot.x = ev.vertex.x;\n                        ei.bot.y = ev.vertex.y;\n\n                        v = gpcas.geometry.Clip.PREV_INDEX(v, num_vertices);\n                        ev = edge_table.getNode(v);\n\n                        ei.top.x = ev.vertex.x;\n                        ei.top.y = ev.vertex.y;\n                        ei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n                        ei.type = type;\n                        ei.outp[gpcas.geometry.Clip.ABOVE] = null;\n                        ei.outp[gpcas.geometry.Clip.BELOW] = null;\n                        ei.next = null;\n                        ei.prev = null;\n                        ei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index + i + 1) : null;\n                        ei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index + i - 1) : null;\n                        ei.next_bound = null;\n                        ei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n                        ei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n                    }\n                    Clip.insert_bound(gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n                    if (gpcas.geometry.Clip.DEBUG) {\n                        //console.log(\"rev\");\n                        lmt_table.print();\n                    }\n                    e_index += num_edges;\n                }\n            }\n        }\n    }\n    return edge_table;\n}\n\n\ngpcstatic.add_st_edge = function (st, it, edge, dy) {\n    if (st == null) {\n        /* Append edge onto the tail end of the ST */\n        st = new gpcas.geometry.StNode(edge, null);\n    }\n    else {\n        var den = (st.xt - st.xb) - (edge.xt - edge.xb);\n\n        /* If new edge and ST edge don't cross */\n        if ((edge.xt >= st.xt) || (edge.dx == st.dx) || (Math.abs(den) <= gpcas.geometry.Clip.GPC_EPSILON)) {\n            /* No intersection - insert edge here (before the ST edge) */\n            var existing_node = st;\n            st = new StNode(edge, existing_node);\n        }\n        else {\n            /* Compute intersection between new edge and ST edge */\n            var r = (edge.xb - st.xb) / den;\n            var x = st.xb + r * (st.xt - st.xb);\n            var y = r * dy;\n\n            /* Insert the edge pointers and the intersection point in the IT */\n            it.top_node = gpcas.geometry.Clip.add_intersection(it.top_node, st.edge, edge, x, y);\n\n            /* Head further into the ST */\n            st.prev = gpcas.geometry.Clip.add_st_edge(st.prev, it, edge, dy);\n        }\n    }\n    return st;\n}\n\n\ngpcstatic.add_intersection = function (it_node,\n                                       edge0,\n                                       edge1,\n                                       x,\n                                       y) {\n    if (it_node == null) {\n        /* Append a new node to the tail of the list */\n        it_node = new gpcas.geometry.ItNode(edge0, edge1, x, y, null);\n    }\n    else {\n        if (it_node.point.y > y) {\n            /* Insert a new node mid-list */\n            var existing_node = it_node;\n            it_node = new gpcas.geometry.ItNode(edge0, edge1, x, y, existing_node);\n        }\n        else {\n            /* Head further down the list */\n            it_node.next = gpcas.geometry.Clip.add_intersection(it_node.next, edge0, edge1, x, y);\n        }\n    }\n    return it_node;\n}\n\n\n/////////// AetTree ////////////////////////////////////\ngpcas.geometry.AetTree = function () {\n    this.top_node = null; //EdgeNode\n};\nAetTree = gpcas.geometry.AetTree;\ngpcas.geometry.AetTree.prototype.print = function () {\n    //console.log(\"aet\");\n    for (var edge = this.top_node; (edge != null); edge = edge.next) {\n        //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n    }\n}\n\n\n///////////////  BundleState  //////////////////////////////\ngpcas.geometry.BundleState = function (state) {\n    this.m_State = state; //String\n};\ngpcas.geometry.BundleState.UNBUNDLED = new gpcas.geometry.BundleState(\"UNBUNDLED\");\ngpcas.geometry.BundleState.BUNDLE_HEAD = new gpcas.geometry.BundleState(\"BUNDLE_HEAD\");\ngpcas.geometry.BundleState.BUNDLE_TAIL = new gpcas.geometry.BundleState(\"BUNDLE_TAIL\");\ngpcas.geometry.BundleState.prototype.toString = function () {\n    return this.m_State;\n};\nBundleState = gpcas.geometry.BundleState;\n\n/////////////// EdgeNode ////////////////////////////\ngpcas.geometry.EdgeNode = function () {\n    this.vertex = new Point();\n    /* Piggy-backed contour vertex data  */\n    this.bot = new Point();\n    /* Edge lower (x, y) coordinate      */\n    this.top = new Point();\n    /* Edge upper (x, y) coordinate      */\n    this.xb;\n    /* Scanbeam bottom x coordinate      */\n    this.xt;\n    /* Scanbeam top x coordinate         */\n    this.dx;\n    /* Change in x for a unit y increase */\n    this.type;\n    /* Clip / subject edge flag          */\n    this.bundle = ArrayHelper.create2DArray(2, 2);\n    /* Bundle edge flags                 */\n    this.bside = [];\n    /* Bundle left / right indicators    */\n    this.bstate = [];\n    /* Edge bundle state                 */\n    this.outp = [];\n    /* Output polygon / tristrip pointer */\n    this.prev;\n    /* Previous edge in the AET          */\n    this.next;\n    /* Next edge in the AET              */\n    this.pred;\n    /* Edge connected at the lower end   */\n    this.succ;\n    /* Edge connected at the upper end   */\n    this.next_bound;\n    /* Pointer to next bound in LMT      */\n};\n\n\n////////////////   EdgeTable /////////////////////////////////////////\n\n\ngpcas.geometry.EdgeTable = function () {\n    this.m_List = new gpcas.util.ArrayList();\n};\ngpcas.geometry.EdgeTable.prototype.addNode = function (x, y) {\n    var node = new gpcas.geometry.EdgeNode();\n    node.vertex.x = x;\n    node.vertex.y = y;\n    this.m_List.add(node);\n\n}\ngpcas.geometry.EdgeTable.prototype.getNode = function (index) {\n    return this.m_List.get(index);\n}\ngpcas.geometry.EdgeTable.prototype.FWD_MIN = function (i) {\n    var m_List = this.m_List;\n\n    var prev = (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next = (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n\n    return ((prev.vertex.y >= ith.vertex.y) &&\n    (next.vertex.y > ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_FMAX = function (i) {\n    var m_List = this.m_List;\n\n    var next = (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n    return (next.vertex.y > ith.vertex.y);\n}\ngpcas.geometry.EdgeTable.prototype.REV_MIN = function (i) {\n    var m_List = this.m_List;\n\n    var prev = (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next = (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n    return ((prev.vertex.y > ith.vertex.y) && (next.vertex.y >= ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_RMAX = function (i) {\n    var m_List = this.m_List;\n\n    var prev = (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n    return (prev.vertex.y > ith.vertex.y);\n}\n\n\n/////////////////////   HState   //////////////////////////////////////\ngpcas.geometry.HState = function () {\n};\ngpcas.geometry.HState.NH = 0;\n/* No horizontal edge                */\ngpcas.geometry.HState.BH = 1;\n/* Bottom horizontal edge            */\ngpcas.geometry.HState.TH = 2;\n/* Top horizontal edge               */\n\nHState = gpcas.geometry.HState;\n\nvar NH = gpcas.geometry.HState.NH;\nvar BH = gpcas.geometry.HState.BH;\nvar TH = gpcas.geometry.HState.TH;\n\n/* Horizontal edge state transitions within scanbeam boundary */\ngpcas.geometry.HState.next_h_state =\n    [\n        /*        ABOVE     BELOW     CROSS */\n        /*        L   R     L   R     L   R */\n        /* NH */ [BH, TH, TH, BH, NH, NH],\n        /* BH */ [NH, NH, NH, NH, TH, TH],\n        /* TH */ [NH, NH, NH, NH, BH, BH]\n    ];\n\n\n///////////////////////    \t  IntersectionPoint /////////////////////////////\ngpcas.geometry.IntersectionPoint = function (p1, p2, p3) {\n    this.polygonPoint1 = p1;\n    /* of Point */\n    ;\n    this.polygonPoint2 = p2;\n    /* of Point */\n    ;\n    this.intersectionPoint = p3;\n};\ngpcas.geometry.IntersectionPoint.prototype.toString = function () {\n    return \"P1 :\" + polygonPoint1.toString() + \" P2:\" + polygonPoint2.toString() + \" IP:\" + intersectionPoint.toString();\n}\n\n\n///////////////////////////    ItNode   ///////////////\ngpcas.geometry.ItNode = function (edge0, edge1, x, y, next) {\n    this.ie = [];\n    /* Intersecting edge (bundle) pair   */\n    this.point = new Point(x, y);\n    /* Point of intersection             */\n    this.next = next;\n    /* The next intersection table node  */\n\n    this.ie[0] = edge0;\n    this.ie[1] = edge1;\n\n};\n\n\n///////////////////////////    ItNodeTable   ///////////////\ngpcas.geometry.ItNodeTable = function () {\n    this.top_node;\n}\nItNodeTable = gpcas.geometry.ItNodeTable;\n\ngpcas.geometry.ItNodeTable.prototype.build_intersection_table = function (aet, dy) {\n    var st = null;\n\n    /* Process each AET edge */\n    for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n        if ((edge.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) ||\n            (edge.bundle[Clip.ABOVE][Clip.CLIP] != 0) ||\n            (edge.bundle[Clip.ABOVE][Clip.SUBJ] != 0)) {\n            st = gpcas.geometry.Clip.add_st_edge(st, this, edge, dy);\n        }\n\n\n    }\n}\n\n////////////// Line //////////////////////////\ngpcas.geometry.Line = function () {\n    this.start;\n    this.end;\n}\n\n////////////   LineHelper /////////////////////\n\ngpcas.geometry.LineHelper = function () {\n};\ngpcas.geometry.LineHelper.equalPoint = function (p1, p2) {\n    return ((p1[0] == p2[0]) && (p1[1] == p2[1]));\n}\ngpcas.geometry.LineHelper.equalVertex = function (s1, e1, s2, e2) {\n    return (\n    ((gpcas.geometry.LineHelper.equalPoint(s1, s2)) && (gpcas.geometry.LineHelper.equalPoint(e1, e2)))\n    ||\n    ((gpcas.geometry.LineHelper.equalPoint(s1, e2)) && (gpcas.geometry.LineHelper.equalPoint(e1, s2)))\n    );\n}\ngpcas.geometry.LineHelper.distancePoints = function (p1, p2) {\n    return Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\n}\ngpcas.geometry.LineHelper.clonePoint = function (p) {\n    return [p[0], p[1]];\n}\ngpcas.geometry.LineHelper.cloneLine = function (line) {\n    var res = [];\n    for (var i = 0; i < line.length; i++) {\n        res[i] = [line[i][0], line[i][1]];\n    }\n    return res;\n}\ngpcas.geometry.LineHelper.addLineToLine = function (line1, line2) {\n    for (var i = 0; i < line2.length; i++) {\n        line1.push(clonePoint(line2[i]));\n    }\n}\ngpcas.geometry.LineHelper.roundPoint = function (p) {\n    p[0] = Math.round(p[0]);\n    p[1] = Math.round(p[1]);\n}\n//---------------------------------------------------------------\n//Checks for intersection of Segment if as_seg is true.\n//Checks for intersection of Line if as_seg is false.\n//Return intersection of Segment \"AB\" and Segment \"EF\" as a Point\n//Return null if there is no intersection\n//---------------------------------------------------------------\ngpcas.geometry.LineHelper.lineIntersectLine = function (A, B, E, F, as_seg) {\n    if (as_seg == null) as_seg = true;\n    var ip;\n    var a1;\n    var a2;\n    var b1;\n    var b2;\n    var c1;\n    var c2;\n\n    a1 = B.y - A.y;\n    b1 = A.x - B.x;\n    c1 = B.x * A.y - A.x * B.y;\n    a2 = F.y - E.y;\n    b2 = E.x - F.x;\n    c2 = F.x * E.y - E.x * F.y;\n\n    var denom = a1 * b2 - a2 * b1;\n    if (denom == 0) {\n        return null;\n    }\n    ip = new Point();\n    ip.x = (b1 * c2 - b2 * c1) / denom;\n    ip.y = (a2 * c1 - a1 * c2) / denom;\n\n    //---------------------------------------------------\n    //Do checks to see if intersection to endpoints\n    //distance is longer than actual Segments.\n    //Return null if it is with any.\n    //---------------------------------------------------\n    if (as_seg) {\n        if (Math.pow((ip.x - B.x) + (ip.y - B.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)) {\n            return null;\n        }\n        if (Math.pow((ip.x - A.x) + (ip.y - A.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)) {\n            return null;\n        }\n\n        if (Math.pow((ip.x - F.x) + (ip.y - F.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)) {\n            return null;\n        }\n        if (Math.pow((ip.x - E.x) + (ip.y - E.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)) {\n            return null;\n        }\n    }\n    return new Point(Math.round(ip.x), Math.round(ip.y));\n}\n\n\n//////////////  LineIntersection  ///////////////////////\ngpcas.geometry.LineIntersection = function () {\n};\ngpcas.geometry.LineIntersection.iteratePoints = function (points, s1, s2, e1, e2) {\n    var direction = true;\n    var pl = points.length;\n    var s1Ind = points.indexOf(s1);\n    var s2Ind = points.indexOf(s2);\n    var start = s1Ind;\n\n    if (s2Ind > s1Ind) direction = false;\n    var newPoints = [];\n    var point;\n\n    if (direction) {\n        for (var i = 0; i < pl; i++) {\n            point = (i + start < pl) ? points[i + start] : points[i + start - pl];\n            newPoints.push(point);\n            if ((equals(point, e1)) || (equals(point, e2))) {\n                break;\n            }\n        }\n    } else {\n        for (var i = pl; i >= 0; i--) {\n            point = (i + start < pl) ? points[i + start] : points[i + start - pl];\n            newPoints.push(point);\n            if ((equals(point, e1)) || (equals(point, e2))) {\n                break;\n            }\n        }\n    }\n\n    return newPoints;\n}\n\ngpcas.geometry.LineIntersection.intersectPoly = function (poly, line /* of Points */) {\n    var res = [];\n    var numPoints = poly.getNumPoints();\n\n    //points\n    var ip;\n    var p1;\n    var p2;\n    var p3;\n    var p4;\n    var firstIntersection = null;\n    var lastIntersection = null;\n    var firstIntersectionLineIndex = -1;\n    var lastIntersectionLineIndex = -1;\n    var firstFound = false;\n\n    for (var i = 1; i < line.length; i++) {\n        p1 = line[i - 1];\n        p2 = line[i];\n        var maxDist = 0;\n        var minDist = Number.MAX_VALUE;\n        var dist = -1;\n        for (var j = 0; j < numPoints; j++) {\n            p3 = poly.getPoint(j == 0 ? numPoints - 1 : j - 1);\n            p4 = poly.getPoint(j);\n            if ((ip = LineHelper.lineIntersectLine(p1, p2, p3, p4)) != null) {\n                dist = Point.distance(ip, p2);\n\n                if ((dist > maxDist) && (!firstFound)) {\n                    maxDist = dist;\n                    firstIntersection = new IntersectionPoint(p3, p4, ip);\n                    firstIntersectionLineIndex = i;\n                }\n                if (dist < minDist) {\n                    minDist = dist;\n                    lastIntersection = new IntersectionPoint(p3, p4, ip);\n                    lastIntersectionLineIndex = i - 1;\n                }\n            }\n        }\n        firstFound = (firstIntersection != null);\n    }\n    /*\n     Alert.show(firstIntersection.toString());\n     Alert.show(lastIntersection.toString());*/\n    if ((firstIntersection != null) && (lastIntersection != null)) {\n        var newLine /* of Point */ = [];\n        newLine[0] = firstIntersection.intersectionPoint;\n        var j = 1;\n        for (var i = firstIntersectionLineIndex; i <= lastIntersectionLineIndex; i++) {\n            newLine[j++] = line[i];\n        }\n        newLine[newLine.length - 1] = lastIntersection.intersectionPoint;\n        if (\n            (\n            (equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint1)) &&\n            (equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint2))\n            ) ||\n            (\n            (equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint2)) &&\n            (equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint1))\n            )\n        ) {\n            var poly1 = new gpcas.geometry.PolySimple();\n            poly1.add(newLine);\n            var finPoly1 = poly.intersection(poly1);\n            var finPoly2 = poly.xor(poly1);\n            if ((checkPoly(finPoly1)) && (checkPoly(finPoly2))) {\n                return [finPoly1, finPoly2];\n            }\n        } else {\n            var points1 = iteratePoints(poly.getPoints(), firstIntersection.polygonPoint1, firstIntersection.polygonPoint2, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n            points1 = points1.concat(newLine.reverse());\n            var points2 = iteratePoints(poly.getPoints(), firstIntersection.polygonPoint2, firstIntersection.polygonPoint1, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n            points2 = points2.concat(newLine);\n            var poly1 = new gpcas.geometry.PolySimple();\n            poly1.add(points1);\n            var poly2 = new gpcas.geometry.PolySimple();\n            poly2.add(points2);\n            var finPoly1 = poly.intersection(poly1);\n            var finPoly2 = poly.intersection(poly2);\n\n            if ((checkPoly(finPoly1)) && (checkPoly(finPoly2))) {\n                return [finPoly1, finPoly2];\n            }\n        }\n    }\n    return null;\n}\ngpcas.geometry.LineIntersection.checkPoly = function (poly) {\n    var noHoles = 0;\n    for (var i = 0; i < poly.getNumInnerPoly(); i++) {\n        var innerPoly = poly.getInnerPoly(i);\n        if (innerPoly.isHole()) {\n            return false;\n        } else {\n            noHoles++;\n        }\n        if (noHoles > 1) return false;\n    }\n    return true;\n}\n\n\n///////////  LmtNode //////////////////////////\n\ngpcas.geometry.LmtNode = function (yvalue) {\n    this.y = yvalue;\n    /* Y coordinate at local minimum     */\n    this.first_bound;\n    /* Pointer to bound list             */\n    this.next;\n    /* Pointer to next local minimum     */\n};\nLmtNode = gpcas.geometry.LmtNode;\n\n////////////// LmtTable ///////////////\n\ngpcas.geometry.LmtTable = function () {\n    this.top_node;\n};\ngpcas.geometry.LmtTable.prototype.print = function () {\n    var n = 0;\n    var lmt = this.top_node;\n    while (lmt != null) {\n        //console.log(\"lmt(\"+n+\")\");\n        for (var edge = lmt.first_bound; (edge != null); edge = edge.next_bound) {\n            //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n        }\n        n++;\n        lmt = lmt.next;\n    }\n}\n\n/////////////   OperationType //////////////////////////////////\ngpcas.geometry.OperationType = function (type) {\n    this.m_Type = type;\n}\ngpcas.geometry.OperationType.GPC_DIFF = new gpcas.geometry.OperationType(\"Difference\");\ngpcas.geometry.OperationType.GPC_INT = new gpcas.geometry.OperationType(\"Intersection\");\ngpcas.geometry.OperationType.GPC_XOR = new gpcas.geometry.OperationType(\"Exclusive or\");\ngpcas.geometry.OperationType.GPC_UNION = new gpcas.geometry.OperationType(\"Union\");\n\n//////////// Poly  /////////////////////\n// ---> an interface\n\n\n/////////////// PolyDefault  /////////////////////\n/**\n * <code>PolyDefault</code> is a default <code>Poly</code> implementation.\n * It provides support for both complex and simple polygons.  A <i>complex polygon</i>\n * is a polygon that consists of more than one polygon.  A <i>simple polygon</i> is a\n * more traditional polygon that contains of one inner polygon and is just a\n * collection of points.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty <code>PolyDefault</code>\n * object, it will create an inner polygon of type <code>PolySimple</code>.\n *\n * @see PolySimple\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolyDefault = function (isHole) {\n    if (isHole == null) isHole = false;\n\n    /**\n     * Only applies to the first poly and can only be used with a poly that contains one poly\n     */\n    this.m_IsHole = isHole;\n    this.m_List = new gpcas.util.ArrayList();\n}\n/**\n * Return true if the given object is equal to this one.\n */\ngpcas.geometry.PolyDefault.prototype.equals = function (obj) {\n    if (!(obj instanceof PolyDefault)) {\n        return false;\n    }\n    var that = obj;\n\n    if (this.m_IsHole != that.m_IsHole) return false;\n    if (!equals(this.m_List, that.m_List)) return false;\n\n    return true;\n}\n/**\n * Return the hashCode of the object.\n *\n * @return an integer value that is the same for two objects\n * whenever their internal representation is the same (equals() is true)\n **/\ngpcas.geometry.PolyDefault.prototype.hashCode = function () {\n    var m_List = this.m_List;\n\n    var result = 17;\n    result = 37 * result + m_List.hashCode();\n    return result;\n}\n/**\n * Remove all of the points.  Creates an empty polygon.\n */\ngpcas.geometry.PolyDefault.prototype.clear = function () {\n    this.m_List.clear();\n}\n\ngpcas.geometry.PolyDefault.prototype.add = function (arg0, arg1) {\n    var args = [];\n\n    args[0] = arg0;\n    if (arg1) {\n        args[1] = arg1;\n    }\n    if (args.length == 2) {\n        this.addPointXY(args[0], args[1]);\n    } else if (args.length == 1) {\n        if (args[0] instanceof Point) {\n            this.addPoint(args[0]);\n        } else if (args[0] instanceof gpcas.geometry.PolySimple) {\n            this.addPoly(args[0]);\n        } else if (args[0] instanceof Array) {\n            var arr = args[0];\n            if ((arr.length == 2) && (arr[0] instanceof Number) && (arr[1] instanceof Number)) {\n                this.add(arr[0], arr[1])\n            } else {\n                for (var i = 0; i < args[0].length; i++) {\n                    this.add(args[0][i]);\n                }\n            }\n        }\n    }\n}\n/**\n * Add a point to the first inner polygon.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n * it will create an inner polygon of type <code>PolySimple</code>.\n */\ngpcas.geometry.PolyDefault.prototype.addPointXY = function (x, y) {\n    this.addPoint(new Point(x, y));\n}\n/**\n * Add a point to the first inner polygon.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n * it will create an inner polygon of type <code>PolySimple</code>.\n */\ngpcas.geometry.PolyDefault.prototype.addPoint = function (p) {\n\n\n    var m_List = this.m_List;\n\n    if (m_List.size() == 0) {\n        m_List.add(new gpcas.geometry.PolySimple());\n    }\n    (m_List.get(0)).addPoint(p);\n}\n/**\n * Add an inner polygon to this polygon - assumes that adding polygon does not\n * have any inner polygons.\n *\n * @throws IllegalStateException if the number of inner polygons is greater than\n * zero and this polygon was designated a hole.  This would break the assumption\n * that only simple polygons can be holes.\n */\ngpcas.geometry.PolyDefault.prototype.addPoly = function (p) {\n\n    var m_IsHole = this.m_IsHole;\n    var m_List = this.m_List;\n\n    if ((m_List.size() > 0) && m_IsHole) {\n        alert(\"ERROR : Cannot add polys to something designated as a hole.\");\n    }\n    m_List.add(p);\n}\n/**\n * Return true if the polygon is empty\n */\ngpcas.geometry.PolyDefault.prototype.isEmpty = function () {\n    return this.m_List.isEmpty();\n}\n/**\n * Returns the bounding rectangle of this polygon.\n * <strong>WARNING</strong> Not supported on complex polygons.\n */\ngpcas.geometry.PolyDefault.prototype.getBounds = function () {\n    var m_List = this.m_List;\n    if (m_List.size() == 0) {\n        return new Rectangle();\n    }\n    else if (m_List.size() == 1) {\n        var ip = this.getInnerPoly(0);\n        return ip.getBounds();\n    }\n    else {\n        console.log(\"getBounds not supported on complex poly.\");\n    }\n}\n/**\n * Returns the polygon at this index.\n */\ngpcas.geometry.PolyDefault.prototype.getInnerPoly = function (polyIndex) {\n    return this.m_List.get(polyIndex);\n}\n/**\n * Returns the number of inner polygons - inner polygons are assumed to return one here.\n */\ngpcas.geometry.PolyDefault.prototype.getNumInnerPoly = function () {\n    var m_List = this.m_List;\n    return m_List.size();\n}\n/**\n * Return the number points of the first inner polygon\n */\ngpcas.geometry.PolyDefault.prototype.getNumPoints = function () {\n    return (this.m_List.get(0)).getNumPoints();\n}\n\n/**\n * Return the X value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolyDefault.prototype.getX = function (index) {\n    return (this.m_List.get(0)).getX(index);\n}\ngpcas.geometry.PolyDefault.prototype.getPoint = function (index) {\n    return (this.m_List.get(0)).getPoint(index);\n}\n\ngpcas.geometry.PolyDefault.prototype.getPoints = function () {\n    return (this.m_List.get(0)).getPoints();\n}\n\n\ngpcas.geometry.PolyDefault.prototype.isPointInside = function (point) {\n    var m_List = this.m_List;\n    if (!(m_List.get(0)).isPointInside(point)) return false;\n\n    for (var i = 0; i < m_List.size(); i++) {\n        var poly = m_List.get(i);\n        if ((poly.isHole()) && (poly.isPointInside(point))) return false;\n    }\n    return true;\n}\n/**\n * Return the Y value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolyDefault.prototype.getY = function (index) {\n    var m_List = this.m_List;\n    return (m_List.get(0)).getY(index);\n}\n\n/**\n * Return true if this polygon is a hole.  Holes are assumed to be inner polygons of\n * a more complex polygon.\n *\n * @throws IllegalStateException if called on a complex polygon.\n */\ngpcas.geometry.PolyDefault.prototype.isHole = function () {\n    var m_List = this.m_List;\n    var m_IsHole = this.m_IsHole;\n\n    if (m_List.size() > 1) {\n        alert(\"Cannot call on a poly made up of more than one poly.\");\n    }\n    return m_IsHole;\n}\n\n/**\n * Set whether or not this polygon is a hole.  Cannot be called on a complex polygon.\n *\n * @throws IllegalStateException if called on a complex polygon.\n */\ngpcas.geometry.PolyDefault.prototype.setIsHole = function (isHole) {\n    var m_List = this.m_List;\n    if (m_List.size() > 1) {\n        alert(\"Cannot call on a poly made up of more than one poly.\");\n    }\n    this.m_IsHole = isHole;\n}\n\n/**\n * Return true if the given inner polygon is contributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n */\ngpcas.geometry.PolyDefault.prototype.isContributing = function (polyIndex) {\n    var m_List = this.m_List;\n    return (m_List.get(polyIndex)).isContributing(0);\n}\n\n/**\n * Set whether or not this inner polygon is constributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n *\n * @throws IllegalStateException if called on a complex polygon\n */\ngpcas.geometry.PolyDefault.prototype.setContributing = function (polyIndex, contributes) {\n    var m_List = this.m_List;\n    if (m_List.size() != 1) {\n        alert(\"Only applies to polys of size 1\");\n    }\n    (m_List.get(polyIndex)).setContributing(0, contributes);\n}\n\n/**\n * Return a Poly that is the intersection of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.intersection = function (p) {\n    return gpcas.geometry.Clip.intersection(p, this, \"PolyDefault\");\n}\n\n/**\n * Return a Poly that is the union of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.union = function (p) {\n    return gpcas.geometry.Clip.union(p, this, \"PolyDefault\");\n}\n\n/**\n * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.xor = function (p) {\n    return gpcas.geometry.Clip.xor(p, this, \"PolyDefault\");\n}\n\n/**\n * Return a Poly that is the difference of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.difference = function (p) {\n    return gpcas.geometry.Clip.difference(p, this, \"PolyDefault\");\n}\n\n/**\n * Return the area of the polygon in square units.\n */\ngpcas.geometry.PolyDefault.prototype.getArea = function () {\n    var area = 0.0;\n    for (var i = 0; i < getNumInnerPoly(); i++) {\n        var p = getInnerPoly(i);\n        var tarea = p.getArea() * (p.isHole() ? -1.0 : 1.0);\n        area += tarea;\n    }\n    return area;\n}\n\n// -----------------------\n// --- Package Methods ---\n// -----------------------\ngpcas.geometry.PolyDefault.prototype.toString = function () {\n    var res = \"\";\n    var m_List = this.m_List;\n    for (var i = 0; i < m_List.size(); i++) {\n        var p = this.getInnerPoly(i);\n        res += (\"InnerPoly(\" + i + \").hole=\" + p.isHole());\n        var points = [];\n        for (var j = 0; j < p.getNumPoints(); j++) {\n            points.push(new Point(p.getX(j), p.getY(j)));\n        }\n        points = ArrayHelper.sortPointsClockwise(points);\n\n        for (var k = 0; k < points.length; k++) {\n            res += points[k].toString();\n        }\n\n    }\n    return res;\n}\n\n///////////////  Polygon   /////////////////////////////////\ngpcas.geometry.Polygon = function () {\n    this.maxTop;\n    this.maxBottom;\n    this.maxLeft;\n    this.maxRight;\n    this.vertices  /* of Point */;\n};\ngpcas.geometry.Polygon.prototype.fromArray = function (v) {\n    this.vertices = [];\n\n    for (var i = 0; i < v.length; i++) {\n        var pointArr = v[i];\n        this.vertices.push(new Point(pointArr[0], pointArr[1]));\n    }\n}\n\n/*Normalize vertices in polygon to be ordered clockwise from most left point*/\ngpcas.geometry.Polygon.prototype.normalize = function () {\n    var maxLeftIndex;\n    var vertices = this.vertices;\n    var newVertices = this.vertices;\n\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n\n        if ((maxTop == null) || (maxTop.y > vertex.y) || ((maxTop.y == vertex.y) && (vertex.x < maxTop.x))) {\n            maxTop = vertex;\n        }\n        if ((maxBottom == null) || (maxBottom.y < vertex.y) || ((maxBottom.y == vertex.y) && (vertex.x > maxBottom.x))) {\n            maxBottom = vertex;\n        }\n        if ((maxLeft == null) || (maxLeft.x > vertex.x) || ((maxLeft.x == vertex.x) && (vertex.y > maxLeft.y))) {\n            maxLeft = vertex;\n            maxLeftIndex = i;\n        }\n        if ((maxRight == null) || (maxRight.x < vertex.x) || ((maxRight.x == vertex.x) && (vertex.y < maxRight.y))) {\n            maxRight = vertex;\n        }\n    }\n\n    if (maxLeftIndex > 0) {\n        newVertices = [];\n        var j = 0;\n        for (var i = maxLeftIndex; i < vertices.length; i++) {\n            newVertices[j++] = this.vertices[i];\n        }\n        for (var i = 0; i < maxLeftIndex; i++) {\n            newVertices[j++] = this.vertices[i];\n        }\n        vertices = newVertices;\n    }\n    var reverse = false;\n    for (var k = 0; k < this.vertices.length; k++) {\n        var vertex = this.vertices[k];\n        if (equals(vertex, maxBottom)) {\n            reverse = true;\n            break;\n        } else if (equals(vertex, maxTop)) {\n            break;\n        }\n    }\n    if (reverse) {\n        newVertices = [];\n        newVertices[0] = vertices[0];\n        var j = 1;\n        for (var i = vertices.length - 1; i > 0; i--) {\n            newVertices[j++] = this.vertices[i];\n        }\n        vertices = newVertices;\n    }\n}\ngpcas.geometry.Polygon.prototype.getVertexIndex = function (vertex) {\n    for (var i = 0; i < this.vertices.length; i++) {\n        if (equals(vertices[i], vertex)) {\n            return i;\n        }\n    }\n    return -1;\n}\ngpcas.geometry.Polygon.prototype.insertVertex = function (vertex1, vertex2, newVertex) {\n    var vertex1Index = getVertexIndex(vertex1);\n    var vertex2Index = getVertexIndex(vertex2);\n    if ((vertex1Index == -1) || (vertex2Index == -1)) {\n        return false;\n    }\n\n    if (vertex2Index < vertex1Index) {\n        var i = vertex1Index;\n        vertex1Index = vertex2Index;\n        vertex2Index = i;\n    }\n    if (vertex2Index == vertex1Index + 1) {\n        var newVertices = [];\n        for (var i = 0; i <= vertex1Index; i++) {\n            newVertices[i] = this.vertices[i];\n        }\n        newVertices[vertex2Index] = newVertex;\n        for (var i = vertex2Index; i < this.vertices.length; i++) {\n            newVertices[i + 1] = this.vertices[i];\n        }\n        this.vertices = newVertices;\n    } else if ((vertex2Index == vertices.length - 1) && (vertex1Index == 0)) {\n        this.vertices.push(newVertex);\n    }\n    return true;\n}\ngpcas.geometry.Polygon.prototype.clone = function () {\n    var res = new gpcas.geometry.Polygon();\n    res.vertices = vertices.slice(this.vertices.length - 1);\n    return res;\n}\ngpcas.geometry.Polygon.prototype.toString = function () {\n    var vertices = this.vertices;\n    var res = \"[\";\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n        res += (i > 0 ? \",\" : \"\") + \"[\" + vertex.x + \",\" + vertex.y + \"]\";\n    }\n    res += \"]\";\n    return res;\n}\n\n\n////////////////////  PolygonNode ///////////////////////////\ngpcas.geometry.PolygonNode = function (next, x, y) {\n\n\n    this.active;\n    /* Active flag / vertex count        */\n    this.hole;\n    /* Hole / external contour flag      */\n    this.v = [];\n    /* Left and right vertex list ptrs   */\n    this.next;\n    /* Pointer to next polygon contour   */\n    this.proxy;\n    /* Pointer to actual structure used  */\n\n    /* Make v[Clip.LEFT] and v[Clip.RIGHT] point to new vertex */\n    var vn = new VertexNode(x, y);\n\n    this.v[Clip.LEFT] = vn;\n    this.v[Clip.RIGHT] = vn;\n\n    this.next = next;\n    this.proxy = this;\n    /* Initialise proxy to point to p itself */\n    this.active = 1; //TRUE\n}\ngpcas.geometry.PolygonNode.prototype.add_right = function (x, y) {\n    var nv = new VertexNode(x, y);\n\n    /* Add vertex nv to the right end of the polygon's vertex list */\n    this.proxy.v[Clip.RIGHT].next = nv;\n\n    /* Update proxy->v[Clip.RIGHT] to point to nv */\n    this.proxy.v[Clip.RIGHT] = nv;\n}\ngpcas.geometry.PolygonNode.prototype.add_left = function (x, y) {\n    var proxy = this.proxy;\n\n    var nv = new VertexNode(x, y);\n\n    /* Add vertex nv to the left end of the polygon's vertex list */\n    nv.next = proxy.v[Clip.LEFT];\n\n    /* Update proxy->[Clip.LEFT] to point to nv */\n    proxy.v[Clip.LEFT] = nv;\n}\n\n\n//////////////////   PolySimple ////////////////\n\n/**\n * <code>PolySimple</code> is a simple polygon - contains only one inner polygon.\n * <p>\n * <strong>WARNING:</strong> This type of <code>Poly</code> cannot be used for an\n * inner polygon that is a hole.\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolySimple = function () {\n    /**\n     * The list of Point objects in the polygon.\n     */\n    this.m_List = new gpcas.util.ArrayList();\n\n    /** Flag used by the Clip algorithm */\n    this.m_Contributes = true;\n};\n\n/**\n * Return true if the given object is equal to this one.\n * <p>\n * <strong>WARNING:</strong> This method failse if the first point\n * appears more than once in the list.\n */\ngpcas.geometry.PolySimple.prototype.equals = function (obj) {\n    if (!(obj instanceof PolySimple)) {\n        return false;\n    }\n\n    var that = obj;\n\n    var this_num = this.m_List.size();\n    var that_num = that.m_List.size();\n    if (this_num != that_num) return false;\n\n\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // !!! WARNING: This is not the greatest algorithm.  It fails if !!!\n    // !!! the first point in \"this\" poly appears more than once.    !!!\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    if (this_num > 0) {\n        var this_x = this.getX(0);\n        var this_y = this.getY(0);\n        var that_first_index = -1;\n        for (var that_index = 0; (that_first_index == -1) && (that_index < that_num); that_index++) {\n            var that_x = that.getX(that_index);\n            var that_y = that.getY(that_index);\n            if ((this_x == that_x) && (this_y == that_y)) {\n                that_first_index = that_index;\n            }\n        }\n        if (that_first_index == -1) return false;\n        var that_index = that_first_index;\n        for (var this_index = 0; this_index < this_num; this_index++) {\n            this_x = this.getX(this_index);\n            this_y = this.getY(this_index);\n            var that_x = that.getX(that_index);\n            var that_y = that.getY(that_index);\n\n            if ((this_x != that_x) || (this_y != that_y)) return false;\n\n            that_index++;\n            if (that_index >= that_num) {\n                that_index = 0;\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * Return the hashCode of the object.\n * <p>\n * <strong>WARNING:</strong>Hash and Equals break contract.\n *\n * @return an integer value that is the same for two objects\n * whenever their internal representation is the same (equals() is true)\n */\ngpcas.geometry.PolySimple.prototype.hashCode = function () {\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // !!! WARNING:  This hash and equals break the contract. !!!\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    var result = 17;\n    result = 37 * result + this.m_List.hashCode();\n    return result;\n}\n\n/**\n * Return a string briefly describing the polygon.\n */\ngpcas.geometry.PolySimple.prototype.toString = function () {\n    return \"PolySimple: num_points=\" + getNumPoints();\n}\n\n// --------------------\n// --- Poly Methods ---\n// --------------------\n/**\n * Remove all of the points.  Creates an empty polygon.\n */\ngpcas.geometry.PolySimple.prototype.clear = function () {\n    this.m_List.clear();\n}\n\n\ngpcas.geometry.PolySimple.prototype.add = function (arg0, arg1) {\n    var args = [];\n    args[0] = arg0;\n    if (arg1) {\n        args[1] = arg1;\n    }\n\n    if (args.length == 2) {\n        this.addPointXY(args[0], args[1]);\n    } else if (args.length == 1) {\n        if (args[0] instanceof Point) {\n            this.addPoint(args[0]);\n        } else if (args[0] instanceof Poly) {\n            this.addPoly(args[0]);\n        } else if (args[0] instanceof Array) {\n            for (var k = 0; k < args[0].length; k++) {\n                var val = args[0][k];\n                this.add(val);\n            }\n        }\n    }\n}\n\n\n/**\n * Add a point to the first inner polygon.\n */\ngpcas.geometry.PolySimple.prototype.addPointXY = function (x, y) {\n    this.addPoint(new Point(x, y));\n}\n\n/**\n * Add a point to the first inner polygon.\n */\ngpcas.geometry.PolySimple.prototype.addPoint = function (p) {\n    this.m_List.add(p);\n}\n\n/**\n * Throws IllegalStateexception if called\n */\ngpcas.geometry.PolySimple.prototype.addPoly = function (p) {\n    alert(\"Cannot add poly to a simple poly.\");\n}\n\n/**\n * Return true if the polygon is empty\n */\ngpcas.geometry.PolySimple.prototype.isEmpty = function () {\n    return this.m_List.isEmpty();\n}\n\n/**\n * Returns the bounding rectangle of this polygon.\n */\ngpcas.geometry.PolySimple.prototype.getBounds = function () {\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var xmax = -Number.MAX_VALUE;\n    var ymax = -Number.MAX_VALUE;\n\n    for (var i = 0; i < this.m_List.size(); i++) {\n        var x = this.getX(i);\n        var y = this.getY(i);\n        if (x < xmin) xmin = x;\n        if (x > xmax) xmax = x;\n        if (y < ymin) ymin = y;\n        if (y > ymax) ymax = y;\n    }\n\n    return new Rectangle(xmin, ymin, (xmax - xmin), (ymax - ymin));\n}\n\n/**\n * Returns <code>this</code> if <code>polyIndex = 0</code>, else it throws\n * IllegalStateException.\n */\ngpcas.geometry.PolySimple.prototype.getInnerPoly = function (polyIndex) {\n    if (polyIndex != 0) {\n        alert(\"PolySimple only has one poly\");\n    }\n    return this;\n}\n\n/**\n * Always returns 1.\n */\ngpcas.geometry.PolySimple.prototype.getNumInnerPoly = function () {\n    return 1;\n}\n\n/**\n * Return the number points of the first inner polygon\n */\ngpcas.geometry.PolySimple.prototype.getNumPoints = function () {\n    return this.m_List.size();\n}\n\n/**\n * Return the X value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolySimple.prototype.getX = function (index) {\n    return (this.m_List.get(index)).x;\n}\n\n/**\n * Return the Y value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolySimple.prototype.getY = function (index) {\n    return (this.m_List.get(index)).y;\n}\n\ngpcas.geometry.PolySimple.prototype.getPoint = function (index) {\n    return (this.m_List.get(index));\n}\n\ngpcas.geometry.PolySimple.prototype.getPoints = function () {\n    return this.m_List.toArray();\n}\n\ngpcas.geometry.PolySimple.prototype.isPointInside = function (point) {\n    var points = this.getPoints();\n    var j = points.length - 1;\n    var oddNodes = false;\n\n    for (var i = 0; i < points.length; i++) {\n        if (points[i].y < point.y && points[j].y >= point.y ||\n            points[j].y < point.y && points[i].y >= point.y) {\n            if (points[i].x +\n                (point.y - points[i].y) / (points[j].y - points[i].y) * (points[j].x - points[i].x) < point.x) {\n                oddNodes = !oddNodes;\n            }\n        }\n        j = i;\n    }\n    return oddNodes;\n}\n\n\n/**\n * Always returns false since PolySimples cannot be holes.\n */\ngpcas.geometry.PolySimple.prototype.isHole = function () {\n    return false;\n}\n\n/**\n * Throws IllegalStateException if called.\n */\ngpcas.geometry.PolySimple.prototype.setIsHole = function (isHole) {\n    alert(\"PolySimple cannot be a hole\");\n}\n\n/**\n * Return true if the given inner polygon is contributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n *\n * @throws IllegalStateException if <code>polyIndex != 0</code>\n */\ngpcas.geometry.PolySimple.prototype.isContributing = function (polyIndex) {\n    if (polyIndex != 0) {\n        alert(\"PolySimple only has one poly\");\n    }\n    return this.m_Contributes;\n}\n\n/**\n * Set whether or not this inner polygon is constributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n *\n * @throws IllegalStateException if <code>polyIndex != 0</code>\n */\ngpcas.geometry.PolySimple.prototype.setContributing = function (polyIndex, contributes) {\n    if (polyIndex != 0) {\n        alert(\"PolySimple only has one poly\");\n    }\n    this.m_Contributes = contributes;\n}\n\n/**\n * Return a Poly that is the intersection of this polygon with the given polygon.\n * The returned polygon is simple.\n *\n * @return The returned Poly is of type PolySimple\n */\ngpcas.geometry.PolySimple.prototype.intersection = function (p) {\n    return gpcas.geometry.Clip.intersection(this, p, \"PolySimple\");\n}\n\n/**\n * Return a Poly that is the union of this polygon with the given polygon.\n * The returned polygon is simple.\n *\n * @return The returned Poly is of type PolySimple\n */\ngpcas.geometry.PolySimple.prototype.union = function (p) {\n    return gpcas.geometry.Clip.union(this, p, \"PolySimple\");\n}\n\n/**\n * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n * The returned polygon is simple.\n *\n * @return The returned Poly is of type PolySimple\n */\ngpcas.geometry.PolySimple.prototype.xor = function (p) {\n    return gpcas.geometry.Clip.xor(p, this, \"PolySimple\");\n}\n\n/**\n * Return a Poly that is the difference of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolySimple.prototype.difference = function (p) {\n    return gpcas.geometry.Clip.difference(p, this, \"PolySimple\");\n}\n\n/**\n * Returns the area of the polygon.\n * <p>\n * The algorithm for the area of a complex polygon was take from\n * code by Joseph O'Rourke author of \" Computational Geometry in C\".\n */\ngpcas.geometry.PolySimple.prototype.getArea = function () {\n    if (this.getNumPoints() < 3) {\n        return 0.0;\n    }\n    var ax = this.getX(0);\n    var ay = this.getY(0);\n\n    var area = 0.0;\n    for (var i = 1; i < (this.getNumPoints() - 1); i++) {\n        var bx = this.getX(i);\n        var by = this.getY(i);\n        var cx = this.getX(i + 1);\n        var cy = this.getY(i + 1);\n        var tarea = ((cx - bx) * (ay - by)) - ((ax - bx) * (cy - by));\n        area += tarea;\n    }\n    area = 0.5 * Math.abs(area);\n    return area;\n}\n\n/////////////////////// Rectangle  ///////////////////\ngpcas.geometry.Rectangle = function (_x, _y, _w, _h) {\n    this.x = _x;\n    this.y = _y;\n    this.w = _w;\n    this.h = _h;\n}\ngpcas.geometry.Rectangle.prototype.getMaxY = function () {\n    return this.y + this.h;\n}\ngpcas.geometry.Rectangle.prototype.getMinY = function () {\n    return this.y;\n}\ngpcas.geometry.Rectangle.prototype.getMaxX = function () {\n    return this.x + this.w;\n}\ngpcas.geometry.Rectangle.prototype.getMinX = function () {\n    return this.x;\n}\ngpcas.geometry.Rectangle.prototype.toString = function () {\n    return \"[\" + x.toString() + \" \" + y.toString() + \" \" + w.toString() + \" \" + h.toString() + \"]\";\n}\n\n/////////////////// ScanBeamTree //////////////////////\ngpcas.geometry.ScanBeamTree = function (yvalue) {\n    this.y = yvalue;\n    /* Scanbeam node y value             */\n    this.less;\n    /* Pointer to nodes with lower y     */\n    this.more;\n    /* Pointer to nodes with higher y    */\n}\n\n///////////////////////// ScanBeamTreeEntries /////////////////\ngpcas.geometry.ScanBeamTreeEntries = function () {\n    this.sbt_entries = 0;\n    this.sb_tree;\n};\ngpcas.geometry.ScanBeamTreeEntries.prototype.build_sbt = function () {\n    var sbt = [];\n\n    var entries = 0;\n    entries = this.inner_build_sbt(entries, sbt, this.sb_tree);\n\n    //console.log(\"SBT = \"+this.sbt_entries);\n\n    if (entries != this.sbt_entries) {\n        //console.log(\"Something went wrong buildign sbt from tree.\");\n    }\n    return sbt;\n}\ngpcas.geometry.ScanBeamTreeEntries.prototype.inner_build_sbt = function (entries, sbt, sbt_node) {\n    if (sbt_node.less != null) {\n        entries = this.inner_build_sbt(entries, sbt, sbt_node.less);\n    }\n    sbt[entries] = sbt_node.y;\n    entries++;\n    if (sbt_node.more != null) {\n        entries = this.inner_build_sbt(entries, sbt, sbt_node.more);\n    }\n    return entries;\n}\n\n///////////////////////////  StNode\nStNode = gpcas.geometry.StNode = function (edge, prev) {\n    this.edge;\n    /* Pointer to AET edge               */\n    this.xb;\n    /* Scanbeam bottom x coordinate      */\n    this.xt;\n    /* Scanbeam top x coordinate         */\n    this.dx;\n    /* Change in x for a unit y increase */\n    this.prev;\n    /* Previous edge in sorted list      */\n\n    this.edge = edge;\n    this.xb = edge.xb;\n    this.xt = edge.xt;\n    this.dx = edge.dx;\n    this.prev = prev;\n}\n\n/////////////////////   TopPolygonNode /////////////////\ngpcas.geometry.TopPolygonNode = function () {\n    this.top_node;\n};\nTopPolygonNode = gpcas.geometry.TopPolygonNode;\n\ngpcas.geometry.TopPolygonNode.prototype.add_local_min = function (x, y) {\n    var existing_min = this.top_node;\n    this.top_node = new gpcas.geometry.PolygonNode(existing_min, x, y);\n    return this.top_node;\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_left = function (p, q) {\n    /* Label contour as a hole */\n    q.proxy.hole = true;\n    var top_node = this.top_node;\n\n    if (p.proxy != q.proxy) {\n        /* Assign p's vertex list to the left end of q's list */\n        p.proxy.v[Clip.RIGHT].next = q.proxy.v[Clip.LEFT];\n        q.proxy.v[Clip.LEFT] = p.proxy.v[Clip.LEFT];\n\n        /* Redirect any p.proxy references to q.proxy */\n        var target = p.proxy;\n        for (var node = top_node; (node != null); node = node.next) {\n            if (node.proxy == target) {\n                node.active = 0;\n                node.proxy = q.proxy;\n            }\n        }\n    }\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_right = function (p, q) {\n    var top_node = this.top_node;\n    /* Label contour as external */\n    q.proxy.hole = false;\n\n    if (p.proxy != q.proxy) {\n        /* Assign p's vertex list to the right end of q's list */\n        q.proxy.v[Clip.RIGHT].next = p.proxy.v[Clip.LEFT];\n        q.proxy.v[Clip.RIGHT] = p.proxy.v[Clip.RIGHT];\n\n        /* Redirect any p->proxy references to q->proxy */\n        var target = p.proxy;\n        for (var node = top_node; (node != null ); node = node.next) {\n            if (node.proxy == target) {\n                node.active = 0;\n                node.proxy = q.proxy;\n            }\n        }\n    }\n}\ngpcas.geometry.TopPolygonNode.prototype.count_contours = function () {\n    var nc = 0;\n\n    for (var polygon = this.top_node; (polygon != null); polygon = polygon.next) {\n        if (polygon.active != 0) {\n            /* Count the vertices in the current contour */\n            var nv = 0;\n            for (var v = polygon.proxy.v[Clip.LEFT]; (v != null); v = v.next) {\n                nv++;\n            }\n\n            /* Record valid vertex counts in the active field */\n            if (nv > 2) {\n                polygon.active = nv;\n                nc++;\n            }\n            else {\n                /* Invalid contour: just free the heap */\n//                  VertexNode nextv = null ;\n//                  for (VertexNode v= polygon.proxy.v[Clip.LEFT]; (v != null); v = nextv)\n//                  {\n//                     nextv= v.next;\n//                     v = null ;\n//                  }\n                polygon.active = 0;\n            }\n        }\n    }\n    return nc;\n}\ngpcas.geometry.TopPolygonNode.prototype.getResult = function (polyClass) {\n\n    var top_node = this.top_node;\n    var result = gpcas.geometry.Clip.createNewPoly(polyClass);\n//console.log(polyClass);\n\n\n    var num_contours = this.count_contours();\n\n    if (num_contours > 0) {\n        var c = 0;\n        var npoly_node = null;\n        for (var poly_node = top_node; (poly_node != null); poly_node = npoly_node) {\n            npoly_node = poly_node.next;\n            if (poly_node.active != 0) {\n\n                var poly = result;\n\n\n                if (num_contours > 1) {\n                    poly = gpcas.geometry.Clip.createNewPoly(polyClass);\n                }\n                if (poly_node.proxy.hole) {\n                    poly.setIsHole(poly_node.proxy.hole);\n                }\n\n                // ------------------------------------------------------------------------\n                // --- This algorithm puts the verticies into the poly in reverse order ---\n                // ------------------------------------------------------------------------\n                for (var vtx = poly_node.proxy.v[Clip.LEFT]; (vtx != null); vtx = vtx.next) {\n                    poly.add(vtx.x, vtx.y);\n                }\n                if (num_contours > 1) {\n                    result.addPoly(poly);\n                }\n                c++;\n            }\n        }\n\n        // -----------------------------------------\n        // --- Sort holes to the end of the list ---\n        // -----------------------------------------\n        var orig = result;\n        result = gpcas.geometry.Clip.createNewPoly(polyClass);\n        for (var i = 0; i < orig.getNumInnerPoly(); i++) {\n            var inner = orig.getInnerPoly(i);\n            if (!inner.isHole()) {\n                result.addPoly(inner);\n            }\n        }\n        for (var i = 0; i < orig.getNumInnerPoly(); i++) {\n            var inner = orig.getInnerPoly(i);\n            if (inner.isHole()) {\n                result.addPoly(inner);\n            }\n        }\n    }\n    return result;\n}\ngpcas.geometry.TopPolygonNode.prototype.print = function () {\n    //console.log(\"---- out_poly ----\");\n    var top_node = this.top_node;\n    var c = 0;\n    var npoly_node = null;\n    for (var poly_node = top_node; (poly_node != null); poly_node = npoly_node) {\n        //console.log(\"contour=\"+c+\"  active=\"+poly_node.active+\"  hole=\"+poly_node.proxy.hole);\n        npoly_node = poly_node.next;\n        if (poly_node.active != 0) {\n            var v = 0;\n            for (var vtx = poly_node.proxy.v[Clip.LEFT]; (vtx != null); vtx = vtx.next) {\n                //console.log(\"v=\"+v+\"  vtx.x=\"+vtx.x+\"  vtx.y=\"+vtx.y);\n            }\n            c++;\n        }\n    }\n}\n\n///////////    VertexNode  ///////////////\ngpcas.geometry.VertexNode = function (x, y) {\n    this.x;    // X coordinate component\n    this.y;    // Y coordinate component\n    this.next; // Pointer to next vertex in list\n\n    this.x = x;\n    this.y = y;\n    this.next = null;\n}\nVertexNode = gpcas.geometry.VertexNode;\n\n/////////////   VertexType   /////////////\ngpcas.geometry.VertexType = function () {\n};\ngpcas.geometry.VertexType.NUL = 0;\n/* Empty non-intersection            */\ngpcas.geometry.VertexType.EMX = 1;\n/* External maximum                  */\ngpcas.geometry.VertexType.ELI = 2;\n/* External left intermediate        */\ngpcas.geometry.VertexType.TED = 3;\n/* Top edge                          */\ngpcas.geometry.VertexType.ERI = 4;\n/* External right intermediate       */\ngpcas.geometry.VertexType.RED = 5;\n/* Right edge                        */\ngpcas.geometry.VertexType.IMM = 6;\n/* Internal maximum and minimum      */\ngpcas.geometry.VertexType.IMN = 7;\n/* Internal minimum                  */\ngpcas.geometry.VertexType.EMN = 8;\n/* External minimum                  */\ngpcas.geometry.VertexType.EMM = 9;\n/* External maximum and minimum      */\ngpcas.geometry.VertexType.LED = 10;\n/* Left edge                         */\ngpcas.geometry.VertexType.ILI = 11;\n/* Internal left intermediate        */\ngpcas.geometry.VertexType.BED = 12;\n/* Bottom edge                       */\ngpcas.geometry.VertexType.IRI = 13;\n/* Internal right intermediate       */\ngpcas.geometry.VertexType.IMX = 14;\n/* Internal maximum                  */\ngpcas.geometry.VertexType.FUL = 15;\n/* Full non-intersection             */\ngpcas.geometry.VertexType.getType = function (tr, tl, br, bl) {\n    return tr + (tl << 1) + (br << 2) + (bl << 3);\n}\n\nVertexType = gpcas.geometry.VertexType;\n\n////////////////// WeilerAtherton  /////////////\ngpcas.geometry.WeilerAtherton = function () {\n};\n\ngpcas.geometry.WeilerAtherton.prototype.merge = function (p1, p2) {\n    p1 = p1.clone();\n    p2 = p2.clone();\n}\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\n/*jshint -W072 */\nvar intersect = function (a10, a11, a20, a21, b10, b11, b20, b21) {\n    var ua_t = (b20 - b10) * (a11 - b11) - (b21 - b11) * (a10 - b10);\n    var ub_t = (a20 - a10) * (a11 - b11) - (a21 - a11) * (a10 - b10);\n    var u_b = (b21 - b11) * (a20 - a10) - (b20 - b10) * (a21 - a11);\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\nfunction Cell(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.items = [];\n}\n\nCell.prototype.insert = function (item) {\n    if (\n        (item.fromX >= this.x && item.fromY >= this.y && item.toX <= this.x + this.width && item.toY <= this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x + this.width, this.y) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x, this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x + this.width, this.y, this.x + this.width, this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y + this.height, this.x + this.width, this.y + this.height)\n    ) {\n        this.items.push(item);\n    }\n};\n\nmodule.exports = Cell;\n\n},{}],13:[function(require,module,exports){\n'use strict';\n\nvar Cell = require('./cell');\nvar DoublyLinkedList = require('../../linkedlist/doublylinkedlist');\n\nfunction Grid(bounds, rows, cols) {\n    this.bounds = bounds;\n    this.rows = rows;\n    this.cols = cols;\n    this.cellX = this.bounds.width / this.cols;\n    this.cellY = this.bounds.height / this.rows;\n    this.cells = [];\n    this.out = new DoublyLinkedList();\n    for (var col = 0; col < this.cols; col++) {\n        this.cells[col] = [];\n        for (var row = 0; row < this.rows; row++) {\n            this.cells[col][row] = new Cell(col * this.cellX, row * this.cellY, this.cellX, this.cellY);\n        }\n    }\n}\n\nGrid.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            n = item.length;\n        while (i < n) {\n            this.insert(item);\n            i++;\n        }\n    } else {\n        for (var col = 0; col < this.cols; col++) {\n            for (var row = 0; row < this.rows; row++) {\n                this.cells[col][row].insert(item);\n            }\n        }\n    }\n};\n\nGrid.prototype.addOut = function (items) {\n    var i = 0,\n        n = items.length;\n    while (i < n) {\n        this.out.add(items[i]);\n        i++;\n    }\n};\n\nGrid.prototype.retrieve = function (item) {\n    // figure out cells\n    var nx = ((item.x % this.cellX) + item.width) > this.cellX ? true : false,\n        ny = ((item.y % this.cellY) + item.height) > this.cellY ? true : false,\n        x = Math.floor(item.x / this.cellX),\n        y = Math.floor(item.y / this.cellY);\n    this.out.clear();\n\n    this.addOut(this.cells[x][y].items);\n    if (nx) {\n        this.addOut(this.cells[x + 1][y].items);\n    }\n    if (ny) {\n        this.addOut(this.cells[x][y + 1].items);\n    }\n    if (nx && ny) {\n        this.addOut(this.cells[x + 1][y + 1].items);\n    }\n    return this.out;\n};\n\nmodule.exports = Grid;\n\n},{\"../../linkedlist/doublylinkedlist\":31,\"./cell\":12}],14:[function(require,module,exports){\nmodule.exports = {\n    Grid: require('./grid'),\n    Cell: require('./cell')\n};\n\n},{\"./cell\":12,\"./grid\":13}],15:[function(require,module,exports){\nmodule.exports = {\n    Vector2: require('./vector2'),\n    LineSegment2: require('./linesegment2'),\n    Triangle2: require('./triangle2'),\n    Polygon2: require('./polygon2'),\n    RegularPolygon2: require('./regularpolygon2'),\n    gpc: require('./gpc'),\n    VisibilityPolygon: require('./visibilitypolygon'),\n\n    Grid: require('./grid'),\n    QuadTree: require('./quadtree')\n};\n\n},{\"./gpc\":11,\"./grid\":14,\"./linesegment2\":16,\"./polygon2\":17,\"./quadtree\":19,\"./regularpolygon2\":23,\"./triangle2\":24,\"./vector2\":25,\"./visibilitypolygon\":26}],16:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\n\nmodule.exports = LineSegment2;\n\nvar cache = [];\nvar created = 0;\n\nfunction LineSegment2(start, end) {\n    if (!(this instanceof LineSegment2)) {\n        var l = cache.pop();\n        if (!l) {\n            l = new LineSegment2(start, end);\n            created++;\n        } else {\n            l.start.free();\n            l.end.free();\n            l.set(start, end);\n        }\n        return l;\n    }\n    this.start = start || Vector2();\n    this.end = end || Vector2();\n}\n\nLineSegment2.getStats = function () {\n    return [cache.length, created];\n};\n\nLineSegment2.prototype.set = function (start, end) {\n    this.start = start || Vector2();\n    this.end = end || Vector2();\n    return this;\n};\n\nLineSegment2.prototype.free = function () {\n    cache.push(this);\n};\n\nLineSegment2.prototype.lengthSq = function () {\n    return this.start.distanceSq(this.end);\n};\n\nLineSegment2.prototype.length = function () {\n    return this.start.distance(this.end);\n};\n\nLineSegment2.prototype.closestPoint = function (point, full) {\n    var l2 = this.lengthSq();\n    if (l2 === 0) {\n        return this.start.clone();\n    }\n    var t = ((point.x - this.start.x) * (this.end.x - this.start.x) + (point.y - this.start.y) * (this.end.y - this.start.y)) / l2;\n    if (!full) {\n        if (t < 0) {\n            return this.start.clone();\n        }\n        if (t > 1) {\n            return this.end.clone();\n        }\n    }\n    return Vector2(this.start.x + t * (this.end.x - this.start.x), this.start.y + t * (this.end.y - this.start.y));\n};\n\nLineSegment2.prototype.distanceSq = function (point, full) {\n    var c = this.closestPoint(point, full);\n    var d = point.distanceSq(c);\n    c.free();\n    return d;\n};\n\nLineSegment2.prototype.distance = function (point, full) {\n    return Math.sqrt(this.distanceSq(point, full));\n};\n\nLineSegment2.prototype.intersect = function (l, full) {\n    var u_b = (l.end.y - l.start.y) * (this.end.x - this.start.x) - (l.end.x - l.start.x) * (this.end.y - this.start.y);\n    if (u_b !== 0) {\n        var ua_t = (l.end.x - l.start.x) * (this.start.y - l.start.y) - (l.end.y - l.start.y) * (this.start.x - l.start.x);\n        var ub_t = (this.end.x - this.start.x) * (this.start.y - l.start.y) - (this.end.y - this.start.y) * (this.start.x - l.start.x);\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (full || (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)) {\n            return Vector2(this.start.x - ua * (this.start.x - this.end.x), this.start.y - ua * (this.start.y - this.end.y));\n        }\n    } else {\n        return null; // perpendicular\n    }\n    return false;\n};\n\nLineSegment2.prototype.intersectCircle = function (point, radius, full) {\n    var r2 = radius * radius;\n    var closest = this.closestPoint(point, full);\n    var dist_v = point.clone().subtract(closest);\n    var len2 = dist_v.distanceSq();\n    dist_v.free();\n    if (len2 < r2) {\n        return closest;\n    } else {\n        closest.free();\n        return false;\n    }\n};\n\nLineSegment2.prototype.equals = function (other) {\n    return (this.start === other.start && this.end === other.end);\n};\n\nLineSegment2.prototype.inverse = function () {\n    return LineSegment2(this.end.clone(), this.start.clone());\n};\n\n/* jshint +W064 */\n\n},{\"./vector2\":25}],17:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\nvar LineSegment2 = require('./linesegment2');\nvar epsilon = 0.0000001;\n\nmodule.exports = Polygon2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Polygon2(points) {\n    if (!(this instanceof Polygon2)) {\n        var p = cache.pop();\n        if (!p) {\n            p = new Polygon2(points);\n            created++;\n        } else {\n            p.freePoints();\n            p.set(points);\n        }\n        return p;\n    }\n    this.points = points || [];\n}\n\nPolygon2.fromArray = function (points) {\n    var p = Polygon2();\n    for (var i = 0; i < points.length; i++) {\n        p.add(Vector2.fromArray(points[i]));\n    }\n    return p;\n};\n\nPolygon2.getStats = function () {\n    return [cache.length, created];\n};\n\nPolygon2.prototype.free = function () {\n    this.freePoints();\n    cache.push(this);\n};\n\nPolygon2.prototype.freePoints = function () {\n    var p = this.points.pop();\n    while (p) {\n        p.free();\n        p = this.points.pop();\n    }\n    return this;\n};\n\nPolygon2.prototype.set = function (points) {\n    this.points = points || [];\n    return this;\n};\n\nPolygon2.prototype.add = function (point) {\n    this.points.push(point);\n    return this;\n};\n\nPolygon2.prototype.translate = function (vec) {\n    for (var i = 0; i < this.points.length; i++) {\n        this.points[i].add(vec);\n    }\n    return this;\n};\n\nPolygon2.prototype.rotate = function (angle, origin) {\n    for (var i = 0; i < this.points.length; i++) {\n        this.points[i].rotate(angle, origin);\n    }\n    return this;\n};\n\nPolygon2.prototype.containsPoint = function (point) {\n    var inside = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n\n        var intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n\nPolygon2.prototype.intersectsLine = function (line, ignorePoints) {\n    var tempLine = LineSegment2();\n\n    var intersect = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n        tempLine.start.set(xi, yi);\n        tempLine.end.set(xj, yj);\n        var is = tempLine.intersect(line);\n        if (is) {\n            if (ignorePoints && (this.points[i].isEqualEpsilon(is) || this.points[j].isEqualEpsilon(is) || line.start.isEqualEpsilon(is) || line.end.isEqualEpsilon(is) )) {\n                // special perpendicular test\n                var a = this.points[i].clone().subtract(this.points[j]).normalize();\n                var aa = a.angle();\n                a.copy(line.start).subtract(line.end).normalize();\n                var bb = a.angle();\n                a.free();\n                is.free();\n                if (Math.abs(aa - bb) < epsilon) {\n                    intersect = true;\n                    break;\n                }\n                continue;\n            }\n            is.free();\n            intersect = true;\n            break;\n        }\n    }\n    tempLine.free();\n    return intersect;\n};\n\n\nPolygon2.prototype.intersectsTriangle = function (triangle, ignorePoints) {\n    var tempLine = LineSegment2();\n\n    tempLine.start.copy(triangle.v0);\n    tempLine.end.copy(triangle.v1);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v1);\n    tempLine.end.copy(triangle.v2);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v2);\n    tempLine.end.copy(triangle.v0);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n    return false;\n};\n\nPolygon2.prototype.AABB = function () {\n    var min = this.points[0].clone();\n    var max = this.points[0].clone();\n\n    for (var i = 1; i < this.points.length; i++) {\n        var p = this.points[i];\n        if (p.x < min.x) {\n            min.x = p.x;\n        } else if (p.x > max.x) {\n            max.x = p.x;\n        }\n        if (p.y < min.y) {\n            min.y = p.y;\n        } else if (p.y > max.y) {\n            max.y = p.y;\n        }\n    }\n    return [min, max];\n};\n\n// negative = CCW\nPolygon2.prototype.winding = function () {\n    return this.area() > 0;\n};\n\nPolygon2.prototype.rewind = function (cw) {\n    cw = !!cw;\n    var winding = this.winding();\n    if (winding !== cw) {\n        this.points.reverse();\n    }\n    return this;\n};\n\nPolygon2.prototype.area = function () {\n    var area = 0;\n    var first = this.points[0];\n    var p1 = Vector2();\n    var p2 = Vector2();\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        p1.copy(first).subtract(this.points[i]);\n        p2.copy(first).subtract(this.points[j]);\n        area += p1.cross(p2);\n    }\n    p1.free();\n    p2.free();\n    return area / 2;\n};\n\nPolygon2.prototype.clean = function (distance) {\n    var p1 = Vector2();\n    var newpoints = [];\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var length = p1.copy(this.points[i]).subtract(this.points[j]).length();\n        if (length > distance) {\n            newpoints.push(this.points[i]);\n        } else {\n            this.points[i].free();\n        }\n    }\n    this.points = newpoints;\n};\n\nPolygon2.prototype.toArray = function () {\n    var ret = [];\n    for (var i = 0; i < this.points.length; i++) {\n        ret.push(this.points[i].toArray());\n    }\n    return ret;\n};\n\n\n/* jshint +W064 */\n\n},{\"./linesegment2\":16,\"./vector2\":25}],18:[function(require,module,exports){\n'use strict';\n\nvar PointNode = require('./pointnode');\n\nfunction BoundsNode(bounds, depth, maxChildren, maxDepth) {\n    PointNode.call(this, bounds, depth, maxChildren, maxDepth);\n    this._stuckChildren = [];\n}\n\nBoundsNode.prototype = new PointNode();\nBoundsNode.prototype._classConstructor = BoundsNode;\nBoundsNode.prototype._stuckChildren = null;\n\n//we use this to collect and conctenate items being retrieved. This way\n//we dont have to continuously create new Array instances.\n//Note, when returned from QuadTree.retrieve, we then copy the array\nBoundsNode.prototype._out = [];\n\nBoundsNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        //todo: make _bounds bounds\n        if (item.x >= node._bounds.x &&\n            item.x + item.width <= node._bounds.x + node._bounds.width &&\n            item.y >= node._bounds.y &&\n            item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            this.nodes[index].insert(item);\n\n        } else {\n            this._stuckChildren.push(item);\n        }\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n\n    if (this._depth < this._maxDepth &&\n        len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nBoundsNode.prototype.getChildren = function () {\n    return this.children.concat(this._stuckChildren);\n};\n\nBoundsNode.prototype.retrieve = function (item) {\n    var out = this._out;\n    out.length = 0;\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        if (item.x >= node._bounds.x &&\n            item.x + item.width <= node._bounds.x + node._bounds.width &&\n            item.y >= node._bounds.y &&\n            item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            out.push.apply(out, this.nodes[index].retrieve(item));\n        } else {\n            //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n            if (item.x <= this.nodes[PointNode.TOP_RIGHT]._bounds.x) {\n                if (item.y <= this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_LEFT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_LEFT].retrieve(item));\n                }\n            }\n\n            if (item.x + item.width > this.nodes[PointNode.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                if (item.y <= this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_RIGHT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_RIGHT].retrieve(item));\n                }\n            }\n        }\n    }\n\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n\n    return out;\n};\n\n//Returns all contents of node.\nBoundsNode.prototype.getAllContent = function () {\n    var out = this._out;\n    if (this.nodes.length) {\n\n        var i;\n        for (i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].getAllContent();\n        }\n    }\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n    return out;\n};\n\nBoundsNode.prototype.clear = function () {\n\n    this._stuckChildren.length = 0;\n\n    //array\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    if (!len) {\n        return;\n    }\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    //array\n    this.nodes.length = 0;\n\n    //we could call the super clear function but for now, im just going to inline it\n    //call the hidden super.clear, and make sure its called with this = this instance\n    //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n};\n\nmodule.exports = BoundsNode;\n\n},{\"./pointnode\":20}],19:[function(require,module,exports){\nmodule.exports = {\n    QuadTree: require('./quadtree'),\n    PointNode: require('./pointnode'),\n    BoundsNode: require('./boundsnode')\n};\n\n},{\"./boundsnode\":18,\"./pointnode\":20,\"./quadtree\":21}],20:[function(require,module,exports){\n'use strict';\n\nfunction PointNode(bounds, depth, maxDepth, maxChildren) {\n    this._bounds = bounds;\n    this.children = [];\n    this.nodes = [];\n\n    if (maxChildren) {\n        this._maxChildren = maxChildren;\n    }\n\n    if (maxDepth) {\n        this._maxDepth = maxDepth;\n    }\n\n    if (depth) {\n        this._depth = depth;\n    }\n}\n\n//subnodes\nPointNode.prototype.nodes = null;\nPointNode.prototype._classConstructor = PointNode;\n\n//children contained directly in the node\nPointNode.prototype.children = null;\nPointNode.prototype._bounds = null;\n\n//read only\nPointNode.prototype._depth = 0;\n\nPointNode.prototype._maxChildren = 4;\nPointNode.prototype._maxDepth = 4;\n\nPointNode.TOP_LEFT = 0;\nPointNode.TOP_RIGHT = 1;\nPointNode.BOTTOM_LEFT = 2;\nPointNode.BOTTOM_RIGHT = 3;\n\n\nPointNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        this.nodes[index].insert(item);\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n    if (this._depth < this._maxDepth &&\n        len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nPointNode.prototype.retrieve = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        return this.nodes[index].retrieve(item);\n    }\n\n    return this.children;\n};\n\nPointNode.prototype._findIndex = function (item) {\n    var b = this._bounds;\n    var left = (item.x > b.x + b.width / 2) ? false : true;\n    var top = (item.y > b.y + b.height / 2) ? false : true;\n\n    //top left\n    var index = PointNode.TOP_LEFT;\n    if (left) {\n        //left side\n        if (!top) {\n            //bottom left\n            index = PointNode.BOTTOM_LEFT;\n        }\n    } else {\n        //right side\n        if (top) {\n            //top right\n            index = PointNode.TOP_RIGHT;\n        } else {\n            //bottom right\n            index = PointNode.BOTTOM_RIGHT;\n        }\n    }\n\n    return index;\n};\n\n\nPointNode.prototype.subdivide = function () {\n    var depth = this._depth + 1;\n\n    var bx = this._bounds.x;\n    var by = this._bounds.y;\n\n    //floor the values\n    var b_w_h = (this._bounds.width / 2) | 0; //todo: Math.floor?\n    var b_h_h = (this._bounds.height / 2) | 0;\n    var bx_b_w_h = bx + b_w_h;\n    var by_b_h_h = by + b_h_h;\n\n    //top left\n    this.nodes[PointNode.TOP_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n\n    //top right\n    this.nodes[PointNode.TOP_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n\n    //bottom left\n    this.nodes[PointNode.BOTTOM_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n\n\n    //bottom right\n    this.nodes[PointNode.BOTTOM_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n};\n\nPointNode.prototype.clear = function () {\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    this.nodes.length = 0;\n};\n\n\nmodule.exports = PointNode;\n\n},{}],21:[function(require,module,exports){\n'use strict';\n\nvar PointNode = require('./pointnode'),\n    BoundsNode = require('./boundsnode');\n\n/**\n * QuadTree data structure.\n * @class QuadTree\n * @constructor\n * @param {Object} An object representing the bounds of the top level of the QuadTree. The object\n * should contain the following properties : x, y, width, height\n * @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds\n * (width / height)(false). Default value is false.\n * @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n * @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n **/\nfunction QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n    var node;\n    if (pointQuad) {\n        node = new PointNode(bounds, 0, maxDepth, maxChildren);\n    } else {\n        node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n    }\n\n    this.root = node;\n}\n\n/**\n * The root node of the QuadTree which covers the entire area being segmented.\n * @property root\n * @type Node\n **/\nQuadTree.prototype.root = null;\n\n\n/**\n * Inserts an item into the QuadTree.\n * @method insert\n * @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y\n * properties that represents its position in 2D space.\n **/\nQuadTree.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            len = item.length;\n        while (i < len) {\n            this.root.insert(item[i]);\n            i++;\n        }\n    } else {\n        this.root.insert(item);\n    }\n};\n\n/**\n * Clears all nodes and children from the QuadTree\n * @method clear\n **/\nQuadTree.prototype.clear = function () {\n    this.root.clear();\n};\n\n/**\n * Retrieves all items / points in the same node as the specified item / point. If the specified item\n * overlaps the bounds of a node, then all children in both nodes will be returned.\n * @method retrieve\n * @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n * with dimensions (x, y, width, height) properties.\n **/\nQuadTree.prototype.retrieve = function (item) {\n    //get a copy of the array of items\n    return this.root.retrieve(item);\n    // var out = this.root.retrieve(item).slice(0);\n    // return out;\n};\n\nmodule.exports = QuadTree;\n\n},{\"./boundsnode\":18,\"./pointnode\":20}],22:[function(require,module,exports){\n'use strict';\n/* jshint -W064 */\n\nmodule.exports = Rectangle2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Rectangle2(x, y, width, height) {\n    if (!(this instanceof Rectangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Rectangle2(x || 0, y || 0, width || 0, height || 0);\n            created++;\n        } else {\n            v.set(x, y, width, height);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n    this.width = width || 0;\n    this.height = height || 0;\n}\n\nRectangle2.getStats = function () {\n    return [cache.length, created];\n};\n\nRectangle2.fromArray = function (arr) {\n    return Rectangle2(arr[0] || 0, arr[1] || 0, arr[2] || 0, arr[3] || 0);\n};\n\nRectangle2.fromObject = function (obj) {\n    return Rectangle2(obj.x || 0, obj.y || 0, obj.width || 0, obj.height || 0);\n};\n\nRectangle2.prototype.set = function (x, y, width, height) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.width = width || 0;\n    this.height = height || 0;\n    return this;\n};\n\nRectangle2.prototype.free = function () {\n    cache.push(this);\n};\n\nRectangle2.prototype.translate = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nRectangle2.prototype.intersects = function (r) {\n    return !(this.x + this.width < r.x ||\n    this.y + this.height < r.y ||\n    this.x > r.x + r.width ||\n    this.y > r.y + r.height\n    );\n};\n\nRectangle2.prototype.toString = function () {\n    return 'x: ' + this.x + ', y: ' + this.y + ', width: ' + this.width + ', height: ' + this.height;\n};\n\nRectangle2.prototype.toArray = function () {\n    return [this.x, this.y];\n};\n\nRectangle2.prototype.toObject = function () {\n    return {x: this.x, y: this.y, width: this.width, height: this.height};\n};\n\n/* jshint +W064 */\n\n},{}],23:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2'),\n    Polygon2 = require('./polygon2');\n\nmodule.exports = RegularPolygon2;\n\nfunction RegularPolygon2(radius, sides, center) {\n    center = center || Vector2();\n\n    if (!sides || sides < 2) {\n        sides = 3;\n    }\n    if (!radius || radius <= 0) {\n        radius = 1;\n    }\n\n    var p = Polygon2();\n    for (var i = 0; i < sides; i++) {\n        p.add(Vector2(center.x + radius * Math.cos((i * 2 * Math.PI / sides) + 0.25 * Math.PI), center.y + radius * Math.sin((i * 2 * Math.PI / sides) + 0.25 * Math.PI)));\n    }\n    return p;\n}\n/* jshint +W064 */\n\n},{\"./polygon2\":17,\"./vector2\":25}],24:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\n\nmodule.exports = Triangle2;\n\nvar epsilon = 0.0000001;\nvar cache = [];\nvar created = 0;\n\nfunction Triangle2(v0, v1, v2) {\n    if (!(this instanceof Triangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Triangle2(v0, v1, v2);\n            created++;\n        } else {\n            v.set(v0, v1, v2);\n            //v.calcCircumcircle();\n        }\n        return v;\n    }\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    /*\n     this.center = Vector2();\n     this.radius = 0;\n     this.radius_squared = 0;\n\n     this.calcCircumcircle();\n     */\n}\n\nTriangle2.getStats = function () {\n    return [cache.length, created];\n};\n\nTriangle2.prototype.free = function () {\n    cache.push(this);\n};\n\n\nTriangle2.prototype.set = function (v0, v1, v2) {\n    this.v0.free();\n    this.v1.free();\n    this.v2.free();\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    return this;\n};\n\nTriangle2.prototype.translate = function (vec) {\n    this.v0.add(vec);\n    this.v1.add(vec);\n    this.v2.add(vec);\n    return this;\n};\n\nTriangle2.prototype.calcCircumcircle = function () {\n    // From: http://www.exaflop.org/docs/cgafaq/cga1.html\n\n    var A = this.v1.x - this.v0.x;\n    var B = this.v1.y - this.v0.y;\n    var C = this.v2.x - this.v0.x;\n    var D = this.v2.y - this.v0.y;\n\n    var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);\n    var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);\n\n    var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));\n\n    var dx, dy;\n\n    if (Math.abs(G) < epsilon) {\n        // Collinear - find extremes and use the midpoint\n\n        var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);\n        var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);\n        var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);\n        var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);\n\n        this.center.set((minx + maxx) / 2, (miny + maxy) / 2);\n\n        dx = this.center.x - minx;\n        dy = this.center.y - miny;\n    } else {\n        var cx = (D * E - B * F) / G;\n        var cy = (A * F - C * E) / G;\n\n        this.center.set(cx, cy);\n\n        dx = this.center.x - this.v0.x;\n        dy = this.center.y - this.v0.y;\n    }\n\n    this.radius_squared = dx * dx + dy * dy;\n    this.radius = Math.sqrt(this.radius_squared);\n};\n\nTriangle2.prototype.inCircumcircle = function (v) {\n    var dx = this.center.x - v.x;\n    var dy = this.center.y - v.y;\n    var dist_squared = dx * dx + dy * dy;\n\n    return (dist_squared <= this.radius_squared);\n};\n/* jshint +W064 */\n\n},{}],25:[function(require,module,exports){\n'use strict';\n/* jshint -W064 */\n\nmodule.exports = Vector2;\n\nvar epsilon = 0.0000001;\nvar degrees = 180 / Math.PI;\n\nvar cache = [];\nvar created = 0;\n\nfunction Vector2(x, y) {\n    if (!(this instanceof Vector2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Vector2(x || 0, y || 0);\n            created++;\n        } else {\n            v.set(x, y);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n}\n\nVector2.warmup = function (amount) {\n    while (amount--) {\n        new Vector2().free();\n    }\n};\n\nVector2.getStats = function () {\n    return [cache.length, created];\n};\n\nVector2.fromArray = function (arr) {\n    return Vector2(arr[0] || 0, arr[1] || 0);\n};\n\nVector2.fromObject = function (obj) {\n    return Vector2(obj.x || 0, obj.y || 0);\n};\n\nVector2.prototype.set = function (x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n};\n\nVector2.prototype.free = function () {\n    cache.push(this);\n};\n\nVector2.prototype.add = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nVector2.prototype.addScalar = function (scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    return this;\n};\n\n\nVector2.prototype.subtract = function (vec) {\n    this.x -= vec.x;\n    this.y -= vec.y;\n    return this;\n};\n\nVector2.prototype.subtractScalar = function (scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n};\n\n\nVector2.prototype.divide = function (vec) {\n    this.x /= vec.x;\n    this.y /= vec.y;\n    return this;\n};\n\nVector2.prototype.multiply = function (vec) {\n    this.x *= vec.x;\n    this.y *= vec.y;\n    return this;\n};\n\nVector2.prototype.multiplyScalar = function (scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n};\n\nVector2.prototype.normalize = function () {\n    var length = this.length();\n\n    if (length === 0) {\n        this.x = 0;\n        this.y = 0;\n    } else {\n        this.x /= length;\n        this.y /= length;\n    }\n    return this;\n};\n\nVector2.prototype.clone = function () {\n    return Vector2(this.x, this.y);\n};\n\nVector2.prototype.copy = function (vec) {\n    this.x = vec.x;\n    this.y = vec.y;\n    return this;\n};\n\nVector2.prototype.zero = function () {\n    this.x = this.y = 0;\n    return this;\n};\n\nVector2.prototype.dot = function (vec) {\n    return this.x * vec.x + this.y * vec.y;\n};\n\nVector2.prototype.cross = function (vec) {\n    return (this.x * vec.y ) - (this.y * vec.x );\n};\n\nVector2.prototype.projectOnto = function (vec) {\n    var coeff = ( (this.x * vec.x) + (this.y * vec.y) ) / ((vec.x * vec.x) + (vec.y * vec.y));\n    this.x = coeff * vec.x;\n    this.y = coeff * vec.y;\n    return this;\n};\n\nVector2.prototype.setAngle = function (rad) {\n    var len = this.length();\n    this.x = Math.cos(rad) * len;\n    this.y = Math.sin(rad) * len;\n};\n\nVector2.prototype.horizontalAngle = function () {\n    return Math.atan2(this.y, this.x);\n};\n\nVector2.prototype.horizontalAngleDeg = function () {\n    return radian2degrees(this.horizontalAngle());\n};\n\nVector2.prototype.verticalAngle = function () {\n    return Math.atan2(this.x, this.y);\n};\n\nVector2.prototype.verticalAngleDeg = function () {\n    return radian2degrees(this.verticalAngle());\n};\n\nVector2.prototype.angle = Vector2.prototype.horizontalAngle;\nVector2.prototype.angleDeg = Vector2.prototype.horizontalAngleDeg;\nVector2.prototype.direction = Vector2.prototype.horizontalAngle;\n\nVector2.prototype.rotate = function (angle, origin) {\n    var ox = 0,\n        oy = 0;\n    if (origin) {\n        ox = origin.x || 0;\n        oy = origin.y || 0;\n    }\n\n    var nx = ox + (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));\n    var ny = oy + (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));\n\n    this.x = nx;\n    this.y = ny;\n\n    return this;\n};\n\nVector2.prototype.rotateDeg = function (angle) {\n    angle = degrees2radian(angle);\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateBy = function (rotation) {\n    var angle = this.angle() + rotation;\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateByDeg = function (rotation) {\n    rotation = degrees2radian(rotation);\n    return this.rotateBy(rotation);\n};\n\nVector2.prototype.distance = function (vec) {\n    return Math.sqrt(this.distanceSq(vec));\n};\n\nVector2.prototype.distanceSq = function (vec) {\n    var dx = this.x - vec.x,\n        dy = this.y - vec.y;\n    return dx * dx + dy * dy;\n};\n\nVector2.prototype.length = function () {\n    return Math.sqrt(this.lengthSq());\n};\n\nVector2.prototype.lengthSq = function () {\n    return this.x * this.x + this.y * this.y;\n};\n\nVector2.prototype.magnitude = Vector2.prototype.length;\n\nVector2.prototype.isZero = function () {\n    return this.x === 0 && this.y === 0;\n};\nVector2.prototype.isEqualTo = function (vec) {\n    return this.x === vec.x && this.y === vec.y;\n};\n\nVector2.prototype.isEqualEpsilon = function (vec) {\n    return Math.abs(this.x - vec.x) < epsilon && Math.abs(this.y - vec.y) < epsilon;\n};\n\nVector2.prototype.toString = function () {\n    return 'x: ' + this.x + ', y: ' + this.y;\n};\n\nVector2.prototype.toArray = function () {\n    return [this.x, this.y];\n};\n\nVector2.prototype.toObject = function () {\n    return {x: this.x, y: this.y};\n};\n\nfunction radian2degrees(rad) {\n    return rad * degrees;\n}\n\nfunction degrees2radian(deg) {\n    return deg / degrees;\n}\n/* jshint +W064 */\n\n},{}],26:[function(require,module,exports){\n'use strict';\n/* jshint -W064 */\n\n/*\n Based upon https://code.google.com/p/visibility-polygon-js/\n Made by Byron Knoll in 2013/2014.\n */\n\nvar Polygon2 = require('./polygon2'),\n    Vector2 = require('./vector2'),\n    LineSegment2 = require('./linesegment2');\n\nvar PI = Math.PI;\nvar PI2 = PI * 2;\nvar PImin = -1 * PI;\nvar epsilon = 0.0000001;\n\nvar segmentIter = ['start', 'end'];\nfunction pointsorter(a, b) {\n    return a[2] - b[2];\n}\n\nmodule.exports = VisibilityPolygon;\n\nfunction VisibilityPolygon(segments) {\n    this.polygon = Polygon2();\n    this.segments = segments;\n    this.heap = [];\n    this.map = new Array(this.segments.length);\n    this.points = new Array(this.segments.length * 2);\n    this.position = Vector2();\n}\n\nVisibilityPolygon.prototype.angle = function (p1, p2) {\n    var p = p2.clone().subtract(p1);\n    var a = p.angle();\n    p.free();\n    return a;\n};\n\nVisibilityPolygon.prototype.angle2 = function (a, b, c) {\n    var a1 = this.angle(a, b);\n    var a2 = this.angle(b, c);\n    var a3 = a1 - a2;\n    if (a3 < 0) {\n        a3 += PI2;\n    }\n    if (a3 > PI2) {\n        a3 -= PI2;\n    }\n    return a3;\n};\n\n\nVisibilityPolygon.prototype.compute = function (position) {\n    this.position.copy(position);\n    this.reset();\n    this.sortPoints();\n\n    var start = this.position.clone();\n    start.x += 1; // why?\n\n    var i = 0,\n        n = this.segments.length;\n    while (i < n) {\n        var a1 = this.angle(this.segments[i].start, this.position);\n        var a2 = this.angle(this.segments[i].end, this.position);\n        if (\n            ( a1 > PImin && a1 <= 0 && a2 <= PI && a2 >= 0 && a2 - a1 > PI) ||\n            (a2 > PImin && a2 <= 0 && a1 <= PI && a1 >= 0 && a1 - a2 > PI)\n        ) {\n            this.insert(i, start);\n        }\n        i += 1;\n    }\n    i = 0;\n    n = this.segments.length * 2;\n    while (i < n) {\n        var extend = false;\n        var shorten = false;\n        var orig = i;\n        var vertex = this.segments[this.points[i][0]][this.points[i][1]];\n        var old_segment = this.heap[0];\n        do {\n            if (this.map[this.points[i][0]] !== -1) {\n                if (this.points[i][0] === old_segment) {\n                    extend = true;\n                    vertex = this.segments[this.points[i][0]][this.points[i][1]];\n                }\n                this.remove(this.map[this.points[i][0]], vertex);\n            } else {\n                this.insert(this.points[i][0], vertex);\n                if (this.heap[0] !== old_segment) {\n                    shorten = true;\n                }\n            }\n            ++i;\n            if (i === n) {\n                break;\n            }\n        } while (this.points[i][2] < this.points[orig][2] + epsilon);\n\n        var l = LineSegment2(position.clone(), vertex.clone());\n        if (extend) {\n            this.polygon.add(vertex.clone());\n            var cur = this.segments[this.heap[0]].intersect(l, true);\n            if (cur) {\n                if (!cur.isEqualEpsilon(vertex)) {\n                    this.polygon.add(cur);\n                } else {\n                    cur.free();\n                }\n            }\n        } else if (shorten) {\n            this.polygon.add(this.segments[old_segment].intersect(l, true));\n            this.polygon.add(this.segments[this.heap[0]].intersect(l, true));\n        }\n    }\n    return this.polygon;\n};\n\n\nVisibilityPolygon.prototype.insert = function (index, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var intersect = this.segments[index].intersect(l, true);\n    if (intersect === false) {\n        l.free();\n        return;\n    }\n    intersect.free();\n\n    var cur = this.heap.length;\n    this.heap.push(index);\n    this.map[index] = cur;\n    while (cur > 0) {\n        var parent = this.parent(cur);\n        if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n            break;\n        }\n        this.map[this.heap[parent]] = cur;\n        this.map[this.heap[cur]] = parent;\n        var temp = this.heap[cur];\n        this.heap[cur] = this.heap[parent];\n        this.heap[parent] = temp;\n        cur = parent;\n    }\n};\n\nVisibilityPolygon.prototype.remove = function (index, destination) {\n    this.map[this.heap[index]] = -1;\n    if (index === this.heap.length - 1) {\n        this.heap.pop();\n        return;\n    }\n    this.heap[index] = this.heap.pop();\n    this.map[this.heap[index]] = index;\n    var cur = index;\n    var parent = this.parent(cur);\n    if (cur !== 0 && this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n        while (cur > 0) {\n            parent = this.parent(cur);\n            if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n                break;\n            }\n            this.swap(cur, parent);\n            cur = parent;\n        }\n    } else {\n        while (true) {\n            var left = this.child(cur);\n            var right = left + 1;\n            if (left < this.heap.length && this.lessThan(this.heap[left], this.heap[cur], destination) &&\n                (right === this.heap.length || this.lessThan(this.heap[left], this.heap[right], destination))) {\n                this.swap(cur, left);\n                cur = left;\n            } else if (right < this.heap.length && this.lessThan(this.heap[right], this.heap[cur], destination)) {\n                this.swap(cur, right);\n                cur = right;\n            } else {\n                break;\n            }\n        }\n    }\n};\n\n\nVisibilityPolygon.prototype.lessThan = function (index1, index2, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var inter1 = this.segments[index1].intersect(l, true);\n    var inter2 = this.segments[index2].intersect(l, true);\n    if (!inter1.isEqualEpsilon(inter2)) {\n        var d1 = inter1.distanceSq(this.position);\n        var d2 = inter2.distanceSq(this.position);\n        inter1.free();\n        inter2.free();\n        l.free();\n        return d1 < d2;\n    }\n    var end1 = this.segments[index1].start;\n    if (inter1.isEqualEpsilon(this.segments[index1].start)) {\n        end1 = this.segments[index1].end;\n    }\n    var end2 = this.segments[index2].start;\n    if (inter2.isEqualEpsiolon(this.segments[index2].start)) {\n        end2 = this.segments[index2].end;\n    }\n    var a1 = this.angle2(end1, inter1, this.position);\n    var a2 = this.angle2(end2, inter2, this.position);\n    inter1.free();\n    inter2.free();\n    if (a1 < PI) {\n        if (a2 > PI) {\n            return true;\n        }\n        return a2 < a1;\n    }\n    return a1 < a2;\n};\n\nVisibilityPolygon.prototype.parent = function (index) {\n    return Math.floor((index - 1) / 2);\n};\n\nVisibilityPolygon.prototype.child = function (index) {\n    return 2 * index + 1;\n};\n\nVisibilityPolygon.prototype.swap = function (c, l) {\n    this.map[this.heap[l]] = c;\n    this.map[this.heap[c]] = l;\n    var temp = this.heap[l];\n    this.heap[l] = this.heap[c];\n    this.heap[c] = temp;\n};\n\n\nVisibilityPolygon.prototype.sortPoints = function () {\n    var i = 0,\n        n = this.segments.length,\n        p = null,\n        pp = Vector2();\n    while (i < n) {\n        for (var j = 0; j < 2; ++j) {\n            if (j === 0) {\n                p = this.segments[i][segmentIter[j]];\n            } else {\n                p = this.segments[i][segmentIter[j]];\n            }\n            pp.copy(this.position).subtract(p);\n            var nr = 2 * i + j;\n            if (this.points[nr]) {\n                this.points[nr][0] = i;\n                this.points[nr][1] = segmentIter[j];\n                this.points[nr][2] = pp.angle();\n            } else {\n                this.points[nr] = [i, segmentIter[j], pp.angle()];\n            }\n        }\n        i += 1;\n    }\n    pp.free();\n    this.points = this.points.sort(pointsorter);\n};\n\nVisibilityPolygon.prototype.reset = function () {\n    this.polygon.freePoints();\n    var i = 0,\n        n = this.map.length;\n    while (i < n) {\n        this.map[i] = -1;\n        i += 1;\n    }\n    while (this.heap.length > 0) {\n        this.heap.pop();\n    }\n};\n/* jshint +W064 */\n\n},{\"./linesegment2\":16,\"./polygon2\":17,\"./vector2\":25}],27:[function(require,module,exports){\n(function (global){\nvar core = {};\n\n\ncore.geometry = require('./geometry');\ncore.linkedlist = require('./linkedlist');\ncore.procedural = require('./procedural');\ncore.timer = require('./timer');\ncore.input = require('./input');\ncore.game = require('./game');\n\nmodule.exports = core;\n\nglobal.ULTRON = core;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./game\":7,\"./geometry\":15,\"./input\":28,\"./linkedlist\":32,\"./procedural\":36,\"./timer\":38}],28:[function(require,module,exports){\nmodule.exports = {\n    Unified: require('./unified')\n};\n\n},{\"./unified\":30}],29:[function(require,module,exports){\n//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\n// taken from game-shell\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif (window.addEventListener) {\n    _addEventListener = \"addEventListener\";\n} else {\n    _addEventListener = \"attachEvent\";\n    prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n    document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n        \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener(elem, eventName, callback, useCapture) {\n    elem[_addEventListener](prefix + eventName, support === \"wheel\" ? callback : function (originalEvent) {\n        !originalEvent && ( originalEvent = window.event );\n\n        // create a normalized event object\n        var event = {\n            // keep a ref to the original event object\n            originalEvent: originalEvent,\n            target: originalEvent.target || originalEvent.srcElement,\n            type: \"wheel\",\n            deltaMode: originalEvent.type === \"MozMousePixelScroll\" ? 0 : 1,\n            deltaX: 0,\n            delatZ: 0,\n            preventDefault: function () {\n                originalEvent.preventDefault ?\n                    originalEvent.preventDefault() :\n                    originalEvent.returnValue = false;\n            }\n        };\n\n        // calculate deltaY (and deltaX) according to the event\n        if (support === \"mousewheel\") {\n            event.deltaY = -1 / 40 * originalEvent.wheelDelta;\n            // Webkit also support wheelDeltaX\n            originalEvent.wheelDeltaX && ( event.deltaX = -1 / 40 * originalEvent.wheelDeltaX );\n        } else {\n            event.deltaY = originalEvent.detail;\n        }\n\n        // it's time to fire the callback\n        return callback(event);\n    }, useCapture || false);\n}\n\nmodule.exports = function (elem, callback, useCapture) {\n    _addWheelListener(elem, support, callback, useCapture);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (support === \"DOMMouseScroll\") {\n        _addWheelListener(elem, \"MozMousePixelScroll\", callback, useCapture);\n    }\n};\n\n},{}],30:[function(require,module,exports){\n'use strict';\n\n// taken from https://github.com/andyhall/game-inputs\n\nvar vkey = require('vkey');\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\nvar EventEmitter = require('eventemitter3');\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = require('./mousewheel-polyfill');\n\nmodule.exports = Inputs;\n\n// map button index to name\nvar gamepadButtonNames = [\n    'a',\n    'b',\n    'x',\n    'y',\n    'left-shoulder',\n    'right-shoulder',\n    'left-trigger',\n    'right-trigger',\n    'select',\n    'start',\n    'left-stick',\n    'right-stick',\n    'dpad-up',\n    'dpad-down',\n    'dpad-left',\n    'dpad-right'\n];\nvar gamepadAxesNames = [\n    'left-stick-x',\n    'left-stick-y',\n    'right-stick-x',\n    'right-stick-y'\n];\nvar hasGamepadEvents = 'GamepadEvent' in window;\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from)\n *        game-shell: https://github.com/mikolalysenko/game-shell\n *\n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *\n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n */\n\n\nfunction Inputs(element, opts) {\n\n    // settings\n    this.element = element || document;\n    opts = opts || {};\n    this.preventDefaults = !!opts.preventDefaults;\n    this.stopPropagation = !!opts.stopPropagation;\n\n    // emitters\n    this.down = new EventEmitter();\n    this.up = new EventEmitter();\n    this.gamepadconnected = new EventEmitter();\n    this.gamepaddisconnected = new EventEmitter();\n\n    // state object to be queried\n    this.state = {\n        dx: 0, dy: 0,\n        scrollx: 0, scrolly: 0, scrollz: 0\n    };\n\n    // internal state\n    this._keybindmap = {};       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n    this._keyStates = {};        // { 'vkeycode' : boolean }\n    this._bindPressCounts = {};  // { 'binding' : int }\n    this._gamepads = {}; // { 'index' : gamepad }\n    this._gamepadButtonStates = {}; // { 'vcode' : int }\n\n    // raf handle\n    this._gamepadRaf = false;\n\n    // register for dom events\n    this.initEvents();\n}\n\n\n/*\n *\n *   PUBLIC API\n *\n */\n\nInputs.prototype.initEvents = function () {\n    // keys\n    window.addEventListener('keydown', onKeyEvent.bind(undefined, this, true), false);\n    window.addEventListener('keyup', onKeyEvent.bind(undefined, this, false), false);\n    // mouse buttons\n    this.element.addEventListener('mousedown', onMouseEvent.bind(undefined, this, true), false);\n    this.element.addEventListener('mouseup', onMouseEvent.bind(undefined, this, false), false);\n    this.element.oncontextmenu = onContextMenu.bind(undefined, this);\n    // mouse other\n    this.element.addEventListener('mousemove', onMouseMove.bind(undefined, this), false);\n    addMouseWheel(this.element, onMouseWheel.bind(undefined, this), false);\n\n    // gamepads\n    if (hasGamepadEvents) {\n        window.addEventListener('gamepadconnected', onGamepadConnected.bind(undefined, this), false);\n        window.addEventListener('gamepaddisconnected', onGamepadDisconnected.bind(undefined, this), false);\n    } else {\n        window.setInterval(scanGamepads.bind(undefined, this), 500);\n    }\n};\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function (binding) {\n    for (var i = 1; i < arguments.length; ++i) {\n        var vkeyCode = arguments[i];\n        var arr = this._keybindmap[vkeyCode] || [];\n        if (arr.indexOf(binding) === -1) {\n            arr.push(binding);\n        }\n        this._keybindmap[vkeyCode] = arr;\n    }\n    this.state[binding] = !!this.state[binding];\n};\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function (binding) {\n    for (var b in this._keybindmap) {\n        var arr = this._keybindmap[b];\n        var i = arr.indexOf(binding);\n        if (i > -1) {\n            arr.splice(i, 1);\n        }\n    }\n};\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function () {\n    this.state['mouse-dx'] = this.state['mouse-dy'] = 0;\n    this.state['mouse-scrollx'] = this.state['mouse-scrolly'] = this.state['mouse-scrollz'] = 0;\n};\n\n\nInputs.prototype.getBoundKeys = function () {\n    var arr = [];\n    for (var b in this._keybindmap) {\n        arr.push(b);\n    }\n    return arr;\n};\n\n\n/*\n *   INTERNALS - DOM EVENT HANDLERS\n */\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n    handleKeyEvent(ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev);\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n    // simulate a code out of range of vkey\n    var keycode = -1 - ev.button;\n    var vkeycode = '<mouse ' + (ev.button + 1) + '>';\n    handleKeyEvent(keycode, vkeycode, wasDown, inputs, ev);\n    return false;\n}\n\nfunction onContextMenu(inputs) {\n    // cancel context menu if there's a binding for right mousebutton\n    var arr = inputs._keybindmap['<mouse 3>'];\n    if (arr) {\n        return false;\n    }\n}\n\nfunction onMouseMove(inputs, ev) {\n    // for now, just populate the state object with mouse movement\n    var dx = ev.movementX || ev.mozMovementX || ev.webkitMovementX || 0,\n        dy = ev.movementY || ev.mozMovementY || ev.webkitMovementY || 0;\n    inputs.state['mouse-dx'] += dx;\n    inputs.state['mouse-dy'] += dy;\n    // TODO: verify if this is working/useful during pointerlock?\n}\n\nfunction onMouseWheel(inputs, ev) {\n    // basically borrowed from game-shell\n    var scale = 1;\n    switch (ev.deltaMode) {\n        case 0:\n            scale = 1;\n            break;  // Pixel\n        case 1:\n            scale = 12;\n            break;  // Line\n        case 2:  // page\n            // TODO: investigagte when this happens, what correct handling is\n            scale = inputs.element.clientHeight || window.innerHeight;\n            break;\n    }\n    // accumulate state\n    inputs.state['mouse-scrollx'] += ev.deltaX * scale;\n    inputs.state['mouse-scrolly'] += ev.deltaY * scale;\n    inputs.state['mouse-scrollz'] += (ev.deltaZ * scale) || 0;\n    return false;\n}\n\n\n/*\n *   KEY BIND HANDLING\n */\n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n    var arr = inputs._keybindmap[vcode];\n    // don't prevent defaults if there's no binding\n    if (!arr) {\n        return;\n    }\n    if (inputs.preventDefaults) {\n        ev.preventDefault();\n    }\n    if (inputs.stopPropagation) {\n        ev.stopPropagation();\n    }\n\n    // if the key's state has changed, handle an event for all bindings\n    var currstate = inputs._keyStates[keycode];\n    if (XOR(currstate, wasDown)) {\n        // for each binding: emit an event, and update cached state information\n        for (var i = 0; i < arr.length; ++i) {\n            handleBindingEvent(arr[i], wasDown, inputs, ev);\n        }\n    }\n    inputs._keyStates[keycode] = wasDown;\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n    // keep count of presses mapped by binding\n    // (to handle two keys with the same binding pressed at once)\n    var ct = inputs._bindPressCounts[binding] || 0;\n    ct += wasDown ? 1 : -1;\n    if (ct < 0) {\n        ct = 0;\n    } // shouldn't happen\n    inputs._bindPressCounts[binding] = ct;\n\n    // emit event if binding's state has changed\n    var currstate = inputs.state[binding];\n    if (XOR(currstate, ct)) {\n        var emitter = wasDown ? inputs.down : inputs.up;\n        emitter.emit(binding, binding, ev);\n    }\n    inputs.state[binding] = !!ct;\n}\n\n/**\n Gamepad HANDLERS\n */\n\nfunction handleGamePadButtonEvent(val, vcode, inputs) {\n    var arr = inputs._keybindmap[vcode];\n    if (!arr) {\n        return;\n    }\n\n    var pressed = val === 1.0;\n    var isPerc = false;\n    if (typeof(val) === 'object') {\n        pressed = val.pressed;\n        val = val.value;\n        isPerc = true;\n        inputs.state[vcode] = val;\n    } else {\n        var currstate = inputs._buttonStates[vcode];\n        if (XOR(currstate, val)) {\n            var i = 0;\n            for (i = 0; i < arr.length; ++i) {\n                handleBindingEvent(arr[i], pressed, inputs, null); // pass null as fake event\n            }\n        }\n    }\n}\n\nfunction updateGamepads(inputs) {\n    var found = scanGamepads(inputs);\n    if (!found) {\n        if (inputs._gamepadRaf) {\n            cancel(inputs._gamepadRaf);\n            inputs._gamepadRaf = false;\n        }\n        return;\n    }\n\n    var vcode = '';\n    for (var j in inputs._gamepads) {\n        var gamepad = inputs._gamepads[j];\n\n        for (var i = 0; i < gamepad.buttons.length; i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadButtonNames[i] + '>';\n            handleGamePadButtonEvent(gamepad.buttons[i], vcode, inputs);\n        }\n\n        for (i = 0; i < gamepad.axes.length; i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadAxesNames[i] + '>';\n            inputs.state[vcode] = gamepad.axes[i];\n        }\n    }\n    inputs._gamepadRaf = request(updateGamepads);\n}\n\nfunction onGamepadConnected(inputs, ev) {\n    addGamepad(inputs, ev.gamepad);\n}\n\nfunction onGamepadDisconnected(inputs, ev) {\n    removeGamepad(inputs, ev.gamepad);\n}\n\n\nfunction addGamepad(inputs, gamepad) {\n    inputs._gamepads[gamepad.index] = gamepad;\n    inputs.gamepadconnected.emit(gamepad);\n    if (!inputs._gamepadRaf) {\n        inputs._gamepadRaf = request(updateGamepads);\n    }\n}\n\nfunction removeGamepad(inputs, gamepad) {\n    delete inputs._gamepads[gamepad.index];\n    inputs.gamepaddisconnected.emit(gamepad);\n    for (var j in inputs._gamepads) {\n        if (inputs._gamepads.hasOwnProperty(j)) {\n            return;\n        }\n    }\n    if (inputs._gamepadRaf) {\n        cancel(inputs._gamepadRaf);\n        inputs._gamepadRaf = false;\n    }\n}\n\n\nfunction scanGamepads(inputs) {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n    var found = false;\n    for (var i = 0; i < gamepads.length; i++) {\n        if (gamepads[i]) {\n            found = true;\n            if (!(gamepads[i].index in inputs._gamepads)) {\n                addGamepad(inputs, gamepads[i]);\n            } else {\n                inputs._gamepads[gamepads[i].index] = gamepads[i];\n            }\n        }\n    }\n    return found;\n}\n\n/*\n *    HELPERS\n *\n */\n\n\n// how is this not part of Javascript?\nfunction XOR(a, b) {\n    return a ? !b : b;\n}\n\n},{\"./mousewheel-polyfill\":29,\"eventemitter3\":2,\"request-frame\":3,\"vkey\":4}],31:[function(require,module,exports){\n/*\n * Doubly Linked List implementation in JavaScript\n * Copyright (c) 2009 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*\n * Optimizations and data reuse by Wouter Commandeur\n */\n\n'use strict';\n\n/**\n * A linked list implementation in JavaScript.\n * @class DoublyLinkedList\n * @constructor\n */\nfunction DoublyLinkedList() {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    this._head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    this._tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type int\n     * @private\n     */\n    this._length = 0;\n\n    this._nodeCache = [];\n\n}\n\nDoublyLinkedList.prototype = {\n\n    //restore constructor\n    constructor: DoublyLinkedList,\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {variant} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    add: function (data) {\n        //create a new item object, place data in\n        var node = this._allocate(data);\n\n        //special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n        } else {\n            //attach to the tail node\n            this._tail.next = node;\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        //don't forget to update the count\n        this._length++;\n\n    },\n\n\n    set: function (index, data) {\n        // update data at index\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while (i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while (i++ < index) {\n                    current = current.next;\n                }\n            }\n            current.data = data;\n        }\n    },\n\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {int} index The zero-based index of the item whose value\n     *      should be returned.\n     * @return {variant} The value in the \"data\" portion of the given item\n     *      or null if the item doesn't exist.\n     * @method item\n     */\n    item: function (index) {\n\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while (i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while (i++ < index) {\n                    current = current.next;\n                }\n            }\n            return current.data;\n        } else {\n            return null;\n        }\n    },\n\n    pop: function () {\n        return this.remove(this._length - 1);\n    },\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {variant} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    remove: function (index) {\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n\n            var current = this._head,\n                i = 0;\n\n            //special case: removing first item\n            if (index === 0) {\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head) {\n                    this._tail = null;\n                } else {\n                    this._head.prev = null;\n                }\n\n                //special case: removing last item\n            } else if (index === this._length - 1) {\n                current = this._tail;\n                this._tail = current.prev;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while (i++ < index) {\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.prev.next = current.next;\n            }\n\n            //decrement the length\n            this._length--;\n\n            // release into object pool\n            this._free(current);\n\n            //return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    },\n\n    clear: function () {\n        while (this._length > 0) {\n            this.remove(0);\n        }\n    },\n\n    /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    size: function () {\n        return this._length;\n    },\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    toArray: function () {\n        var result = [],\n            current = this._head;\n\n        while (current) {\n            result.push(current.data);\n            current = current.next;\n        }\n\n        return result;\n    },\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    toString: function () {\n        return this.toArray().toString();\n    },\n\n    _free: function (node) {\n        this._nodeCache.push(node);\n    },\n\n    _allocate: function (data) {\n        var node = this._nodeCache.pop();\n        if (!node) {\n            node = {};\n        }\n        node.data = data;\n        node.prev = null;\n        node.next = null;\n        return node;\n    }\n};\n\nmodule.exports = DoublyLinkedList;\n\n},{}],32:[function(require,module,exports){\nmodule.exports = {\n    DoublyLinkedList: require('./doublylinkedlist')\n};\n\n},{\"./doublylinkedlist\":31}],33:[function(require,module,exports){\n'use strict';\n\n/* jshint -W064 */\nvar RegularPolygon2 = require('../../geometry/regularpolygon2');\nvar Polygon2 = require('../../geometry/polygon2');\nvar Vector2 = require('../../geometry/vector2');\nvar LineSegment2 = require('../../geometry/linesegment2');\nvar gpc = require('../../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('../graph');\n\nmodule.exports = Building;\n\nvar createPoly = function (points) {\n    var res = new gpc.geometry.PolyDefault();\n    for (var i = 0; i < points.length; i++) {\n        res.addPoint(new gpc.geometry.Point(points[i][0], points[i][1]));\n    }\n    return res;\n};\n\nvar getPolygonVertices = function (poly) {\n    var vertices = [];\n    var numPoints = poly.getNumPoints();\n    var i;\n\n    for (i = 0; i < numPoints; i++) {\n        vertices.push([poly.getX(i), poly.getY(i)]);\n    }\n    return vertices;\n};\n\nfunction Building(chance, iterations, minRadius, maxRadius, maxSides, noRotate) {\n    var end, l;\n    this.centers = [];\n    iterations = iterations || 1;\n//\tif ( iterations < 3 ) {\n//\t\titerations = 3;\n//\t}\n    maxSides = maxSides || 6;\n    if (maxSides < 4) {\n        maxSides = 4;\n    }\n    var sidesChanceObj = {min: 4, max: maxSides};\n    var radiusChanceObj = {min: minRadius, max: maxRadius};\n\n    var sides = chance.integer(sidesChanceObj);\n    var polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n    var gpcPoly = createPoly(polygon.toArray());\n    polygon.free();\n    var vec, gpcPoly2, num;\n    this.centers.push(Vector2());\n\n    for (var i = 1; i < iterations; i++) {\n        // new random polygon\n        sides = chance.integer(sidesChanceObj);\n        polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\n        // rotate random\n        if (!noRotate) {\n            polygon.rotate(chance.floating({min: 0, max: 2 * Math.PI / sides}));\n        }\n\n        // random point on prev poly\n        num = chance.integer({min: 0, max: gpcPoly.getNumPoints() - 1});\n        vec = Vector2(gpcPoly.getX(num), gpcPoly.getY(num));\n        this.centers.push(vec);\n\n        // center the polygon on a random point of the previous polygon\n        polygon.translate(vec);\n        gpcPoly2 = createPoly(polygon.toArray());\n        gpcPoly = gpcPoly.union(gpcPoly2);\n\n        // free our stuff for reuse\n        polygon.free();\n    }\n    var arr = getPolygonVertices(gpcPoly);\n\n    // generate final polygon\n    polygon = Polygon2.fromArray(arr);\n    this.polygon = polygon;\n\n    // this.polygon.clean(30);\n\n    // add outer doors\n    var nrdoors = Math.ceil(iterations / 2);\n    this.doors = [];\n\n    var nr;\n    var dooredges = {};\n    for (i = 0; i < nrdoors; i++) {\n        nr = chance.integer({min: 0, max: this.polygon.points.length - 1});\n        while (dooredges[nr]) {\n            nr = chance.integer({min: 0, max: this.polygon.points.length - 1});\n        }\n        dooredges[nr] = true;\n        end = nr + 1;\n        if (end === this.polygon.points.length) {\n            end = 0;\n        }\n        l = LineSegment2(this.polygon.points[nr].clone(), this.polygon.points[end].clone());\n        var p2 = l.end.clone();\n        var p1 = l.start.clone();\n        var length = l.length(); // p2.subtract(l.start).length();\n        p2.subtract(l.start).normalize().multiplyScalar(length / 2);\n        p1.add(p2);\n        // this.centers.push(p1);\n        this.doors.push(p1);\n        p2.free();\n        l.free();\n    }\n\n\n    var c = [];\n    for (i = 0; i < this.centers.length; i++) {\n        c.push(this.centers[i].toArray());\n    }\n\n    this.graph = new Graph();\n    this.delaunay_used = {};\n\n    // delaunay the centers\n    this.delaunay = Delaunay.triangulate(c);\n\n    for (i = 0; i < this.delaunay.length; i += 1) {\n        if (!this.delaunay_used[this.delaunay[i]]) {\n            this.graph.addNode(this.delaunay[i]);\n            this.delaunay_used[this.delaunay[i]] = true;\n        }\n    }\n\n\n    this.delaunay_exists = {};\n\n    this.delaunay_triangles = [];\n    this.delaunay_lines = [];\n    for (i = 0; i < this.delaunay.length; i += 3) {\n        // line 1\n        this.addDelaunayLine(i, i + 1);\n        this.addDelaunayLine(i + 1, i + 2);\n        this.addDelaunayLine(i + 2, i);\n    }\n\n    // connect the doors;\n    nr = this.centers.length;\n    for (i = 0; i < this.doors.length; i++) {\n        this.connectDoor(this.doors[i], nr);\n    }\n\n\n    // calculate the minimal spanning tree\n    var edges = this.graph.prim(); // Prim(this.graph);\n    // console.log(edges);\n    this.mst_lines = [];\n\n    for (i = 0; i < edges.length; i++) {\n        var start = edges[i].source;\n        end = edges[i].sink;\n        l = LineSegment2(this.centers[start].clone(), this.centers[end].clone());\n        this.mst_lines.push(l);\n        //var l = LineSegment2()\n    }\n\n\n    this.outside = this.polygon.AABB();\n\n    this.outside[0].subtractScalar(50);\n    this.outside[1].addScalar(50);\n\n}\n\nBuilding.prototype.connectDoor = function (door, nr) {\n    var min = 9999999;\n    var l, d;\n    var point = false;\n    for (var i = 0; i < nr; i++) {\n        l = LineSegment2(this.centers[i].clone(), door.clone());\n        if (!this.polygon.intersectsLine(l, true)) {\n            d = l.length();\n            if (d < min) {\n                min = d;\n                point = i;\n            }\n        }\n        l.free();\n    }\n    if (point !== false) {\n        this.centers.push(door.clone());\n        this.graph.addNode(this.centers.length - 1);\n        this.graph.addEdge(point, this.centers.length - 1, min);\n        this.delaunay_lines.push(LineSegment2(this.centers[point].clone(), door.clone()));\n    } else {\n        l.free();\n    }\n\n};\n\nBuilding.prototype.addDelaunayLine = function (start, end) {\n    var key1 = start + ':' + end;\n    var key2 = end + ':' + start;\n    if (this.delaunay_exists[key1] || this.delaunay_exists[key2]) {\n        return;\n    }\n    this.delaunay_exists[key1] = true;\n    this.delaunay_exists[key2] = true;\n    var l = LineSegment2(this.centers[this.delaunay[start]].clone(), this.centers[this.delaunay[end]].clone());\n    if (this.polygon.intersectsLine(l)) {\n        l.free();\n    } else {\n        this.graph.addEdge(this.delaunay[start], this.delaunay[end], l.length());\n        this.delaunay_lines.push(l);\n    }\n};\n\n\nBuilding.prototype.translate = function (vec) {\n    this.polygon.translate(vec);\n    for (var i = 0; i < this.centers.length; i++) {\n        this.centers[i].add(vec);\n    }\n    for (i = 0; i < this.delaunay_triangles.length; i++) {\n        this.delaunay_triangles[i].translate(vec);\n    }\n    return this;\n};\n\n\n/* jshint +W064 */\n\n},{\"../../geometry/gpc\":11,\"../../geometry/linesegment2\":16,\"../../geometry/polygon2\":17,\"../../geometry/regularpolygon2\":23,\"../../geometry/vector2\":25,\"../graph\":35,\"delaunay-fast\":1}],34:[function(require,module,exports){\n'use strict';\n\nvar Rectangle2 = require('../../geometry/rectangle2');\nvar Vector2 = require('../../geometry/vector2');\nvar LineSegment2 = require('../../geometry/linesegment2');\nvar gpc = require('../../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('../graph');\nvar avoidance = require('../../ai/steering').avoidance;\n\n/* jshint -W064 */\nmodule.exports = Dungeon;\n\nvar GENERATE_ROOMS = 1,\n    EVADE_ROOMS = 2,\n    SELECT_ROOMS = 3;\n\n\nfunction Dungeon(chance, iterations, radius, minSide, maxSide) {\n    this.sizeChance = {min: minSide, max: maxSide};\n    this.posChance = {min: 0, max: 1};\n    this.rooms = [];\n    this.vectors = [];\n    this.chance = chance;\n    this.iterations = iterations;\n    this.radius = radius;\n    this.minSide = minSide;\n    this.maxSide = maxSide;\n    this.state = GENERATE_ROOMS;\n}\n\n\nDungeon.prototype.step = function () {\n    switch (this.state) {\n        case GENERATE_ROOMS:\n            this.addRoom();\n            break;\n        case EVADE_ROOMS:\n            this.evadeRooms();\n            break;\n        default:\n            break;\n    }\n};\n\nDungeon.prototype.addRoom = function () {\n    var t = 2 * Math.PI * this.chance.floating(this.posChance);\n    var u = this.chance.floating(this.posChance) + this.chance.floating(this.posChance);\n    var r = ( u > 1 ? 2 - u : u );\n    var x = this.radius * r * Math.cos(t);\n    var y = this.radius * r * Math.sin(t);\n    var w = this.chance.integer(this.sizeChance);\n    var h = this.chance.integer(this.sizeChance);\n\n    var room = Rectangle2(x - (w / 2), y - (h / 2), w, h);\n    this.rooms.push(room);\n    this.vectors.push(Vector2());\n\n    if (this.rooms.length === this.iterations) {\n        this.state = EVADE_ROOMS;\n    }\n};\n\nDungeon.prototype.evadeRooms = function () {\n    var l = this.rooms.length;\n    var i, r, v, j, rr, f;\n    var p1 = Vector2();\n    var p2 = Vector2();\n    var avoided = false;\n    var oneAvoided = false;\n    for (i = 0; i < l; i++) {\n        avoided = false;\n        r = this.rooms[i];\n        v = this.vectors[i];\n        for (j = 0; j < l; j++) {\n            if (j !== i) {\n                rr = this.rooms[j];\n                if (r.intersects(rr)) {\n                    // avoidance force\n                    p1.set(r.x, r.y);\n                    p2.set(rr.x, rr.y);\n                    f = avoidance(p2, p1, v, 10, 10, 5); // arbitrary numbers, but it seems to work\n                    v.copy(f);\n                    f.free();\n                    avoided = true;\n                }\n            }\n        }\n        if (avoided) {\n            r.x += v.x;\n            r.y += v.y;\n            oneAvoided = true;\n        }\n    }\n\n    p1.free();\n    p2.free();\n    if (!oneAvoided) {\n        v = this.vectors.pop();\n        while (v) {\n            v.free();\n            v = this.vectors.pop();\n        }\n        this.state = SELECT_ROOMS;\n    }\n};\n/* jshint +W064 */\n},{\"../../ai/steering\":5,\"../../geometry/gpc\":11,\"../../geometry/linesegment2\":16,\"../../geometry/rectangle2\":22,\"../../geometry/vector2\":25,\"../graph\":35,\"delaunay-fast\":1}],35:[function(require,module,exports){\n'use strict';\n\n\n// Represents an edge from source to sink with capacity\nvar Edge = function (source, sink, capacity) {\n    this.source = source;\n    this.sink = sink;\n    this.capacity = capacity;\n};\n\n// Main class to manage the network\nvar Graph = function () {\n    this.edges = {};\n    this.nodes = [];\n    this.nodeMap = {};\n\n    // Add a node to the graph\n    this.addNode = function (node) {\n        this.nodes.push(node);\n        this.nodeMap[node] = this.nodes.length - 1;\n        this.edges[node] = [];\n    };\n\n    // Add an edge from source to sink with capacity\n    this.addEdge = function (source, sink, capacity) {\n        // Create the two edges = one being the reverse of the other\n        this.edges[source].push(new Edge(source, sink, capacity));\n        this.edges[sink].push(new Edge(sink, source, capacity));\n    };\n\n    // Does edge from source to sink exist?\n    this.edgeExists = function (source, sink) {\n        if (this.edges[source] !== undefined) {\n            for (var i = 0; i < this.edges[source].length; i++) {\n                if (this.edges[source][i].sink === sink) {\n                    return this.edges[source][i];\n                }\n            }\n        }\n        return null;\n    };\n\n\n    this.prim = function () {\n        var result = [];\n        var resultEdges = [];\n        var usedNodes = {};\n\n        function findMin(g) {\n            var min = [999999, null];\n            for (var i = 0; i < result.length; i++) {\n                for (var n = 0; n < g.edges[result[i]].length; n++) {\n                    if (g.edges[result[i]][n].capacity < min[0] && usedNodes[g.edges[result[i]][n].sink] === undefined) {\n                        min = [g.edges[result[i]][n].capacity, g.edges[result[i]][n]];\n                    }\n                }\n            }\n            return min;\n        }\n\n        // Pick random start point\n        var node = this.nodes[Math.round(Math.random() * (this.nodes.length - 1))];\n        result.push(node);\n        usedNodes[node] = true;\n\n        var min = findMin(this);\n        while (min[1] !== null) {\n            resultEdges.push(min[1]);\n            result.push(min[1].sink);\n            usedNodes[min[1].sink] = true;\n            min = findMin(this);\n        }\n\n        return resultEdges;\n    };\n\n};\n\nmodule.exports = Graph;\n\n},{}],36:[function(require,module,exports){\nmodule.exports = {\n    Graph: require('./graph'),\n    Building: require('./building'),\n    Dungeon: require('./dungeon')\n};\n \n},{\"./building\":33,\"./dungeon\":34,\"./graph\":35}],37:[function(require,module,exports){\n'use strict';\n\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\n\nvar NOOP = function () {\n};\n\nmodule.exports = GameLoop;\n\nfunction GameLoop() {\n    this.simulationTimestep = 1000 / 60;\n    this.frameDelta = 0;\n    this.lastFrameTimeMs = 0;\n    this.fps = 60;\n    this.lastFpsUpdate = 0;\n    this.framesThisSecond = 0;\n    this.numUpdateSteps = 0;\n    this.minFrameDelay = 0;\n    this.running = false;\n    this.started = false;\n    this.panic = false;\n    this.rafHandle = false;\n    this.boundAnimate = this.animate.bind(this);\n}\n\nGameLoop.prototype.begin = NOOP;\nGameLoop.prototype.update = NOOP;\nGameLoop.prototype.render = NOOP;\nGameLoop.prototype.end = NOOP;\n\nGameLoop.prototype.getSimulationTimestep = function () {\n    return this.simulationTimestep;\n};\n\nGameLoop.prototype.setSimulationTimestep = function (timestep) {\n    this.simulationTimestep = timestep;\n    return this;\n};\n\nGameLoop.prototype.getFPS = function () {\n    return this.fps;\n};\n\nGameLoop.prototype.getMaxAllowedFPS = function () {\n    return 1000 / this.minFrameDelay;\n};\n\nGameLoop.prototype.setMaxAllowedFPS = function (fps) {\n    if (typeof fps === 'undefined') {\n        fps = Infinity;\n    }\n    if (fps === 0) {\n        this.stop();\n    }\n    else {\n        // Dividing by Infinity returns zero.\n        this.minFrameDelay = 1000 / fps;\n    }\n    return this;\n};\n\nGameLoop.prototype.resetFrameDelta = function () {\n    var oldFrameDelta = this.frameDelta;\n    this.frameDelta = 0;\n    return oldFrameDelta;\n};\n\nGameLoop.prototype.setBegin = function (fun) {\n    this.begin = fun || this.begin;\n    return this;\n};\n\nGameLoop.prototype.setUpdate = function (fun) {\n    this.update = fun || this.update;\n    return this;\n};\n\nGameLoop.prototype.setRender = function (fun) {\n    this.render = fun || this.render;\n    return this;\n};\n\nGameLoop.prototype.setEnd = function (fun) {\n    this.end = fun || this.end;\n    return this;\n};\n\nGameLoop.prototype.start = function () {\n    if (!this.started) {\n        this.started = true;\n        var self = this;\n        this.rafHandle = request(function (timestamp) {\n            self.render(1);\n            self.running = true;\n            self.lastFrameTimeMs = timestamp;\n            self.lastFpsUpdate = timestamp;\n            self.framesThisSecond = 0;\n            self.rafHandle = request(self.boundAnimate);\n        });\n    }\n    return this;\n};\n\nGameLoop.prototype.stop = function () {\n    this.running = false;\n    this.started = false;\n    cancel(this.rafHandle);\n    return this;\n};\n\nGameLoop.prototype.isRunning = function () {\n    return this.running;\n};\n\nGameLoop.prototype.animate = function animate(timestamp) {\n\n    if (timestamp < this.lastFrameTimeMs + this.minFrameDelay) {\n        this.rafHandle = request(this.boundAnimate);\n        return;\n    }\n\n    this.frameDelta += timestamp - this.lastFrameTimeMs;\n    this.lastFrameTimeMs = timestamp;\n\n    this.begin(timestamp, this.frameDelta);\n\n    if (timestamp > this.lastFpsUpdate + 1000) {\n        this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;\n        this.lastFpsUpdate = timestamp;\n        this.framesThisSecond = 0;\n    }\n    this.framesThisSecond++;\n\n    /* - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    this.numUpdateSteps = 0;\n    while (this.frameDelta >= this.simulationTimestep) {\n        this.update(this.simulationTimestep);\n        this.frameDelta -= this.simulationTimestep;\n\n        if (++this.numUpdateSteps >= 240) {\n            this.panic = true;\n            break;\n        }\n    }\n\n    this.render(this.frameDelta / this.simulationTimestep);\n\n    this.end(this.fps, this.panic);\n\n    this.panic = false;\n\n    this.rafHandle = request(this.boundAnimate);\n};\n\n},{\"request-frame\":3}],38:[function(require,module,exports){\nmodule.exports = {\n    GameLoop: require('./gameloop')\n};\n\n},{\"./gameloop\":37}]},{},[27])(27)\n});\n\n","'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\n *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for\n *   optimal cross-browser development.\n *    Version:  v1.4.0\n *     License:  MIT\n *      Copyright Julien Etienne 2015 All Rights Reserved.\n *        github:  https://github.com/julienetie/request-frame\n *\n */\n(function (window) {\n\n/**\n * @param  {String} type - request | cancel | native.\n * @return {Function} Timing function.\n */\nfunction requestFrame(type) {\n    // The only vendor prefixes required.\n    var vendors = ['moz', 'webkit'],\n\n        // Disassembled timing function abbreviations.\n        aF = 'AnimationFrame',\n        rqAF = 'Request' + aF,\n\n        // Final assigned functions.\n        assignedRequestAnimationFrame,\n        assignedCancelAnimationFrame,\n\n        // Initial time of the timing lapse.\n        previousTime = 0,\n\n        mozRAF = window.mozRequestAnimationFrame,\n        mozCAF = window.mozCancelAnimationFrame,\n\n        // Checks for firefox 4 - 10 function pair mismatch.\n        hasMozMismatch = mozRAF && !mozCAF,\n\n        func;\n\n    // Date.now polyfill, mainly for legacy IE versions.\n    if (!Date.now) {\n        Date.now = function() {\n            return new Date().getTime();\n        };\n    }\n\n    /**\n     * hasIOS6RequestAnimationFrameBug.\n     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}\n     * - for Commentary.\n     * @Copyright 2015 - Julien Etienne. \n     * @License: MIT.\n     */\n    function hasIOS6RequestAnimationFrameBug() {\n        var webkitRAF = window.webkitRequestAnimationFrame,\n            rAF = window.requestAnimationFrame,\n\n            // CSS/ Device with max for iOS6 Devices.\n            hasMobileDeviceWidth = screen.width <= 768 ? true : false,\n\n            // Only supports webkit prefixed requestAnimtionFrane.\n            requiresWebkitprefix = !(webkitRAF && rAF),\n\n            // iOS6 webkit browsers don't support performance now.\n            hasNoNavigationTiming = window.performance ? false : true,\n\n            iOS6Notice = 'setTimeout is being used as a substitiue for' +\n            'requestAnimationFrame due to a bug within iOS 6 builds',\n\n            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&\n            hasNoNavigationTiming;\n\n        function bugCheckresults(timingFnA, timingFnB, notice) {\n            if (timingFnA || timingFnB) {\n                console.warn(notice);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function displayResults() {\n            if (hasIOS6Bug) {\n                return bugCheckresults(webkitRAF, rAF, iOS6Notice);\n            } else {\n                return false;\n            }\n        }\n\n        return displayResults();\n    }\n\n    /**\n     * Native clearTimeout function.\n     * @return {Function}\n     */\n    function clearTimeoutWithId(id) {\n        clearTimeout(id);\n    }\n\n    /**\n     * Based on a polyfill by Erik, introduced by Paul Irish & \n     * further improved by Darius Bacon.\n     * @see  {@link http://www.paulirish.com/2011/\n     * requestanimationframe-for-smart-animating}\n     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/\n     * master/requestAnimationFrame.js}\n     * @callback {Number} Timestamp.\n     * @return {Function} setTimeout Function.\n     */\n    function setTimeoutWithTimestamp(callback) {\n        var immediateTime = Date.now(),\n            lapsedTime = Math.max(previousTime + 16, immediateTime);\n        return setTimeout(function() {\n                callback(previousTime = lapsedTime);\n            },\n            lapsedTime - immediateTime);\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the setTimeoutWithTimestamp function.\n     * @return {Function}\n     */\n    function queryRequestAnimationFrame() {\n        if (Array.prototype.filter) {\n            assignedRequestAnimationFrame = window['request' + aF] ||\n                window[vendors.filter(function(vendor) {\n                    if (window[vendor + rqAF] !== undefined)\n                        return vendor;\n                }) + rqAF] || setTimeoutWithTimestamp;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedRequestAnimationFrame;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the clearTimeoutWithId function.\n     * @return {Function}\n     */\n    function queryCancelAnimationFrame() {\n        var cancellationNames = [];\n        if (Array.prototype.map) {\n            vendors.map(function(vendor) {\n                return ['Cancel', 'CancelRequest'].map(\n                    function(cancellationNamePrefix) {\n                        cancellationNames.push(vendor +\n                            cancellationNamePrefix + aF);\n                    });\n            });\n        } else {\n            return clearTimeoutWithId;\n        }\n\n        /**\n         * Checks for the prefixed cancelAnimationFrame implementation.\n         * @param  {Array} prefixedNames - An array of the prefixed names. \n         * @param  {Number} i - Iteration start point.\n         * @return {Function} prefixed cancelAnimationFrame function.\n         */\n        function prefixedCancelAnimationFrame(prefixedNames, i) {\n            var cancellationFunction;\n            for (; i < prefixedNames.length; i++) {\n                if (window[prefixedNames[i]]) {\n                    cancellationFunction = window[prefixedNames[i]];\n                    break;\n                }\n            }\n            return cancellationFunction;\n        }\n\n        // Use truthly function\n        assignedCancelAnimationFrame = window['cancel' + aF] ||\n            prefixedCancelAnimationFrame(cancellationNames, 0) ||\n            clearTimeoutWithId;\n\n        // Check for iOS 6 bug\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedCancelAnimationFrame;\n        } else {\n            return clearTimeoutWithId;\n        }\n    }\n\n    function getRequestFn() {\n        if (hasMozMismatch) {\n            return setTimeoutWithTimestamp;\n        } else {\n            return queryRequestAnimationFrame();\n        }\n    }\n\n    function getCancelFn() {\n        return queryCancelAnimationFrame();\n    }\n\n    function setNativeFn() {\n        if (hasMozMismatch) {\n            window.requestAnimationFrame = setTimeoutWithTimestamp;\n            window.cancelAnimationFrame = clearTimeoutWithId;\n        } else {\n            window.requestAnimationFrame = queryRequestAnimationFrame();\n            window.cancelAnimationFrame = queryCancelAnimationFrame();\n        }\n    }\n\n    /**\n     * The type value \"request\" singles out firefox 4 - 10 and \n     * assigns the setTimeout function if plausible.\n     */\n\n    switch (type) {\n        case 'request':\n        case '':\n            func = getRequestFn();\n            break;\n\n        case 'cancel':\n            func = getCancelFn();\n            break;\n\n        case 'native':\n            setNativeFn();\n            break;\n        default:\n            throw new Error('RequestFrame parameter is not a type.');\n    }\n    return func;\n}\n\n\n// Node.js/ CommonJS\nif (typeof module === 'object' && typeof module.exports === 'object') {\nmodule.exports = exports = requestFrame;\n}\n\n// AMD\nelse if (typeof define === 'function' && define.amd) {\ndefine(function() {\n  return requestFrame;\n});\n}\n\n// Default to window as global\nelse if (typeof window === 'object') {\nwindow.requestFrame = requestFrame;\n}\n/* global -module, -exports, -define */\n\n}((typeof window === \"undefined\" ? {} : window)));\n","var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n","var Vector2 = require('../geometry/vector2');\n\nfunction straight(target, position) {\n    return target.clone().subtract(position).normalize();\n}\n\nfunction seek(target, position, currentVelocity, maxVelocity, slowingRadius) {\n    var desired = target.clone().subtract(position);\n    var distance = desired.length();\n    desired = desired.normalize();\n\n    if (distance <= slowingRadius) {\n        desired = desired.multipyScalar(maxVelocity * (distance / slowingRadius));\n    } else {\n        desired = desired.multipyScalar(maxVelocity);\n    }\n\n    return desired.subtract(currentVelocity);\n}\n\nfunction flee(target, position, currentVelocity, maxVelocity) {\n    // chaining madness\n    return position.clone().subtract(target).normalize().multiplyScalar(maxVelocity).subtract(currentVelocity);\n}\n\nfunction wander(currentVelocity, wanderDistance, wanderRadius, wanderAngle) {\n    // wanderAngle should be something like:\n    // wanderAngle += Math.random() * angleChange - angleChange * .5;\n    var force = currentVelocity.clone().normalize().multiplyScalar(wanderDistance);\n    /* jshint -W064 */\n    var displacement = Vector2(0, -1).multiplyScaler(wanderRadius).setAngle(wanderAngle);\n    /* jshint +W064 */\n    force = force.add(displacement);\n    displacement.free();\n    return force; // force applied\n}\n\nfunction evade(target, position, maxVelocity, currentVelocity, targetVelocity) {\n    var distance = target.clone().subtract(position);\n    var updatesNeeded = distance.length() / maxVelocity;\n    distance.free();\n    var tv = targetVelocity.clone().multiplyScalar(updatesNeeded);\n    var targetFuturePosition = targetVelocity.clone().add(tv);\n    tv.free();\n    var force = flee(targetFuturePosition, position, currentVelocity, maxVelocity);\n    targetFuturePosition.free();\n    return force;\n}\n\nfunction pursuit(target, position, maxVelocity, currentVelocity, targetVelocity) {\n    var distance = target.clone().subtract(position);\n    var updatesNeeded = distance.length() / maxVelocity;\n    distance.free();\n    var tv = targetVelocity.clone().multiplyScaler(updatesNeeded);\n    var targetFuturePosition = targetVelocity.clone().add(tv);\n    tv.free();\n    var force = seek(targetFuturePosition, position, currentVelocity, maxVelocity, 0);\n    targetFuturePosition.free();\n    return force;\n}\n\nfunction avoidance(target, position, velocity, maxAvoidAhead, maxVelocity, avoidanceForce) {\n    var tv = velocity.clone().normalize().multiplyScalar((maxAvoidAhead * velocity.length()) / maxVelocity);\n    var force = position.clone().add(tv).subtract(target).normalize().multiplyScalar(avoidanceForce);\n    tv.free();\n    return force;\n}\n\nexports = module.exports = {\n    straight: straight,\n    evade: evade,\n    seek: seek,\n    flee: flee,\n    wander: wander,\n    pursuit: pursuit,\n    avoidance: avoidance\n};\n","'use strict';\n\nvar StateStack = require('./statestack');\nvar GameLoop = require('../timer/gameloop');\nvar NOOP = function () {\n};\n\nmodule.exports = Game;\n\nfunction Game() {\n    this.states = {};\n    this.statestack = new StateStack();\n    this.gameloop = new GameLoop();\n\n    var self = this;\n\n    this.gameloop.setBegin(\n        function (timestamp, frameDelta) {\n            self.begin(timestamp, frameDelta);\n            self.statestack.begin(timestamp, frameDelta);\n        }\n    );\n\n    this.gameloop.setUpdate(\n        function (simulationTimestep) {\n            self.update(simulationTimestep);\n            self.statestack.update(simulationTimestep);\n        }\n    );\n\n    this.gameloop.setRender(\n        function (percentageTimestepRemaining) {\n            // render -> game is last.\n            self.statestack.render(percentageTimestepRemaining);\n            self.render(percentageTimestepRemaining);\n        }\n    );\n\n    this.gameloop.setEnd(\n        function (fps, panic) {\n            self.end(fps.panic);\n            self.statestack.end(fps, panic);\n        }\n    );\n\n}\n\n/* GAMELOOP HANDLING */\n\nGame.prototype.start = function () {\n    return this.gameloop.start();\n};\n\nGame.prototype.stop = function () {\n    return this.gameloop.stop();\n};\n\nGame.prototype.begin = NOOP;\nGame.prototype.end = NOOP;\nGame.prototype.update = NOOP;\nGame.prototype.render = NOOP;\n\n\n/* STATE HANDLING */\n\nGame.prototype.addState = function (state) {\n    state.game = this;\n    this.states[state.name] = state;\n    state.create();\n    return this;\n};\n\nGame.prototype.startState = function (stateName) {\n    var state = this.states[stateName];\n    if (!state) {\n        return;\n    }\n    return this.statestack.push(this.states[stateName]);\n};\n\nGame.prototype.stopState = function (stateName) {\n    var state = this.states[stateName];\n    if (!state) {\n        return;\n    }\n    return this.statestack.pop(state);\n};\n","module.exports = {\n    Game: require('./game'),\n    State: require('./state'),\n    StateList: require('./statelist'),\n    StateStack: require('./statestack')\n};\n","'use strict';\n\nmodule.exports = State;\n\nvar NOOP = function () {\n};\n\nfunction State(name) {\n    this.name = name;\n}\n\nState.prototype.create = NOOP;\nState.prototype.begin = NOOP;\nState.prototype.update = NOOP;\nState.prototype.render = NOOP;\nState.prototype.end = NOOP;\nState.prototype.onEnter = NOOP;\nState.prototype.onExit = NOOP;\n","'use strict';\n\nmodule.exports = StateList;\n\nfunction StateList() {\n    this.states = [];\n}\n\nStateList.prototype.pop = function () {\n    return this.states.pop();\n};\n\nStateList.prototype.push = function (state) {\n    return this.states.push(state);\n};\n\nStateList.prototype.top = function (depth) {\n    depth = depth || 0;\n    return this.states[this.states.length - (depth + 1)];\n};\n","'use strict';\n\nvar StateList = require('./statelist');\n\nmodule.exports = StateStack;\n\nfunction StateStack() {\n    this.states = new StateList();\n}\n\nStateStack.prototype.begin = function (timestamp, frameDelta) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.begin(timestamp, frameDelta)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.update = function (simulationTimestep) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.update(simulationTimestep)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.render = function (percentageTimestepRemaining) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.render(percentageTimestepRemaining)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.end = function (fps, panic) {\n    var depth = 0;\n    var state = this.states.top(depth);\n    while (state) {\n        if (!state.end(fps, panic)) {\n            state = this.states.top(++depth);\n        } else {\n            state = false;\n        }\n    }\n};\n\nStateStack.prototype.pop = function () {\n    var state = this.states.pop();\n    state.onExit();\n    return state;\n};\n\nStateStack.prototype.push = function (state) {\n    this.states.push(state);\n    return state.onEnter();\n};\n","'use strict';\n\nvar gpcas = gpcas || {};\ngpcas.util = {};\ngpcas.geometry = {};\n\nmodule.exports = gpcas;\n\n//////////\nvar Clip, BundleState, LmtNode, TopPolygonNode, AetTree, HState, VertexType, VertexNode, ItNodeTable, StNode;\n\n//Object.prototype.equals = function(x) {\nfunction equals(x1, x) {\n\n    var p;\n    for (p in x1) {\n        if (typeof(x[p]) === 'undefined') {\n            return false;\n        }\n    }\n\n    for (p in x1) {\n        if (x1[p]) {\n            switch (typeof(x1[p])) {\n                case 'object':\n                    if (!equals(x1[p], x[p])) {\n                        return false;\n                    }\n                    break;\n                case 'function':\n                    if (typeof(x[p]) === 'undefined' ||\n                        (p !== 'equals' && x1[p].toString() !== x[p].toString()))\n                        return false;\n                    break;\n                default:\n                    if (x1[p] !== x[p]) {\n                        return false;\n                    }\n            }\n        } else {\n            if (x[p])\n                return false;\n        }\n    }\n\n    for (p in x) {\n        if (typeof(x1[p]) === 'undefined') {\n            return false;\n        }\n    }\n\n    return true;\n}\n///point\nvar Point = function (x, y) {\n    this.x = x;\n    this.y = y;\n};\ngpcas.geometry.Point = Point;\n\n////////////// CLASS ArrayHelper ////////////////////////////////////\ngpcas.util.ArrayHelper = function () {\n};\nvar gpcstatic = gpcas.util.ArrayHelper;\n\ngpcstatic.create2DArray = function (x, y) {\n    var a = [];\n    for (var i = 0; i < x; i++) {\n        a[i] = [];\n    }\n    return a;\n};\ngpcstatic.valueEqual = function (obj1, obj2) {\n    if (obj1 === obj2) return true;\n    if (equals(obj1, obj2)) return true;\n\n    return false;\n}\ngpcstatic.sortPointsClockwise = function (vertices) {\n    var isArrayList = false;\n\n    if (vertices instanceof gpcas.util.ArrayList) {\n        vertices = vertices.toArray();\n        isArrayList = true;\n    }\n\n    //point\n    var maxTop = null;\n    var maxBottom = null;\n    var maxLeft = null;\n    var maxRight = null;\n\n\n    var maxLeftIndex;\n    var newVertices = vertices;\n\n\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n\n        if ((maxTop === null) || (maxTop.y > vertex.y) || ((maxTop.y === vertex.y) && (vertex.x < maxTop.x))) {\n            maxTop = vertex;\n        }\n        if ((maxBottom === null) || (maxBottom.y < vertex.y) || ((maxBottom.y === vertex.y) && (vertex.x > maxBottom.x))) {\n            maxBottom = vertex;\n        }\n        if ((maxLeft === null) || (maxLeft.x > vertex.x) || ((maxLeft.x === vertex.x) && (vertex.y > maxLeft.y))) {\n            maxLeft = vertex;\n            maxLeftIndex = i;\n        }\n        if ((maxRight === null) || (maxRight.x < vertex.x) || ((maxRight.x === vertex.x) && (vertex.y < maxRight.y))) {\n            maxRight = vertex;\n        }\n    }\n\n    if (maxLeftIndex > 0) {\n        newVertices = []\n        var j = 0;\n        for (var i = maxLeftIndex; i < vertices.length; i++) {\n            newVertices[j++] = vertices[i];\n        }\n        for (var i = 0; i < maxLeftIndex; i++) {\n            newVertices[j++] = vertices[i];\n        }\n        vertices = newVertices;\n    }\n\n\n    var reverse = false;\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n        if (equals(vertex, maxBottom)) {\n            reverse = true;\n            break;\n        } else if (equals(vertex, maxTop)) {\n            break;\n        }\n    }\n    if (reverse) {\n        newVertices = []\n        newVertices[0] = vertices[0];\n        var j = 1;\n        for (var i = vertices.length - 1; i > 0; i--) {\n            newVertices[j++] = vertices[i];\n        }\n        vertices = newVertices;\n    }\n\n    return (isArrayList ? (new gpcas.util.ArrayList(vertices)) : (vertices));\n}\n\n/////////////// END ArrayHelper  ////////////////////////////////////////////////\n\nvar ArrayHelper = gpcas.util.ArrayHelper;\n////////////////// CLASS ArrayList  /////////////////////////\n\ngpcas.util.ArrayList = function (arr) {\n    this._array = [];\n    if (arr != null) {\n        this._array = arr;\n    }\n\n};\nvar p = gpcas.util.ArrayList.prototype;\n\np.add = function (value) {\n    this._array.push(value);\n};\np.get = function (index) {\n    return this._array[index];\n};\np.size = function () {\n    return this._array.length;\n};\np.clear = function () {\n    this._array = [];\n\n};\np.equals = function (list) {\n    if (this._array.length != list.size()) return false;\n\n    for (var i = 0; i < this._array.length; i++) {\n        var obj1 = this._array[i];\n        var obj2 = list.get(i);\n\n        if (!ArrayHelper.valueEqual(obj1, obj2)) {\n            return false;\n        }\n    }\n    return true;\n}\np.hashCode = function () {\n    return 0;\n};\np.isEmpty = function () {\n    return (this._array.length == 0);\n}\np.toArray = function () {\n    return this._array;\n}\n///////////////// END ArrayList ////////////////////////\n\n\ngpcas.geometry.Clip = function () {\n};\ngpcas.geometry.Clip.DEBUG = false;\ngpcas.geometry.Clip.GPC_EPSILON = 2.2204460492503131e-016;\ngpcas.geometry.Clip.GPC_VERSION = \"2.31\";\ngpcas.geometry.Clip.LEFT = 0;\ngpcas.geometry.Clip.RIGHT = 1;\ngpcas.geometry.Clip.ABOVE = 0;\ngpcas.geometry.Clip.BELOW = 1;\ngpcas.geometry.Clip.CLIP = 0;\ngpcas.geometry.Clip.SUBJ = 1;\nClip = gpcas.geometry.Clip;\n\n\nvar p = gpcas.geometry.Clip.prototype;\nvar gpcstatic = gpcas.geometry.Clip;\n\n// ----------------------\n// --- gpcstatic Methods ---\n// ----------------------\n\n/**\n * Return the intersection of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he intersection with\n * @param p2        One of the polygons to performt he intersection with\n * @param polyClass The type of <code>Poly</code> to return\n */\n\ngpcstatic.intersection = function (p1, p2, polyClass) {\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, polyClass);\n};\n\n\n/**\n * Return the union of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he union with\n * @param p2        One of the polygons to performt he union with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.union = function (p1, p2, polyClass) {\n\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_UNION, p1, p2, polyClass);\n};\n\n\n/**\n * Return the xor of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he xor with\n * @param p2        One of the polygons to performt he xor with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.xor = function (p1, p2, polyClass) {\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_XOR, p1, p2, polyClass);\n};\n\n\n/**\n * Return the difference of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        Polygon from which second polygon will be substracted\n * @param p2        Second polygon\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.difference = function (p1, p2, polyClass) {\n    if (polyClass == null || polyClass == undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_DIFF, p2, p1, polyClass);\n}\ngpcstatic.intersection = function (p1, p2) {\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, \"PolyDefault.class\");\n}\n\n\n// -----------------------\n// --- Private Methods ---\n// -----------------------\n\n/**\n * Create a new <code>Poly</code> type object using <code>polyClass</code>.\n */\ngpcstatic.createNewPoly = function (polyClass) {\n    /* TODO :\n     try\n     {\n     return (Poly)polyClass.newInstance();\n     }\n     catch( var e:Exception)\n     {\n     throw new RuntimeException(e);\n     }*/\n    if (polyClass == \"PolySimple\") {\n        return new gpcas.geometry.PolySimple();\n    }\n    if (polyClass == \"PolyDefault\") {\n        return new gpcas.geometry.PolyDefault();\n    }\n    if (polyClass == \"PolyDefault.class\") {\n        return new gpcas.geometry.PolyDefault();\n    }\n\n    return null;\n}\n\n/**\n * <code>clip()</code> is the main method of the clipper algorithm.\n * This is where the conversion from really begins.\n */\ngpcstatic.clip = function (op, subj, clip, polyClass) {\n    var result = gpcas.geometry.Clip.createNewPoly(polyClass);\n\n    /* Test for trivial NULL result cases */\n    if ((subj.isEmpty() && clip.isEmpty()) ||\n        (subj.isEmpty() && ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF))) ||\n        (clip.isEmpty() && (op == gpcas.geometry.OperationType.GPC_INT))) {\n        return result;\n    }\n\n\n    /* Identify potentialy contributing contours */\n    if (((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF)) && !subj.isEmpty() && !clip.isEmpty()) {\n        gpcas.geometry.Clip.minimax_test(subj, clip, op);\n    }\n\n    //console.log(\"SUBJ \" + subj);\n    //console.log(\"CLIP \" + clip);\n\n\n    /* Build LMT */\n    var lmt_table = new gpcas.geometry.LmtTable();\n    var sbte = new gpcas.geometry.ScanBeamTreeEntries();\n    var s_heap = null;\n    var c_heap = null;\n\n\n    if (!subj.isEmpty()) {\n        s_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, subj, gpcas.geometry.Clip.SUBJ, op);\n    }\n    if (gpcas.geometry.Clip.DEBUG) {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for subj ---------\");\n        lmt_table.print();\n    }\n    if (!clip.isEmpty()) {\n        c_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, clip, gpcas.geometry.Clip.CLIP, op);\n    }\n    if (gpcas.geometry.Clip.DEBUG) {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for clip ---------\");\n        lmt_table.print();\n    }\n\n    /* Return a NULL result if no contours contribute */\n    if (lmt_table.top_node == null) {\n        return result;\n    }\n\n    /* Build scanbeam table from scanbeam tree */\n    var sbt = sbte.build_sbt();\n\n\n    var parity = [];\n    parity[0] = gpcas.geometry.Clip.LEFT;\n    parity[1] = gpcas.geometry.Clip.LEFT;\n\n    /* Invert clip polygon for difference operation */\n    if (op == gpcas.geometry.OperationType.GPC_DIFF) {\n        parity[Clip.CLIP] = gpcas.geometry.Clip.RIGHT;\n    }\n\n    if (gpcas.geometry.Clip.DEBUG) {\n        //console.log(sbt);\n    }\n\n    var local_min = lmt_table.top_node;\n\n    var out_poly = new TopPolygonNode(); // used to create resulting Poly\n\n    var aet = new AetTree();\n    var scanbeam = 0;\n\n\n    /* Process each scanbeam */\n    while (scanbeam < sbt.length) {\n        /* Set yb and yt to the bottom and top of the scanbeam */\n        var yb = sbt[scanbeam++];\n        var yt = 0.0;\n        var dy = 0.0;\n        if (scanbeam < sbt.length) {\n            yt = sbt[scanbeam];\n            dy = yt - yb;\n        }\n\n\n        /* === SCANBEAM BOUNDARY PROCESSING ================================ */\n\n        /* If LMT node corresponding to yb exists */\n        if (local_min != null) {\n            if (local_min.y == yb) {\n                /* Add edges starting at this local minimum to the AET */\n                for (var edge = local_min.first_bound; (edge != null); edge = edge.next_bound) {\n                    gpcas.geometry.Clip.add_edge_to_aet(aet, edge);\n                }\n\n                local_min = local_min.next;\n            }\n        }\n\n        if (gpcas.geometry.Clip.DEBUG) {\n            aet.print();\n        }\n        /* Set dummy previous x value */\n        var px = -Number.MAX_VALUE;\n\n        /* Create bundles within AET */\n        var e0 = aet.top_node;\n        var e1 = aet.top_node;\n\n\n        /* Set up bundle fields of first edge */\n        aet.top_node.bundle[Clip.ABOVE][aet.top_node.type] = (aet.top_node.top.y != yb) ? 1 : 0;\n        aet.top_node.bundle[Clip.ABOVE][((aet.top_node.type == 0) ? 1 : 0)] = 0;\n        aet.top_node.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n        for (var next_edge = aet.top_node.next; (next_edge != null); next_edge = next_edge.next) {\n            var ne_type = next_edge.type;\n            var ne_type_opp = ((next_edge.type == 0) ? 1 : 0); //next edge type opposite\n\n            /* Set up bundle fields of next edge */\n            next_edge.bundle[Clip.ABOVE][ne_type] = (next_edge.top.y != yb) ? 1 : 0;\n            next_edge.bundle[Clip.ABOVE][ne_type_opp] = 0;\n            next_edge.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n            /* Bundle edges above the scanbeam boundary if they coincide */\n            if (next_edge.bundle[Clip.ABOVE][ne_type] == 1) {\n                if (Clip.EQ(e0.xb, next_edge.xb) && gpcas.geometry.Clip.EQ(e0.dx, next_edge.dx) && (e0.top.y != yb)) {\n                    next_edge.bundle[Clip.ABOVE][ne_type] ^= e0.bundle[Clip.ABOVE][ne_type];\n                    next_edge.bundle[Clip.ABOVE][ne_type_opp] = e0.bundle[Clip.ABOVE][ne_type_opp];\n                    next_edge.bstate[Clip.ABOVE] = BundleState.BUNDLE_HEAD;\n                    e0.bundle[Clip.ABOVE][Clip.CLIP] = 0;\n                    e0.bundle[Clip.ABOVE][Clip.SUBJ] = 0;\n                    e0.bstate[Clip.ABOVE] = BundleState.BUNDLE_TAIL;\n                }\n                e0 = next_edge;\n\n            }\n        }\n\n        var horiz = [];\n        horiz[Clip.CLIP] = HState.NH;\n        horiz[Clip.SUBJ] = HState.NH;\n\n        var exists = [];\n        exists[Clip.CLIP] = 0;\n        exists[Clip.SUBJ] = 0;\n\n        var cf = null;\n\n        /* Process each edge at this scanbeam boundary */\n        for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n            exists[Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP] + (edge.bundle[Clip.BELOW][Clip.CLIP] << 1);\n            exists[Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ] + (edge.bundle[Clip.BELOW][Clip.SUBJ] << 1);\n\n            if ((exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0)) {\n                /* Set bundle side */\n                edge.bside[Clip.CLIP] = parity[Clip.CLIP];\n                edge.bside[Clip.SUBJ] = parity[Clip.SUBJ];\n\n                var contributing = false;\n                var br = 0;\n                var bl = 0;\n                var tr = 0;\n                var tl = 0;\n                /* Determine contributing status and quadrant occupancies */\n                if ((op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT)) {\n                    contributing = ((exists[Clip.CLIP] != 0) && ((parity[Clip.SUBJ] != 0) || (horiz[Clip.SUBJ] != 0))) ||\n                    ((exists[Clip.SUBJ] != 0) && ((parity[Clip.CLIP] != 0) || (horiz[Clip.CLIP] != 0))) ||\n                    ((exists[Clip.CLIP] != 0) && (exists[Clip.SUBJ] != 0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP] != 0) && (parity[Clip.SUBJ] != 0)) ? 1 : 0;\n                    bl = ( ((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) != 0) &&\n                    ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]) != 0) ) ? 1 : 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0)) != 0) &&\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0)) != 0) ) ? 1 : 0;\n                    tl = (((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.CLIP]) != 0) &&\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]) != 0)) ? 1 : 0;\n                }\n                else if (op == gpcas.geometry.OperationType.GPC_XOR) {\n                    contributing = (exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0);\n                    br = (parity[Clip.CLIP]) ^ (parity[Clip.SUBJ]);\n                    bl = (parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) ^ (parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    tr = (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0)) ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0));\n                    tl = (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])\n                    ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]);\n                }\n                else if (op == gpcas.geometry.OperationType.GPC_UNION) {\n                    contributing = ((exists[Clip.CLIP] != 0) && (!(parity[Clip.SUBJ] != 0) || (horiz[Clip.SUBJ] != 0))) ||\n                    ((exists[Clip.SUBJ] != 0) && (!(parity[Clip.CLIP] != 0) || (horiz[Clip.CLIP] != 0))) ||\n                    ((exists[Clip.CLIP] != 0) && (exists[Clip.SUBJ] != 0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP] != 0) || (parity[Clip.SUBJ] != 0)) ? 1 : 0;\n                    bl = (((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) != 0) || ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0)) != 0) ||\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0)) != 0) ) ? 1 : 0;\n                    tl = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.CLIP]) != 0) ||\n                    ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ] != HState.NH) ? 1 : 0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]) != 0) ) ? 1 : 0;\n                }\n                else {\n                    //console.log(\"ERROR : Unknown op\");\n                }\n\n                /* Update parity */\n                parity[Clip.CLIP] ^= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                parity[Clip.SUBJ] ^= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n\n                /* Update horizontal state */\n                if (exists[Clip.CLIP] != 0) {\n                    horiz[Clip.CLIP] = HState.next_h_state[horiz[Clip.CLIP]][((exists[Clip.CLIP] - 1) << 1) + parity[Clip.CLIP]];\n                }\n                if (exists[Clip.SUBJ] != 0) {\n                    horiz[Clip.SUBJ] = HState.next_h_state[horiz[Clip.SUBJ]][((exists[Clip.SUBJ] - 1) << 1) + parity[Clip.SUBJ]];\n                }\n\n                if (contributing) {\n                    var xb = edge.xb;\n\n\n                    var vclass = VertexType.getType(tr, tl, br, bl);\n                    switch (vclass) {\n                        case VertexType.EMN:\n                        case VertexType.IMN:\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (xb != px) {\n                                cf.add_right(xb, yb);\n                                px = xb;\n                            }\n                            edge.outp[Clip.ABOVE] = cf;\n                            cf = null;\n                            break;\n                        case VertexType.ELI:\n                            edge.outp[Clip.BELOW].add_left(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.BELOW];\n                            break;\n                        case VertexType.EMX:\n                            if (xb != px) {\n                                cf.add_left(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            cf = null;\n                            break;\n                        case VertexType.ILI:\n                            if (xb != px) {\n                                cf.add_left(xb, yb);\n                                px = xb;\n                            }\n                            edge.outp[Clip.ABOVE] = cf;\n                            cf = null;\n                            break;\n                        case VertexType.IRI:\n                            edge.outp[Clip.BELOW].add_right(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.BELOW];\n                            edge.outp[Clip.BELOW] = null;\n                            break;\n                        case VertexType.IMX:\n                            if (xb != px) {\n                                cf.add_right(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            cf = null;\n                            edge.outp[Clip.BELOW] = null;\n                            break;\n                        case VertexType.IMM:\n                            if (xb != px) {\n                                cf.add_right(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW] = null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.EMM:\n                            if (xb != px) {\n                                cf.add_left(xb, yb);\n                                px = xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW] = null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.LED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_left(xb, yb);\n                            edge.outp[Clip.ABOVE] = edge.outp[Clip.BELOW];\n                            px = xb;\n                            break;\n                        case VertexType.RED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_right(xb, yb);\n                            edge.outp[Clip.ABOVE] = edge.outp[Clip.BELOW];\n                            px = xb;\n                            break;\n                        default:\n                            break;\n                    }\n                    /* End of switch */\n                }\n                /* End of contributing conditional */\n            }\n            /* End of edge exists conditional */\n            if (gpcas.geometry.Clip.DEBUG) {\n                out_poly.print();\n            }\n            out_poly.print();\n        }\n        /* End of AET loop */\n\n\n        /* Delete terminating edges from the AET, otherwise compute xt */\n        for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n            if (edge.top.y == yb) {\n                var prev_edge = edge.prev;\n                var next_edge = edge.next;\n\n                if (prev_edge != null)\n                    prev_edge.next = next_edge;\n                else\n                    aet.top_node = next_edge;\n\n                if (next_edge != null)\n                    next_edge.prev = prev_edge;\n\n                /* Copy bundle head state to the adjacent tail edge if required */\n                if ((edge.bstate[Clip.BELOW] == BundleState.BUNDLE_HEAD) && (prev_edge != null)) {\n                    if (prev_edge.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL) {\n                        prev_edge.outp[Clip.BELOW] = edge.outp[Clip.BELOW];\n                        prev_edge.bstate[Clip.BELOW] = BundleState.UNBUNDLED;\n                        if (prev_edge.prev != null) {\n                            if (prev_edge.prev.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL) {\n                                prev_edge.bstate[Clip.BELOW] = BundleState.BUNDLE_HEAD;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                if (edge.top.y == yt)\n                    edge.xt = edge.top.x;\n                else\n                    edge.xt = edge.bot.x + edge.dx * (yt - edge.bot.y);\n            }\n        }\n\n        if (scanbeam < sbte.sbt_entries) {\n            /* === SCANBEAM INTERIOR PROCESSING ============================== */\n\n            /* Build intersection table for the current scanbeam */\n            var it_table = new ItNodeTable();\n            it_table.build_intersection_table(aet, dy);\n\n\n            /* Process each node in the intersection table */\n\n            for (var intersect = it_table.top_node; (intersect != null); intersect = intersect.next) {\n\n\n                e0 = intersect.ie[0];\n                e1 = intersect.ie[1];\n\n                /* Only generate output for contributing intersections */\n\n                if (((e0.bundle[Clip.ABOVE][Clip.CLIP] != 0) || (e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0)) &&\n                    ((e1.bundle[Clip.ABOVE][Clip.CLIP] != 0) || (e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0))) {\n                    var p = e0.outp[Clip.ABOVE];\n                    var q = e1.outp[Clip.ABOVE];\n                    var ix = intersect.point.x;\n                    var iy = intersect.point.y + yb;\n\n                    var in_clip = ( ( (e0.bundle[Clip.ABOVE][Clip.CLIP] != 0) && !(e0.bside[Clip.CLIP] != 0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.CLIP] != 0) && (e1.bside[Clip.CLIP] != 0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.CLIP] != 0) && !(e1.bundle[Clip.ABOVE][Clip.CLIP] != 0) &&\n                    (e0.bside[Clip.CLIP] != 0) && (e1.bside[Clip.CLIP] != 0) ) ) ? 1 : 0;\n\n                    var in_subj = ( ( (e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0) && !(e0.bside[Clip.SUBJ] != 0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0) && (e1.bside[Clip.SUBJ] != 0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0) && !(e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0) &&\n                    (e0.bside[Clip.SUBJ] != 0) && (e1.bside[Clip.SUBJ] != 0) ) ) ? 1 : 0;\n\n                    var tr = 0\n                    var tl = 0;\n                    var br = 0;\n                    var bl = 0;\n                    /* Determine quadrant occupancies */\n                    if ((op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT)) {\n                        tr = ((in_clip != 0) && (in_subj != 0)) ? 1 : 0;\n                        tl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) != 0) && ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        br = (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) && ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        bl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) &&\n                        ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0) ) ? 1 : 0;\n                    }\n                    else if (op == gpcas.geometry.OperationType.GPC_XOR) {\n                        tr = in_clip ^ in_subj;\n                        tl = (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        br = (in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        bl = (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])\n                        ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    }\n                    else if (op == gpcas.geometry.OperationType.GPC_UNION) {\n                        tr = ((in_clip != 0) || (in_subj != 0)) ? 1 : 0;\n                        tl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) != 0) || ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        br = (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) || ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                        bl = (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) != 0) ||\n                        ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]) != 0)) ? 1 : 0;\n                    }\n                    else {\n                        //console.log(\"ERROR : Unknown op type, \"+op);\n                    }\n\n                    var vclass = VertexType.getType(tr, tl, br, bl);\n                    switch (vclass) {\n                        case VertexType.EMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (p != null) {\n                                p.add_right(ix, iy);\n                                e1.outp[Clip.ABOVE] = p;\n                                e0.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.ELI:\n                            if (q != null) {\n                                q.add_left(ix, iy);\n                                e0.outp[Clip.ABOVE] = q;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.EMX:\n                            if ((p != null) && (q != null)) {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = null;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ILI:\n                            if (p != null) {\n                                p.add_left(ix, iy);\n                                e1.outp[Clip.ABOVE] = p;\n                                e0.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IRI:\n                            if (q != null) {\n                                q.add_right(ix, iy);\n                                e0.outp[Clip.ABOVE] = q;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IMX:\n                            if ((p != null) && (q != null)) {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = null;\n                                e1.outp[Clip.ABOVE] = null;\n                            }\n                            break;\n                        case VertexType.IMM:\n                            if ((p != null) && (q != null)) {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        case VertexType.EMM:\n                            if ((p != null) && (q != null)) {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                    /* End of switch */\n                }\n                /* End of contributing intersection conditional */\n\n                /* Swap bundle sides in response to edge crossing */\n                if (e0.bundle[Clip.ABOVE][Clip.CLIP] != 0)\n                    e1.bside[Clip.CLIP] = (e1.bside[Clip.CLIP] == 0) ? 1 : 0;\n                if (e1.bundle[Clip.ABOVE][Clip.CLIP] != 0)\n                    e0.bside[Clip.CLIP] = (e0.bside[Clip.CLIP] == 0) ? 1 : 0;\n                if (e0.bundle[Clip.ABOVE][Clip.SUBJ] != 0)\n                    e1.bside[Clip.SUBJ] = (e1.bside[Clip.SUBJ] == 0) ? 1 : 0;\n                if (e1.bundle[Clip.ABOVE][Clip.SUBJ] != 0)\n                    e0.bside[Clip.SUBJ] = (e0.bside[Clip.SUBJ] == 0) ? 1 : 0;\n\n                /* Swap e0 and e1 bundles in the AET */\n                var prev_edge = e0.prev;\n                var next_edge = e1.next;\n                if (next_edge != null) {\n                    next_edge.prev = e0;\n                }\n\n                if (e0.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) {\n                    var search = true;\n                    while (search) {\n                        prev_edge = prev_edge.prev;\n                        if (prev_edge != null) {\n                            if (prev_edge.bstate[Clip.ABOVE] != BundleState.BUNDLE_TAIL) {\n                                search = false;\n                            }\n                        }\n                        else {\n                            search = false;\n                        }\n                    }\n                }\n                if (prev_edge == null) {\n                    aet.top_node.prev = e1;\n                    e1.next = aet.top_node;\n                    aet.top_node = e0.next;\n                }\n                else {\n                    prev_edge.next.prev = e1;\n                    e1.next = prev_edge.next;\n                    prev_edge.next = e0.next;\n                }\n                e0.next.prev = prev_edge;\n                e1.next.prev = e1;\n                e0.next = next_edge;\n                if (gpcas.geometry.Clip.DEBUG) {\n                    out_poly.print();\n                }\n            }\n            /* End of IT loop*/\n\n            /* Prepare for next scanbeam */\n            for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n                var next_edge = edge.next;\n                var succ_edge = edge.succ;\n                if ((edge.top.y == yt) && (succ_edge != null)) {\n                    /* Replace AET edge by its successor */\n                    succ_edge.outp[Clip.BELOW] = edge.outp[Clip.ABOVE];\n                    succ_edge.bstate[Clip.BELOW] = edge.bstate[Clip.ABOVE];\n                    succ_edge.bundle[Clip.BELOW][Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    succ_edge.bundle[Clip.BELOW][Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    var prev_edge = edge.prev;\n                    if (prev_edge != null)\n                        prev_edge.next = succ_edge;\n                    else\n                        aet.top_node = succ_edge;\n                    if (next_edge != null)\n                        next_edge.prev = succ_edge;\n                    succ_edge.prev = prev_edge;\n                    succ_edge.next = next_edge;\n                }\n                else {\n                    /* Update this edge */\n                    edge.outp[Clip.BELOW] = edge.outp[Clip.ABOVE];\n                    edge.bstate[Clip.BELOW] = edge.bstate[Clip.ABOVE];\n                    edge.bundle[Clip.BELOW][Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    edge.bundle[Clip.BELOW][Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    edge.xb = edge.xt;\n                }\n                edge.outp[Clip.ABOVE] = null;\n            }\n        }\n    }\n    /* === END OF SCANBEAM PROCESSING ================================== */\n\n    /* Generate result polygon from out_poly */\n    result = out_poly.getResult(polyClass);\n    //console.log(\"result = \"+result);\n\n    return result;\n}\n\ngpcstatic.EQ = function (a, b) {\n    return (Math.abs(a - b) <= gpcas.geometry.Clip.GPC_EPSILON);\n}\n\ngpcstatic.PREV_INDEX = function (i, n) {\n    return ((i - 1 + n) % n);\n}\n\ngpcstatic.NEXT_INDEX = function (i, n) {\n    return ((i + 1) % n);\n}\n\ngpcstatic.OPTIMAL = function (p, i) {\n    return (p.getY(gpcas.geometry.Clip.PREV_INDEX(i, p.getNumPoints())) != p.getY(i)) ||\n    (p.getY(gpcas.geometry.Clip.NEXT_INDEX(i, p.getNumPoints())) != p.getY(i));\n}\n\ngpcstatic.create_contour_bboxes = function (p) {\n    var box = [];\n\n    /* Construct contour bounding boxes */\n    for (var c = 0; c < p.getNumInnerPoly(); c++) {\n        var inner_poly = p.getInnerPoly(c);\n        box[c] = inner_poly.getBounds();\n    }\n    return box;\n}\n\ngpcstatic.minimax_test = function (subj, clip, op) {\n    var s_bbox = gpcas.geometry.Clip.create_contour_bboxes(subj);\n    var c_bbox = gpcas.geometry.Clip.create_contour_bboxes(clip);\n\n    var subj_num_poly = subj.getNumInnerPoly();\n    var clip_num_poly = clip.getNumInnerPoly();\n    var o_table = ArrayHelper.create2DArray(subj_num_poly, clip_num_poly);\n\n    /* Check all subject contour bounding boxes against clip boxes */\n    for (var s = 0; s < subj_num_poly; s++) {\n        for (var c = 0; c < clip_num_poly; c++) {\n            o_table[s][c] =\n                (!((s_bbox[s].getMaxX() < c_bbox[c].getMinX()) ||\n                (s_bbox[s].getMinX() > c_bbox[c].getMaxX()))) &&\n                (!((s_bbox[s].getMaxY() < c_bbox[c].getMinY()) ||\n                (s_bbox[s].getMinY() > c_bbox[c].getMaxY())));\n        }\n    }\n\n    /* For each clip contour, search for any subject contour overlaps */\n    for (var c = 0; c < clip_num_poly; c++) {\n        var overlap = false;\n        for (var s = 0; !overlap && (s < subj_num_poly); s++) {\n            overlap = o_table[s][c];\n        }\n        if (!overlap) {\n            clip.setContributing(c, false); // Flag non contributing status\n        }\n    }\n\n    if (op == gpcas.geometry.OperationType.GPC_INT) {\n        /* For each subject contour, search for any clip contour overlaps */\n        for (var s = 0; s < subj_num_poly; s++) {\n            var overlap = false;\n            for (var c = 0; !overlap && (c < clip_num_poly); c++) {\n                overlap = o_table[s][c];\n            }\n            if (!overlap) {\n                subj.setContributing(s, false); // Flag non contributing status\n            }\n        }\n    }\n}\n\ngpcstatic.bound_list = function (lmt_table, y) {\n    if (lmt_table.top_node == null) {\n        lmt_table.top_node = new LmtNode(y);\n        return lmt_table.top_node;\n    }\n    else {\n        var prev = null;\n        var node = lmt_table.top_node;\n        var done = false;\n        while (!done) {\n            if (y < node.y) {\n                /* Insert a new LMT node before the current node */\n                var existing_node = node;\n                node = new LmtNode(y);\n                node.next = existing_node;\n                if (prev == null) {\n                    lmt_table.top_node = node;\n                }\n                else {\n                    prev.next = node;\n                }\n                //               if( existing_node == lmt_table.top_node )\n                //               {\n                //                  lmt_table.top_node = node ;\n                //               }\n                done = true;\n            }\n            else if (y > node.y) {\n                /* Head further up the LMT */\n                if (node.next == null) {\n                    node.next = new LmtNode(y);\n                    node = node.next;\n                    done = true;\n                }\n                else {\n                    prev = node;\n                    node = node.next;\n                }\n            }\n            else {\n                /* Use this existing LMT node */\n                done = true;\n            }\n        }\n        return node;\n    }\n}\n\ngpcstatic.insert_bound = function (lmt_node, e) {\n    if (lmt_node.first_bound == null) {\n        /* Link node e to the tail of the list */\n        lmt_node.first_bound = e;\n    }\n    else {\n        var done = false;\n        var prev_bound = null;\n        var current_bound = lmt_node.first_bound;\n        while (!done) {\n            /* Do primary sort on the x field */\n            if (e.bot.x < current_bound.bot.x) {\n                /* Insert a new node mid-list */\n                if (prev_bound == null) {\n                    lmt_node.first_bound = e;\n                }\n                else {\n                    prev_bound.next_bound = e;\n                }\n                e.next_bound = current_bound;\n\n                //               EdgeNode existing_bound = current_bound ;\n                //               current_bound = e ;\n                //               current_bound.next_bound = existing_bound ;\n                //               if( lmt_node.first_bound == existing_bound )\n                //               {\n                //                  lmt_node.first_bound = current_bound ;\n                //               }\n                done = true;\n            }\n            else if (e.bot.x == current_bound.bot.x) {\n                /* Do secondary sort on the dx field */\n                if (e.dx < current_bound.dx) {\n                    /* Insert a new node mid-list */\n                    if (prev_bound == null) {\n                        lmt_node.first_bound = e;\n                    }\n                    else {\n                        prev_bound.next_bound = e;\n                    }\n                    e.next_bound = current_bound;\n                    //                  EdgeNode existing_bound = current_bound ;\n                    //                  current_bound = e ;\n                    //                  current_bound.next_bound = existing_bound ;\n                    //                  if( lmt_node.first_bound == existing_bound )\n                    //                  {\n                    //                     lmt_node.first_bound = current_bound ;\n                    //                  }\n                    done = true;\n                }\n                else {\n                    /* Head further down the list */\n                    if (current_bound.next_bound == null) {\n                        current_bound.next_bound = e;\n                        done = true;\n                    }\n                    else {\n                        prev_bound = current_bound;\n                        current_bound = current_bound.next_bound;\n                    }\n                }\n            }\n            else {\n                /* Head further down the list */\n                if (current_bound.next_bound == null) {\n                    current_bound.next_bound = e;\n                    done = true;\n                }\n                else {\n                    prev_bound = current_bound;\n                    current_bound = current_bound.next_bound;\n                }\n            }\n        }\n    }\n}\n\ngpcstatic.add_edge_to_aet = function (aet, edge) {\n    if (aet.top_node == null) {\n        /* Append edge onto the tail end of the AET */\n        aet.top_node = edge;\n        edge.prev = null;\n        edge.next = null;\n    }\n    else {\n        var current_edge = aet.top_node;\n        var prev = null;\n        var done = false;\n        while (!done) {\n            /* Do primary sort on the xb field */\n            if (edge.xb < current_edge.xb) {\n                /* Insert edge here (before the AET edge) */\n                edge.prev = prev;\n                edge.next = current_edge;\n                current_edge.prev = edge;\n                if (prev == null) {\n                    aet.top_node = edge;\n                }\n                else {\n                    prev.next = edge;\n                }\n                //               if( current_edge == aet.top_node )\n                //               {\n                //                  aet.top_node = edge ;\n                //               }\n                //               current_edge = edge ;\n                done = true;\n            }\n            else if (edge.xb == current_edge.xb) {\n                /* Do secondary sort on the dx field */\n                if (edge.dx < current_edge.dx) {\n                    /* Insert edge here (before the AET edge) */\n                    edge.prev = prev;\n                    edge.next = current_edge;\n                    current_edge.prev = edge;\n                    if (prev == null) {\n                        aet.top_node = edge;\n                    }\n                    else {\n                        prev.next = edge;\n                    }\n                    //                  if( current_edge == aet.top_node )\n                    //                  {\n                    //                     aet.top_node = edge ;\n                    //                  }\n                    //                  current_edge = edge ;\n                    done = true;\n                }\n                else {\n                    /* Head further into the AET */\n                    prev = current_edge;\n                    if (current_edge.next == null) {\n                        current_edge.next = edge;\n                        edge.prev = current_edge;\n                        edge.next = null;\n                        done = true;\n                    }\n                    else {\n                        current_edge = current_edge.next;\n                    }\n                }\n            }\n            else {\n                /* Head further into the AET */\n                prev = current_edge;\n                if (current_edge.next == null) {\n                    current_edge.next = edge;\n                    edge.prev = current_edge;\n                    edge.next = null;\n                    done = true;\n                }\n                else {\n                    current_edge = current_edge.next;\n                }\n            }\n        }\n    }\n}\n\ngpcstatic.add_to_sbtree = function (sbte, y) {\n    if (sbte.sb_tree == null) {\n        /* Add a new tree node here */\n        sbte.sb_tree = new gpcas.geometry.ScanBeamTree(y);\n        sbte.sbt_entries++;\n        return;\n    }\n    var tree_node = sbte.sb_tree;\n    var done = false;\n    while (!done) {\n        if (tree_node.y > y) {\n            if (tree_node.less == null) {\n                tree_node.less = new gpcas.geometry.ScanBeamTree(y);\n                sbte.sbt_entries++;\n                done = true;\n            }\n            else {\n                tree_node = tree_node.less;\n            }\n        }\n        else if (tree_node.y < y) {\n            if (tree_node.more == null) {\n                tree_node.more = new gpcas.geometry.ScanBeamTree(y);\n                sbte.sbt_entries++;\n                done = true;\n            }\n            else {\n                tree_node = tree_node.more;\n            }\n        }\n        else {\n            done = true;\n        }\n    }\n}\n\n\ngpcstatic.build_lmt = function (lmt_table,\n                                sbte,\n                                p,\n                                type, //poly type SUBJ/Clip.CLIP\n                                op) {\n    /* Create the entire input polygon edge table in one go */\n    var edge_table = new gpcas.geometry.EdgeTable();\n\n    for (var c = 0; c < p.getNumInnerPoly(); c++) {\n        var ip = p.getInnerPoly(c);\n        if (!ip.isContributing(0)) {\n            /* Ignore the non-contributing contour */\n            ip.setContributing(0, true);\n        }\n        else {\n\n\n            /* Perform contour optimisation */\n            var num_vertices = 0;\n            var e_index = 0;\n            edge_table = new gpcas.geometry.EdgeTable();\n            for (var i = 0; i < ip.getNumPoints(); i++) {\n                if (gpcas.geometry.Clip.OPTIMAL(ip, i)) {\n                    var x = ip.getX(i);\n                    var y = ip.getY(i);\n                    edge_table.addNode(x, y);\n\n                    /* Record vertex in the scanbeam table */\n                    gpcas.geometry.Clip.add_to_sbtree(sbte, ip.getY(i));\n\n                    num_vertices++;\n                }\n            }\n\n            /* Do the contour forward pass */\n\n            for (var min = 0; min < num_vertices; min++) {\n                /* If a forward local minimum... */\n                if (edge_table.FWD_MIN(min)) {\n                    /* Search for the next local maximum... */\n                    var num_edges = 1;\n                    var max = gpcas.geometry.Clip.NEXT_INDEX(min, num_vertices);\n                    while (edge_table.NOT_FMAX(max)) {\n                        num_edges++;\n                        max = gpcas.geometry.Clip.NEXT_INDEX(max, num_vertices);\n                    }\n\n                    /* Build the next edge list */\n                    var v = min;\n                    var e = edge_table.getNode(e_index);\n                    e.bstate[gpcas.geometry.Clip.BELOW] = gpcas.geometry.BundleState.UNBUNDLED;\n                    e.bundle[gpcas.geometry.Clip.BELOW][Clip.CLIP] = 0;\n                    e.bundle[gpcas.geometry.Clip.BELOW][Clip.SUBJ] = 0;\n\n                    for (var i = 0; i < num_edges; i++) {\n                        var ei = edge_table.getNode(e_index + i);\n                        var ev = edge_table.getNode(v);\n\n                        ei.xb = ev.vertex.x;\n                        ei.bot.x = ev.vertex.x;\n                        ei.bot.y = ev.vertex.y;\n\n                        v = gpcas.geometry.Clip.NEXT_INDEX(v, num_vertices);\n                        ev = edge_table.getNode(v);\n\n                        ei.top.x = ev.vertex.x;\n                        ei.top.y = ev.vertex.y;\n                        ei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n                        ei.type = type;\n                        ei.outp[gpcas.geometry.Clip.ABOVE] = null;\n                        ei.outp[gpcas.geometry.Clip.BELOW] = null;\n                        ei.next = null;\n                        ei.prev = null;\n                        ei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index + i + 1) : null;\n                        ei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index + i - 1) : null;\n                        ei.next_bound = null;\n                        ei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n                        ei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n                    }\n                    Clip.insert_bound(gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n                    if (gpcas.geometry.Clip.DEBUG) {\n                        //console.log(\"fwd\");\n                        lmt_table.print();\n                    }\n                    e_index += num_edges;\n                }\n            }\n\n            /* Do the contour reverse pass */\n            for (var min = 0; min < num_vertices; min++) {\n                /* If a reverse local minimum... */\n                if (edge_table.REV_MIN(min)) {\n                    /* Search for the previous local maximum... */\n                    var num_edges = 1;\n                    var max = gpcas.geometry.Clip.PREV_INDEX(min, num_vertices);\n                    while (edge_table.NOT_RMAX(max)) {\n                        num_edges++;\n                        max = gpcas.geometry.Clip.PREV_INDEX(max, num_vertices);\n                    }\n\n                    /* Build the previous edge list */\n                    var v = min;\n                    var e = edge_table.getNode(e_index);\n                    e.bstate[gpcas.geometry.Clip.BELOW] = BundleState.UNBUNDLED;\n                    e.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.CLIP] = 0;\n                    e.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.SUBJ] = 0;\n\n                    for (var i = 0; i < num_edges; i++) {\n                        var ei = edge_table.getNode(e_index + i);\n                        var ev = edge_table.getNode(v);\n\n                        ei.xb = ev.vertex.x;\n                        ei.bot.x = ev.vertex.x;\n                        ei.bot.y = ev.vertex.y;\n\n                        v = gpcas.geometry.Clip.PREV_INDEX(v, num_vertices);\n                        ev = edge_table.getNode(v);\n\n                        ei.top.x = ev.vertex.x;\n                        ei.top.y = ev.vertex.y;\n                        ei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n                        ei.type = type;\n                        ei.outp[gpcas.geometry.Clip.ABOVE] = null;\n                        ei.outp[gpcas.geometry.Clip.BELOW] = null;\n                        ei.next = null;\n                        ei.prev = null;\n                        ei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index + i + 1) : null;\n                        ei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index + i - 1) : null;\n                        ei.next_bound = null;\n                        ei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n                        ei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n                    }\n                    Clip.insert_bound(gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n                    if (gpcas.geometry.Clip.DEBUG) {\n                        //console.log(\"rev\");\n                        lmt_table.print();\n                    }\n                    e_index += num_edges;\n                }\n            }\n        }\n    }\n    return edge_table;\n}\n\n\ngpcstatic.add_st_edge = function (st, it, edge, dy) {\n    if (st == null) {\n        /* Append edge onto the tail end of the ST */\n        st = new gpcas.geometry.StNode(edge, null);\n    }\n    else {\n        var den = (st.xt - st.xb) - (edge.xt - edge.xb);\n\n        /* If new edge and ST edge don't cross */\n        if ((edge.xt >= st.xt) || (edge.dx == st.dx) || (Math.abs(den) <= gpcas.geometry.Clip.GPC_EPSILON)) {\n            /* No intersection - insert edge here (before the ST edge) */\n            var existing_node = st;\n            st = new StNode(edge, existing_node);\n        }\n        else {\n            /* Compute intersection between new edge and ST edge */\n            var r = (edge.xb - st.xb) / den;\n            var x = st.xb + r * (st.xt - st.xb);\n            var y = r * dy;\n\n            /* Insert the edge pointers and the intersection point in the IT */\n            it.top_node = gpcas.geometry.Clip.add_intersection(it.top_node, st.edge, edge, x, y);\n\n            /* Head further into the ST */\n            st.prev = gpcas.geometry.Clip.add_st_edge(st.prev, it, edge, dy);\n        }\n    }\n    return st;\n}\n\n\ngpcstatic.add_intersection = function (it_node,\n                                       edge0,\n                                       edge1,\n                                       x,\n                                       y) {\n    if (it_node == null) {\n        /* Append a new node to the tail of the list */\n        it_node = new gpcas.geometry.ItNode(edge0, edge1, x, y, null);\n    }\n    else {\n        if (it_node.point.y > y) {\n            /* Insert a new node mid-list */\n            var existing_node = it_node;\n            it_node = new gpcas.geometry.ItNode(edge0, edge1, x, y, existing_node);\n        }\n        else {\n            /* Head further down the list */\n            it_node.next = gpcas.geometry.Clip.add_intersection(it_node.next, edge0, edge1, x, y);\n        }\n    }\n    return it_node;\n}\n\n\n/////////// AetTree ////////////////////////////////////\ngpcas.geometry.AetTree = function () {\n    this.top_node = null; //EdgeNode\n};\nAetTree = gpcas.geometry.AetTree;\ngpcas.geometry.AetTree.prototype.print = function () {\n    //console.log(\"aet\");\n    for (var edge = this.top_node; (edge != null); edge = edge.next) {\n        //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n    }\n}\n\n\n///////////////  BundleState  //////////////////////////////\ngpcas.geometry.BundleState = function (state) {\n    this.m_State = state; //String\n};\ngpcas.geometry.BundleState.UNBUNDLED = new gpcas.geometry.BundleState(\"UNBUNDLED\");\ngpcas.geometry.BundleState.BUNDLE_HEAD = new gpcas.geometry.BundleState(\"BUNDLE_HEAD\");\ngpcas.geometry.BundleState.BUNDLE_TAIL = new gpcas.geometry.BundleState(\"BUNDLE_TAIL\");\ngpcas.geometry.BundleState.prototype.toString = function () {\n    return this.m_State;\n};\nBundleState = gpcas.geometry.BundleState;\n\n/////////////// EdgeNode ////////////////////////////\ngpcas.geometry.EdgeNode = function () {\n    this.vertex = new Point();\n    /* Piggy-backed contour vertex data  */\n    this.bot = new Point();\n    /* Edge lower (x, y) coordinate      */\n    this.top = new Point();\n    /* Edge upper (x, y) coordinate      */\n    this.xb;\n    /* Scanbeam bottom x coordinate      */\n    this.xt;\n    /* Scanbeam top x coordinate         */\n    this.dx;\n    /* Change in x for a unit y increase */\n    this.type;\n    /* Clip / subject edge flag          */\n    this.bundle = ArrayHelper.create2DArray(2, 2);\n    /* Bundle edge flags                 */\n    this.bside = [];\n    /* Bundle left / right indicators    */\n    this.bstate = [];\n    /* Edge bundle state                 */\n    this.outp = [];\n    /* Output polygon / tristrip pointer */\n    this.prev;\n    /* Previous edge in the AET          */\n    this.next;\n    /* Next edge in the AET              */\n    this.pred;\n    /* Edge connected at the lower end   */\n    this.succ;\n    /* Edge connected at the upper end   */\n    this.next_bound;\n    /* Pointer to next bound in LMT      */\n};\n\n\n////////////////   EdgeTable /////////////////////////////////////////\n\n\ngpcas.geometry.EdgeTable = function () {\n    this.m_List = new gpcas.util.ArrayList();\n};\ngpcas.geometry.EdgeTable.prototype.addNode = function (x, y) {\n    var node = new gpcas.geometry.EdgeNode();\n    node.vertex.x = x;\n    node.vertex.y = y;\n    this.m_List.add(node);\n\n}\ngpcas.geometry.EdgeTable.prototype.getNode = function (index) {\n    return this.m_List.get(index);\n}\ngpcas.geometry.EdgeTable.prototype.FWD_MIN = function (i) {\n    var m_List = this.m_List;\n\n    var prev = (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next = (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n\n    return ((prev.vertex.y >= ith.vertex.y) &&\n    (next.vertex.y > ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_FMAX = function (i) {\n    var m_List = this.m_List;\n\n    var next = (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n    return (next.vertex.y > ith.vertex.y);\n}\ngpcas.geometry.EdgeTable.prototype.REV_MIN = function (i) {\n    var m_List = this.m_List;\n\n    var prev = (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next = (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n    return ((prev.vertex.y > ith.vertex.y) && (next.vertex.y >= ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_RMAX = function (i) {\n    var m_List = this.m_List;\n\n    var prev = (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var ith = (m_List.get(i));\n    return (prev.vertex.y > ith.vertex.y);\n}\n\n\n/////////////////////   HState   //////////////////////////////////////\ngpcas.geometry.HState = function () {\n};\ngpcas.geometry.HState.NH = 0;\n/* No horizontal edge                */\ngpcas.geometry.HState.BH = 1;\n/* Bottom horizontal edge            */\ngpcas.geometry.HState.TH = 2;\n/* Top horizontal edge               */\n\nHState = gpcas.geometry.HState;\n\nvar NH = gpcas.geometry.HState.NH;\nvar BH = gpcas.geometry.HState.BH;\nvar TH = gpcas.geometry.HState.TH;\n\n/* Horizontal edge state transitions within scanbeam boundary */\ngpcas.geometry.HState.next_h_state =\n    [\n        /*        ABOVE     BELOW     CROSS */\n        /*        L   R     L   R     L   R */\n        /* NH */ [BH, TH, TH, BH, NH, NH],\n        /* BH */ [NH, NH, NH, NH, TH, TH],\n        /* TH */ [NH, NH, NH, NH, BH, BH]\n    ];\n\n\n///////////////////////    \t  IntersectionPoint /////////////////////////////\ngpcas.geometry.IntersectionPoint = function (p1, p2, p3) {\n    this.polygonPoint1 = p1;\n    /* of Point */\n    ;\n    this.polygonPoint2 = p2;\n    /* of Point */\n    ;\n    this.intersectionPoint = p3;\n};\ngpcas.geometry.IntersectionPoint.prototype.toString = function () {\n    return \"P1 :\" + polygonPoint1.toString() + \" P2:\" + polygonPoint2.toString() + \" IP:\" + intersectionPoint.toString();\n}\n\n\n///////////////////////////    ItNode   ///////////////\ngpcas.geometry.ItNode = function (edge0, edge1, x, y, next) {\n    this.ie = [];\n    /* Intersecting edge (bundle) pair   */\n    this.point = new Point(x, y);\n    /* Point of intersection             */\n    this.next = next;\n    /* The next intersection table node  */\n\n    this.ie[0] = edge0;\n    this.ie[1] = edge1;\n\n};\n\n\n///////////////////////////    ItNodeTable   ///////////////\ngpcas.geometry.ItNodeTable = function () {\n    this.top_node;\n}\nItNodeTable = gpcas.geometry.ItNodeTable;\n\ngpcas.geometry.ItNodeTable.prototype.build_intersection_table = function (aet, dy) {\n    var st = null;\n\n    /* Process each AET edge */\n    for (var edge = aet.top_node; (edge != null); edge = edge.next) {\n        if ((edge.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) ||\n            (edge.bundle[Clip.ABOVE][Clip.CLIP] != 0) ||\n            (edge.bundle[Clip.ABOVE][Clip.SUBJ] != 0)) {\n            st = gpcas.geometry.Clip.add_st_edge(st, this, edge, dy);\n        }\n\n\n    }\n}\n\n////////////// Line //////////////////////////\ngpcas.geometry.Line = function () {\n    this.start;\n    this.end;\n}\n\n////////////   LineHelper /////////////////////\n\ngpcas.geometry.LineHelper = function () {\n};\ngpcas.geometry.LineHelper.equalPoint = function (p1, p2) {\n    return ((p1[0] == p2[0]) && (p1[1] == p2[1]));\n}\ngpcas.geometry.LineHelper.equalVertex = function (s1, e1, s2, e2) {\n    return (\n    ((gpcas.geometry.LineHelper.equalPoint(s1, s2)) && (gpcas.geometry.LineHelper.equalPoint(e1, e2)))\n    ||\n    ((gpcas.geometry.LineHelper.equalPoint(s1, e2)) && (gpcas.geometry.LineHelper.equalPoint(e1, s2)))\n    );\n}\ngpcas.geometry.LineHelper.distancePoints = function (p1, p2) {\n    return Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\n}\ngpcas.geometry.LineHelper.clonePoint = function (p) {\n    return [p[0], p[1]];\n}\ngpcas.geometry.LineHelper.cloneLine = function (line) {\n    var res = [];\n    for (var i = 0; i < line.length; i++) {\n        res[i] = [line[i][0], line[i][1]];\n    }\n    return res;\n}\ngpcas.geometry.LineHelper.addLineToLine = function (line1, line2) {\n    for (var i = 0; i < line2.length; i++) {\n        line1.push(clonePoint(line2[i]));\n    }\n}\ngpcas.geometry.LineHelper.roundPoint = function (p) {\n    p[0] = Math.round(p[0]);\n    p[1] = Math.round(p[1]);\n}\n//---------------------------------------------------------------\n//Checks for intersection of Segment if as_seg is true.\n//Checks for intersection of Line if as_seg is false.\n//Return intersection of Segment \"AB\" and Segment \"EF\" as a Point\n//Return null if there is no intersection\n//---------------------------------------------------------------\ngpcas.geometry.LineHelper.lineIntersectLine = function (A, B, E, F, as_seg) {\n    if (as_seg == null) as_seg = true;\n    var ip;\n    var a1;\n    var a2;\n    var b1;\n    var b2;\n    var c1;\n    var c2;\n\n    a1 = B.y - A.y;\n    b1 = A.x - B.x;\n    c1 = B.x * A.y - A.x * B.y;\n    a2 = F.y - E.y;\n    b2 = E.x - F.x;\n    c2 = F.x * E.y - E.x * F.y;\n\n    var denom = a1 * b2 - a2 * b1;\n    if (denom == 0) {\n        return null;\n    }\n    ip = new Point();\n    ip.x = (b1 * c2 - b2 * c1) / denom;\n    ip.y = (a2 * c1 - a1 * c2) / denom;\n\n    //---------------------------------------------------\n    //Do checks to see if intersection to endpoints\n    //distance is longer than actual Segments.\n    //Return null if it is with any.\n    //---------------------------------------------------\n    if (as_seg) {\n        if (Math.pow((ip.x - B.x) + (ip.y - B.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)) {\n            return null;\n        }\n        if (Math.pow((ip.x - A.x) + (ip.y - A.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)) {\n            return null;\n        }\n\n        if (Math.pow((ip.x - F.x) + (ip.y - F.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)) {\n            return null;\n        }\n        if (Math.pow((ip.x - E.x) + (ip.y - E.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)) {\n            return null;\n        }\n    }\n    return new Point(Math.round(ip.x), Math.round(ip.y));\n}\n\n\n//////////////  LineIntersection  ///////////////////////\ngpcas.geometry.LineIntersection = function () {\n};\ngpcas.geometry.LineIntersection.iteratePoints = function (points, s1, s2, e1, e2) {\n    var direction = true;\n    var pl = points.length;\n    var s1Ind = points.indexOf(s1);\n    var s2Ind = points.indexOf(s2);\n    var start = s1Ind;\n\n    if (s2Ind > s1Ind) direction = false;\n    var newPoints = [];\n    var point;\n\n    if (direction) {\n        for (var i = 0; i < pl; i++) {\n            point = (i + start < pl) ? points[i + start] : points[i + start - pl];\n            newPoints.push(point);\n            if ((equals(point, e1)) || (equals(point, e2))) {\n                break;\n            }\n        }\n    } else {\n        for (var i = pl; i >= 0; i--) {\n            point = (i + start < pl) ? points[i + start] : points[i + start - pl];\n            newPoints.push(point);\n            if ((equals(point, e1)) || (equals(point, e2))) {\n                break;\n            }\n        }\n    }\n\n    return newPoints;\n}\n\ngpcas.geometry.LineIntersection.intersectPoly = function (poly, line /* of Points */) {\n    var res = [];\n    var numPoints = poly.getNumPoints();\n\n    //points\n    var ip;\n    var p1;\n    var p2;\n    var p3;\n    var p4;\n    var firstIntersection = null;\n    var lastIntersection = null;\n    var firstIntersectionLineIndex = -1;\n    var lastIntersectionLineIndex = -1;\n    var firstFound = false;\n\n    for (var i = 1; i < line.length; i++) {\n        p1 = line[i - 1];\n        p2 = line[i];\n        var maxDist = 0;\n        var minDist = Number.MAX_VALUE;\n        var dist = -1;\n        for (var j = 0; j < numPoints; j++) {\n            p3 = poly.getPoint(j == 0 ? numPoints - 1 : j - 1);\n            p4 = poly.getPoint(j);\n            if ((ip = LineHelper.lineIntersectLine(p1, p2, p3, p4)) != null) {\n                dist = Point.distance(ip, p2);\n\n                if ((dist > maxDist) && (!firstFound)) {\n                    maxDist = dist;\n                    firstIntersection = new IntersectionPoint(p3, p4, ip);\n                    firstIntersectionLineIndex = i;\n                }\n                if (dist < minDist) {\n                    minDist = dist;\n                    lastIntersection = new IntersectionPoint(p3, p4, ip);\n                    lastIntersectionLineIndex = i - 1;\n                }\n            }\n        }\n        firstFound = (firstIntersection != null);\n    }\n    /*\n     Alert.show(firstIntersection.toString());\n     Alert.show(lastIntersection.toString());*/\n    if ((firstIntersection != null) && (lastIntersection != null)) {\n        var newLine /* of Point */ = [];\n        newLine[0] = firstIntersection.intersectionPoint;\n        var j = 1;\n        for (var i = firstIntersectionLineIndex; i <= lastIntersectionLineIndex; i++) {\n            newLine[j++] = line[i];\n        }\n        newLine[newLine.length - 1] = lastIntersection.intersectionPoint;\n        if (\n            (\n            (equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint1)) &&\n            (equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint2))\n            ) ||\n            (\n            (equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint2)) &&\n            (equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint1))\n            )\n        ) {\n            var poly1 = new gpcas.geometry.PolySimple();\n            poly1.add(newLine);\n            var finPoly1 = poly.intersection(poly1);\n            var finPoly2 = poly.xor(poly1);\n            if ((checkPoly(finPoly1)) && (checkPoly(finPoly2))) {\n                return [finPoly1, finPoly2];\n            }\n        } else {\n            var points1 = iteratePoints(poly.getPoints(), firstIntersection.polygonPoint1, firstIntersection.polygonPoint2, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n            points1 = points1.concat(newLine.reverse());\n            var points2 = iteratePoints(poly.getPoints(), firstIntersection.polygonPoint2, firstIntersection.polygonPoint1, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n            points2 = points2.concat(newLine);\n            var poly1 = new gpcas.geometry.PolySimple();\n            poly1.add(points1);\n            var poly2 = new gpcas.geometry.PolySimple();\n            poly2.add(points2);\n            var finPoly1 = poly.intersection(poly1);\n            var finPoly2 = poly.intersection(poly2);\n\n            if ((checkPoly(finPoly1)) && (checkPoly(finPoly2))) {\n                return [finPoly1, finPoly2];\n            }\n        }\n    }\n    return null;\n}\ngpcas.geometry.LineIntersection.checkPoly = function (poly) {\n    var noHoles = 0;\n    for (var i = 0; i < poly.getNumInnerPoly(); i++) {\n        var innerPoly = poly.getInnerPoly(i);\n        if (innerPoly.isHole()) {\n            return false;\n        } else {\n            noHoles++;\n        }\n        if (noHoles > 1) return false;\n    }\n    return true;\n}\n\n\n///////////  LmtNode //////////////////////////\n\ngpcas.geometry.LmtNode = function (yvalue) {\n    this.y = yvalue;\n    /* Y coordinate at local minimum     */\n    this.first_bound;\n    /* Pointer to bound list             */\n    this.next;\n    /* Pointer to next local minimum     */\n};\nLmtNode = gpcas.geometry.LmtNode;\n\n////////////// LmtTable ///////////////\n\ngpcas.geometry.LmtTable = function () {\n    this.top_node;\n};\ngpcas.geometry.LmtTable.prototype.print = function () {\n    var n = 0;\n    var lmt = this.top_node;\n    while (lmt != null) {\n        //console.log(\"lmt(\"+n+\")\");\n        for (var edge = lmt.first_bound; (edge != null); edge = edge.next_bound) {\n            //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n        }\n        n++;\n        lmt = lmt.next;\n    }\n}\n\n/////////////   OperationType //////////////////////////////////\ngpcas.geometry.OperationType = function (type) {\n    this.m_Type = type;\n}\ngpcas.geometry.OperationType.GPC_DIFF = new gpcas.geometry.OperationType(\"Difference\");\ngpcas.geometry.OperationType.GPC_INT = new gpcas.geometry.OperationType(\"Intersection\");\ngpcas.geometry.OperationType.GPC_XOR = new gpcas.geometry.OperationType(\"Exclusive or\");\ngpcas.geometry.OperationType.GPC_UNION = new gpcas.geometry.OperationType(\"Union\");\n\n//////////// Poly  /////////////////////\n// ---> an interface\n\n\n/////////////// PolyDefault  /////////////////////\n/**\n * <code>PolyDefault</code> is a default <code>Poly</code> implementation.\n * It provides support for both complex and simple polygons.  A <i>complex polygon</i>\n * is a polygon that consists of more than one polygon.  A <i>simple polygon</i> is a\n * more traditional polygon that contains of one inner polygon and is just a\n * collection of points.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty <code>PolyDefault</code>\n * object, it will create an inner polygon of type <code>PolySimple</code>.\n *\n * @see PolySimple\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolyDefault = function (isHole) {\n    if (isHole == null) isHole = false;\n\n    /**\n     * Only applies to the first poly and can only be used with a poly that contains one poly\n     */\n    this.m_IsHole = isHole;\n    this.m_List = new gpcas.util.ArrayList();\n}\n/**\n * Return true if the given object is equal to this one.\n */\ngpcas.geometry.PolyDefault.prototype.equals = function (obj) {\n    if (!(obj instanceof PolyDefault)) {\n        return false;\n    }\n    var that = obj;\n\n    if (this.m_IsHole != that.m_IsHole) return false;\n    if (!equals(this.m_List, that.m_List)) return false;\n\n    return true;\n}\n/**\n * Return the hashCode of the object.\n *\n * @return an integer value that is the same for two objects\n * whenever their internal representation is the same (equals() is true)\n **/\ngpcas.geometry.PolyDefault.prototype.hashCode = function () {\n    var m_List = this.m_List;\n\n    var result = 17;\n    result = 37 * result + m_List.hashCode();\n    return result;\n}\n/**\n * Remove all of the points.  Creates an empty polygon.\n */\ngpcas.geometry.PolyDefault.prototype.clear = function () {\n    this.m_List.clear();\n}\n\ngpcas.geometry.PolyDefault.prototype.add = function (arg0, arg1) {\n    var args = [];\n\n    args[0] = arg0;\n    if (arg1) {\n        args[1] = arg1;\n    }\n    if (args.length == 2) {\n        this.addPointXY(args[0], args[1]);\n    } else if (args.length == 1) {\n        if (args[0] instanceof Point) {\n            this.addPoint(args[0]);\n        } else if (args[0] instanceof gpcas.geometry.PolySimple) {\n            this.addPoly(args[0]);\n        } else if (args[0] instanceof Array) {\n            var arr = args[0];\n            if ((arr.length == 2) && (arr[0] instanceof Number) && (arr[1] instanceof Number)) {\n                this.add(arr[0], arr[1])\n            } else {\n                for (var i = 0; i < args[0].length; i++) {\n                    this.add(args[0][i]);\n                }\n            }\n        }\n    }\n}\n/**\n * Add a point to the first inner polygon.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n * it will create an inner polygon of type <code>PolySimple</code>.\n */\ngpcas.geometry.PolyDefault.prototype.addPointXY = function (x, y) {\n    this.addPoint(new Point(x, y));\n}\n/**\n * Add a point to the first inner polygon.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n * it will create an inner polygon of type <code>PolySimple</code>.\n */\ngpcas.geometry.PolyDefault.prototype.addPoint = function (p) {\n\n\n    var m_List = this.m_List;\n\n    if (m_List.size() == 0) {\n        m_List.add(new gpcas.geometry.PolySimple());\n    }\n    (m_List.get(0)).addPoint(p);\n}\n/**\n * Add an inner polygon to this polygon - assumes that adding polygon does not\n * have any inner polygons.\n *\n * @throws IllegalStateException if the number of inner polygons is greater than\n * zero and this polygon was designated a hole.  This would break the assumption\n * that only simple polygons can be holes.\n */\ngpcas.geometry.PolyDefault.prototype.addPoly = function (p) {\n\n    var m_IsHole = this.m_IsHole;\n    var m_List = this.m_List;\n\n    if ((m_List.size() > 0) && m_IsHole) {\n        alert(\"ERROR : Cannot add polys to something designated as a hole.\");\n    }\n    m_List.add(p);\n}\n/**\n * Return true if the polygon is empty\n */\ngpcas.geometry.PolyDefault.prototype.isEmpty = function () {\n    return this.m_List.isEmpty();\n}\n/**\n * Returns the bounding rectangle of this polygon.\n * <strong>WARNING</strong> Not supported on complex polygons.\n */\ngpcas.geometry.PolyDefault.prototype.getBounds = function () {\n    var m_List = this.m_List;\n    if (m_List.size() == 0) {\n        return new Rectangle();\n    }\n    else if (m_List.size() == 1) {\n        var ip = this.getInnerPoly(0);\n        return ip.getBounds();\n    }\n    else {\n        console.log(\"getBounds not supported on complex poly.\");\n    }\n}\n/**\n * Returns the polygon at this index.\n */\ngpcas.geometry.PolyDefault.prototype.getInnerPoly = function (polyIndex) {\n    return this.m_List.get(polyIndex);\n}\n/**\n * Returns the number of inner polygons - inner polygons are assumed to return one here.\n */\ngpcas.geometry.PolyDefault.prototype.getNumInnerPoly = function () {\n    var m_List = this.m_List;\n    return m_List.size();\n}\n/**\n * Return the number points of the first inner polygon\n */\ngpcas.geometry.PolyDefault.prototype.getNumPoints = function () {\n    return (this.m_List.get(0)).getNumPoints();\n}\n\n/**\n * Return the X value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolyDefault.prototype.getX = function (index) {\n    return (this.m_List.get(0)).getX(index);\n}\ngpcas.geometry.PolyDefault.prototype.getPoint = function (index) {\n    return (this.m_List.get(0)).getPoint(index);\n}\n\ngpcas.geometry.PolyDefault.prototype.getPoints = function () {\n    return (this.m_List.get(0)).getPoints();\n}\n\n\ngpcas.geometry.PolyDefault.prototype.isPointInside = function (point) {\n    var m_List = this.m_List;\n    if (!(m_List.get(0)).isPointInside(point)) return false;\n\n    for (var i = 0; i < m_List.size(); i++) {\n        var poly = m_List.get(i);\n        if ((poly.isHole()) && (poly.isPointInside(point))) return false;\n    }\n    return true;\n}\n/**\n * Return the Y value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolyDefault.prototype.getY = function (index) {\n    var m_List = this.m_List;\n    return (m_List.get(0)).getY(index);\n}\n\n/**\n * Return true if this polygon is a hole.  Holes are assumed to be inner polygons of\n * a more complex polygon.\n *\n * @throws IllegalStateException if called on a complex polygon.\n */\ngpcas.geometry.PolyDefault.prototype.isHole = function () {\n    var m_List = this.m_List;\n    var m_IsHole = this.m_IsHole;\n\n    if (m_List.size() > 1) {\n        alert(\"Cannot call on a poly made up of more than one poly.\");\n    }\n    return m_IsHole;\n}\n\n/**\n * Set whether or not this polygon is a hole.  Cannot be called on a complex polygon.\n *\n * @throws IllegalStateException if called on a complex polygon.\n */\ngpcas.geometry.PolyDefault.prototype.setIsHole = function (isHole) {\n    var m_List = this.m_List;\n    if (m_List.size() > 1) {\n        alert(\"Cannot call on a poly made up of more than one poly.\");\n    }\n    this.m_IsHole = isHole;\n}\n\n/**\n * Return true if the given inner polygon is contributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n */\ngpcas.geometry.PolyDefault.prototype.isContributing = function (polyIndex) {\n    var m_List = this.m_List;\n    return (m_List.get(polyIndex)).isContributing(0);\n}\n\n/**\n * Set whether or not this inner polygon is constributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n *\n * @throws IllegalStateException if called on a complex polygon\n */\ngpcas.geometry.PolyDefault.prototype.setContributing = function (polyIndex, contributes) {\n    var m_List = this.m_List;\n    if (m_List.size() != 1) {\n        alert(\"Only applies to polys of size 1\");\n    }\n    (m_List.get(polyIndex)).setContributing(0, contributes);\n}\n\n/**\n * Return a Poly that is the intersection of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.intersection = function (p) {\n    return gpcas.geometry.Clip.intersection(p, this, \"PolyDefault\");\n}\n\n/**\n * Return a Poly that is the union of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.union = function (p) {\n    return gpcas.geometry.Clip.union(p, this, \"PolyDefault\");\n}\n\n/**\n * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.xor = function (p) {\n    return gpcas.geometry.Clip.xor(p, this, \"PolyDefault\");\n}\n\n/**\n * Return a Poly that is the difference of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolyDefault.prototype.difference = function (p) {\n    return gpcas.geometry.Clip.difference(p, this, \"PolyDefault\");\n}\n\n/**\n * Return the area of the polygon in square units.\n */\ngpcas.geometry.PolyDefault.prototype.getArea = function () {\n    var area = 0.0;\n    for (var i = 0; i < getNumInnerPoly(); i++) {\n        var p = getInnerPoly(i);\n        var tarea = p.getArea() * (p.isHole() ? -1.0 : 1.0);\n        area += tarea;\n    }\n    return area;\n}\n\n// -----------------------\n// --- Package Methods ---\n// -----------------------\ngpcas.geometry.PolyDefault.prototype.toString = function () {\n    var res = \"\";\n    var m_List = this.m_List;\n    for (var i = 0; i < m_List.size(); i++) {\n        var p = this.getInnerPoly(i);\n        res += (\"InnerPoly(\" + i + \").hole=\" + p.isHole());\n        var points = [];\n        for (var j = 0; j < p.getNumPoints(); j++) {\n            points.push(new Point(p.getX(j), p.getY(j)));\n        }\n        points = ArrayHelper.sortPointsClockwise(points);\n\n        for (var k = 0; k < points.length; k++) {\n            res += points[k].toString();\n        }\n\n    }\n    return res;\n}\n\n///////////////  Polygon   /////////////////////////////////\ngpcas.geometry.Polygon = function () {\n    this.maxTop;\n    this.maxBottom;\n    this.maxLeft;\n    this.maxRight;\n    this.vertices  /* of Point */;\n};\ngpcas.geometry.Polygon.prototype.fromArray = function (v) {\n    this.vertices = [];\n\n    for (var i = 0; i < v.length; i++) {\n        var pointArr = v[i];\n        this.vertices.push(new Point(pointArr[0], pointArr[1]));\n    }\n}\n\n/*Normalize vertices in polygon to be ordered clockwise from most left point*/\ngpcas.geometry.Polygon.prototype.normalize = function () {\n    var maxLeftIndex;\n    var vertices = this.vertices;\n    var newVertices = this.vertices;\n\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n\n        if ((maxTop == null) || (maxTop.y > vertex.y) || ((maxTop.y == vertex.y) && (vertex.x < maxTop.x))) {\n            maxTop = vertex;\n        }\n        if ((maxBottom == null) || (maxBottom.y < vertex.y) || ((maxBottom.y == vertex.y) && (vertex.x > maxBottom.x))) {\n            maxBottom = vertex;\n        }\n        if ((maxLeft == null) || (maxLeft.x > vertex.x) || ((maxLeft.x == vertex.x) && (vertex.y > maxLeft.y))) {\n            maxLeft = vertex;\n            maxLeftIndex = i;\n        }\n        if ((maxRight == null) || (maxRight.x < vertex.x) || ((maxRight.x == vertex.x) && (vertex.y < maxRight.y))) {\n            maxRight = vertex;\n        }\n    }\n\n    if (maxLeftIndex > 0) {\n        newVertices = [];\n        var j = 0;\n        for (var i = maxLeftIndex; i < vertices.length; i++) {\n            newVertices[j++] = this.vertices[i];\n        }\n        for (var i = 0; i < maxLeftIndex; i++) {\n            newVertices[j++] = this.vertices[i];\n        }\n        vertices = newVertices;\n    }\n    var reverse = false;\n    for (var k = 0; k < this.vertices.length; k++) {\n        var vertex = this.vertices[k];\n        if (equals(vertex, maxBottom)) {\n            reverse = true;\n            break;\n        } else if (equals(vertex, maxTop)) {\n            break;\n        }\n    }\n    if (reverse) {\n        newVertices = [];\n        newVertices[0] = vertices[0];\n        var j = 1;\n        for (var i = vertices.length - 1; i > 0; i--) {\n            newVertices[j++] = this.vertices[i];\n        }\n        vertices = newVertices;\n    }\n}\ngpcas.geometry.Polygon.prototype.getVertexIndex = function (vertex) {\n    for (var i = 0; i < this.vertices.length; i++) {\n        if (equals(vertices[i], vertex)) {\n            return i;\n        }\n    }\n    return -1;\n}\ngpcas.geometry.Polygon.prototype.insertVertex = function (vertex1, vertex2, newVertex) {\n    var vertex1Index = getVertexIndex(vertex1);\n    var vertex2Index = getVertexIndex(vertex2);\n    if ((vertex1Index == -1) || (vertex2Index == -1)) {\n        return false;\n    }\n\n    if (vertex2Index < vertex1Index) {\n        var i = vertex1Index;\n        vertex1Index = vertex2Index;\n        vertex2Index = i;\n    }\n    if (vertex2Index == vertex1Index + 1) {\n        var newVertices = [];\n        for (var i = 0; i <= vertex1Index; i++) {\n            newVertices[i] = this.vertices[i];\n        }\n        newVertices[vertex2Index] = newVertex;\n        for (var i = vertex2Index; i < this.vertices.length; i++) {\n            newVertices[i + 1] = this.vertices[i];\n        }\n        this.vertices = newVertices;\n    } else if ((vertex2Index == vertices.length - 1) && (vertex1Index == 0)) {\n        this.vertices.push(newVertex);\n    }\n    return true;\n}\ngpcas.geometry.Polygon.prototype.clone = function () {\n    var res = new gpcas.geometry.Polygon();\n    res.vertices = vertices.slice(this.vertices.length - 1);\n    return res;\n}\ngpcas.geometry.Polygon.prototype.toString = function () {\n    var vertices = this.vertices;\n    var res = \"[\";\n    for (var i = 0; i < vertices.length; i++) {\n        var vertex = vertices[i];\n        res += (i > 0 ? \",\" : \"\") + \"[\" + vertex.x + \",\" + vertex.y + \"]\";\n    }\n    res += \"]\";\n    return res;\n}\n\n\n////////////////////  PolygonNode ///////////////////////////\ngpcas.geometry.PolygonNode = function (next, x, y) {\n\n\n    this.active;\n    /* Active flag / vertex count        */\n    this.hole;\n    /* Hole / external contour flag      */\n    this.v = [];\n    /* Left and right vertex list ptrs   */\n    this.next;\n    /* Pointer to next polygon contour   */\n    this.proxy;\n    /* Pointer to actual structure used  */\n\n    /* Make v[Clip.LEFT] and v[Clip.RIGHT] point to new vertex */\n    var vn = new VertexNode(x, y);\n\n    this.v[Clip.LEFT] = vn;\n    this.v[Clip.RIGHT] = vn;\n\n    this.next = next;\n    this.proxy = this;\n    /* Initialise proxy to point to p itself */\n    this.active = 1; //TRUE\n}\ngpcas.geometry.PolygonNode.prototype.add_right = function (x, y) {\n    var nv = new VertexNode(x, y);\n\n    /* Add vertex nv to the right end of the polygon's vertex list */\n    this.proxy.v[Clip.RIGHT].next = nv;\n\n    /* Update proxy->v[Clip.RIGHT] to point to nv */\n    this.proxy.v[Clip.RIGHT] = nv;\n}\ngpcas.geometry.PolygonNode.prototype.add_left = function (x, y) {\n    var proxy = this.proxy;\n\n    var nv = new VertexNode(x, y);\n\n    /* Add vertex nv to the left end of the polygon's vertex list */\n    nv.next = proxy.v[Clip.LEFT];\n\n    /* Update proxy->[Clip.LEFT] to point to nv */\n    proxy.v[Clip.LEFT] = nv;\n}\n\n\n//////////////////   PolySimple ////////////////\n\n/**\n * <code>PolySimple</code> is a simple polygon - contains only one inner polygon.\n * <p>\n * <strong>WARNING:</strong> This type of <code>Poly</code> cannot be used for an\n * inner polygon that is a hole.\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolySimple = function () {\n    /**\n     * The list of Point objects in the polygon.\n     */\n    this.m_List = new gpcas.util.ArrayList();\n\n    /** Flag used by the Clip algorithm */\n    this.m_Contributes = true;\n};\n\n/**\n * Return true if the given object is equal to this one.\n * <p>\n * <strong>WARNING:</strong> This method failse if the first point\n * appears more than once in the list.\n */\ngpcas.geometry.PolySimple.prototype.equals = function (obj) {\n    if (!(obj instanceof PolySimple)) {\n        return false;\n    }\n\n    var that = obj;\n\n    var this_num = this.m_List.size();\n    var that_num = that.m_List.size();\n    if (this_num != that_num) return false;\n\n\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // !!! WARNING: This is not the greatest algorithm.  It fails if !!!\n    // !!! the first point in \"this\" poly appears more than once.    !!!\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    if (this_num > 0) {\n        var this_x = this.getX(0);\n        var this_y = this.getY(0);\n        var that_first_index = -1;\n        for (var that_index = 0; (that_first_index == -1) && (that_index < that_num); that_index++) {\n            var that_x = that.getX(that_index);\n            var that_y = that.getY(that_index);\n            if ((this_x == that_x) && (this_y == that_y)) {\n                that_first_index = that_index;\n            }\n        }\n        if (that_first_index == -1) return false;\n        var that_index = that_first_index;\n        for (var this_index = 0; this_index < this_num; this_index++) {\n            this_x = this.getX(this_index);\n            this_y = this.getY(this_index);\n            var that_x = that.getX(that_index);\n            var that_y = that.getY(that_index);\n\n            if ((this_x != that_x) || (this_y != that_y)) return false;\n\n            that_index++;\n            if (that_index >= that_num) {\n                that_index = 0;\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * Return the hashCode of the object.\n * <p>\n * <strong>WARNING:</strong>Hash and Equals break contract.\n *\n * @return an integer value that is the same for two objects\n * whenever their internal representation is the same (equals() is true)\n */\ngpcas.geometry.PolySimple.prototype.hashCode = function () {\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // !!! WARNING:  This hash and equals break the contract. !!!\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    var result = 17;\n    result = 37 * result + this.m_List.hashCode();\n    return result;\n}\n\n/**\n * Return a string briefly describing the polygon.\n */\ngpcas.geometry.PolySimple.prototype.toString = function () {\n    return \"PolySimple: num_points=\" + getNumPoints();\n}\n\n// --------------------\n// --- Poly Methods ---\n// --------------------\n/**\n * Remove all of the points.  Creates an empty polygon.\n */\ngpcas.geometry.PolySimple.prototype.clear = function () {\n    this.m_List.clear();\n}\n\n\ngpcas.geometry.PolySimple.prototype.add = function (arg0, arg1) {\n    var args = [];\n    args[0] = arg0;\n    if (arg1) {\n        args[1] = arg1;\n    }\n\n    if (args.length == 2) {\n        this.addPointXY(args[0], args[1]);\n    } else if (args.length == 1) {\n        if (args[0] instanceof Point) {\n            this.addPoint(args[0]);\n        } else if (args[0] instanceof Poly) {\n            this.addPoly(args[0]);\n        } else if (args[0] instanceof Array) {\n            for (var k = 0; k < args[0].length; k++) {\n                var val = args[0][k];\n                this.add(val);\n            }\n        }\n    }\n}\n\n\n/**\n * Add a point to the first inner polygon.\n */\ngpcas.geometry.PolySimple.prototype.addPointXY = function (x, y) {\n    this.addPoint(new Point(x, y));\n}\n\n/**\n * Add a point to the first inner polygon.\n */\ngpcas.geometry.PolySimple.prototype.addPoint = function (p) {\n    this.m_List.add(p);\n}\n\n/**\n * Throws IllegalStateexception if called\n */\ngpcas.geometry.PolySimple.prototype.addPoly = function (p) {\n    alert(\"Cannot add poly to a simple poly.\");\n}\n\n/**\n * Return true if the polygon is empty\n */\ngpcas.geometry.PolySimple.prototype.isEmpty = function () {\n    return this.m_List.isEmpty();\n}\n\n/**\n * Returns the bounding rectangle of this polygon.\n */\ngpcas.geometry.PolySimple.prototype.getBounds = function () {\n    var xmin = Number.MAX_VALUE;\n    var ymin = Number.MAX_VALUE;\n    var xmax = -Number.MAX_VALUE;\n    var ymax = -Number.MAX_VALUE;\n\n    for (var i = 0; i < this.m_List.size(); i++) {\n        var x = this.getX(i);\n        var y = this.getY(i);\n        if (x < xmin) xmin = x;\n        if (x > xmax) xmax = x;\n        if (y < ymin) ymin = y;\n        if (y > ymax) ymax = y;\n    }\n\n    return new Rectangle(xmin, ymin, (xmax - xmin), (ymax - ymin));\n}\n\n/**\n * Returns <code>this</code> if <code>polyIndex = 0</code>, else it throws\n * IllegalStateException.\n */\ngpcas.geometry.PolySimple.prototype.getInnerPoly = function (polyIndex) {\n    if (polyIndex != 0) {\n        alert(\"PolySimple only has one poly\");\n    }\n    return this;\n}\n\n/**\n * Always returns 1.\n */\ngpcas.geometry.PolySimple.prototype.getNumInnerPoly = function () {\n    return 1;\n}\n\n/**\n * Return the number points of the first inner polygon\n */\ngpcas.geometry.PolySimple.prototype.getNumPoints = function () {\n    return this.m_List.size();\n}\n\n/**\n * Return the X value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolySimple.prototype.getX = function (index) {\n    return (this.m_List.get(index)).x;\n}\n\n/**\n * Return the Y value of the point at the index in the first inner polygon\n */\ngpcas.geometry.PolySimple.prototype.getY = function (index) {\n    return (this.m_List.get(index)).y;\n}\n\ngpcas.geometry.PolySimple.prototype.getPoint = function (index) {\n    return (this.m_List.get(index));\n}\n\ngpcas.geometry.PolySimple.prototype.getPoints = function () {\n    return this.m_List.toArray();\n}\n\ngpcas.geometry.PolySimple.prototype.isPointInside = function (point) {\n    var points = this.getPoints();\n    var j = points.length - 1;\n    var oddNodes = false;\n\n    for (var i = 0; i < points.length; i++) {\n        if (points[i].y < point.y && points[j].y >= point.y ||\n            points[j].y < point.y && points[i].y >= point.y) {\n            if (points[i].x +\n                (point.y - points[i].y) / (points[j].y - points[i].y) * (points[j].x - points[i].x) < point.x) {\n                oddNodes = !oddNodes;\n            }\n        }\n        j = i;\n    }\n    return oddNodes;\n}\n\n\n/**\n * Always returns false since PolySimples cannot be holes.\n */\ngpcas.geometry.PolySimple.prototype.isHole = function () {\n    return false;\n}\n\n/**\n * Throws IllegalStateException if called.\n */\ngpcas.geometry.PolySimple.prototype.setIsHole = function (isHole) {\n    alert(\"PolySimple cannot be a hole\");\n}\n\n/**\n * Return true if the given inner polygon is contributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n *\n * @throws IllegalStateException if <code>polyIndex != 0</code>\n */\ngpcas.geometry.PolySimple.prototype.isContributing = function (polyIndex) {\n    if (polyIndex != 0) {\n        alert(\"PolySimple only has one poly\");\n    }\n    return this.m_Contributes;\n}\n\n/**\n * Set whether or not this inner polygon is constributing to the set operation.\n * This method should NOT be used outside the Clip algorithm.\n *\n * @throws IllegalStateException if <code>polyIndex != 0</code>\n */\ngpcas.geometry.PolySimple.prototype.setContributing = function (polyIndex, contributes) {\n    if (polyIndex != 0) {\n        alert(\"PolySimple only has one poly\");\n    }\n    this.m_Contributes = contributes;\n}\n\n/**\n * Return a Poly that is the intersection of this polygon with the given polygon.\n * The returned polygon is simple.\n *\n * @return The returned Poly is of type PolySimple\n */\ngpcas.geometry.PolySimple.prototype.intersection = function (p) {\n    return gpcas.geometry.Clip.intersection(this, p, \"PolySimple\");\n}\n\n/**\n * Return a Poly that is the union of this polygon with the given polygon.\n * The returned polygon is simple.\n *\n * @return The returned Poly is of type PolySimple\n */\ngpcas.geometry.PolySimple.prototype.union = function (p) {\n    return gpcas.geometry.Clip.union(this, p, \"PolySimple\");\n}\n\n/**\n * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n * The returned polygon is simple.\n *\n * @return The returned Poly is of type PolySimple\n */\ngpcas.geometry.PolySimple.prototype.xor = function (p) {\n    return gpcas.geometry.Clip.xor(p, this, \"PolySimple\");\n}\n\n/**\n * Return a Poly that is the difference of this polygon with the given polygon.\n * The returned polygon could be complex.\n *\n * @return the returned Poly will be an instance of PolyDefault.\n */\ngpcas.geometry.PolySimple.prototype.difference = function (p) {\n    return gpcas.geometry.Clip.difference(p, this, \"PolySimple\");\n}\n\n/**\n * Returns the area of the polygon.\n * <p>\n * The algorithm for the area of a complex polygon was take from\n * code by Joseph O'Rourke author of \" Computational Geometry in C\".\n */\ngpcas.geometry.PolySimple.prototype.getArea = function () {\n    if (this.getNumPoints() < 3) {\n        return 0.0;\n    }\n    var ax = this.getX(0);\n    var ay = this.getY(0);\n\n    var area = 0.0;\n    for (var i = 1; i < (this.getNumPoints() - 1); i++) {\n        var bx = this.getX(i);\n        var by = this.getY(i);\n        var cx = this.getX(i + 1);\n        var cy = this.getY(i + 1);\n        var tarea = ((cx - bx) * (ay - by)) - ((ax - bx) * (cy - by));\n        area += tarea;\n    }\n    area = 0.5 * Math.abs(area);\n    return area;\n}\n\n/////////////////////// Rectangle  ///////////////////\ngpcas.geometry.Rectangle = function (_x, _y, _w, _h) {\n    this.x = _x;\n    this.y = _y;\n    this.w = _w;\n    this.h = _h;\n}\ngpcas.geometry.Rectangle.prototype.getMaxY = function () {\n    return this.y + this.h;\n}\ngpcas.geometry.Rectangle.prototype.getMinY = function () {\n    return this.y;\n}\ngpcas.geometry.Rectangle.prototype.getMaxX = function () {\n    return this.x + this.w;\n}\ngpcas.geometry.Rectangle.prototype.getMinX = function () {\n    return this.x;\n}\ngpcas.geometry.Rectangle.prototype.toString = function () {\n    return \"[\" + x.toString() + \" \" + y.toString() + \" \" + w.toString() + \" \" + h.toString() + \"]\";\n}\n\n/////////////////// ScanBeamTree //////////////////////\ngpcas.geometry.ScanBeamTree = function (yvalue) {\n    this.y = yvalue;\n    /* Scanbeam node y value             */\n    this.less;\n    /* Pointer to nodes with lower y     */\n    this.more;\n    /* Pointer to nodes with higher y    */\n}\n\n///////////////////////// ScanBeamTreeEntries /////////////////\ngpcas.geometry.ScanBeamTreeEntries = function () {\n    this.sbt_entries = 0;\n    this.sb_tree;\n};\ngpcas.geometry.ScanBeamTreeEntries.prototype.build_sbt = function () {\n    var sbt = [];\n\n    var entries = 0;\n    entries = this.inner_build_sbt(entries, sbt, this.sb_tree);\n\n    //console.log(\"SBT = \"+this.sbt_entries);\n\n    if (entries != this.sbt_entries) {\n        //console.log(\"Something went wrong buildign sbt from tree.\");\n    }\n    return sbt;\n}\ngpcas.geometry.ScanBeamTreeEntries.prototype.inner_build_sbt = function (entries, sbt, sbt_node) {\n    if (sbt_node.less != null) {\n        entries = this.inner_build_sbt(entries, sbt, sbt_node.less);\n    }\n    sbt[entries] = sbt_node.y;\n    entries++;\n    if (sbt_node.more != null) {\n        entries = this.inner_build_sbt(entries, sbt, sbt_node.more);\n    }\n    return entries;\n}\n\n///////////////////////////  StNode\nStNode = gpcas.geometry.StNode = function (edge, prev) {\n    this.edge;\n    /* Pointer to AET edge               */\n    this.xb;\n    /* Scanbeam bottom x coordinate      */\n    this.xt;\n    /* Scanbeam top x coordinate         */\n    this.dx;\n    /* Change in x for a unit y increase */\n    this.prev;\n    /* Previous edge in sorted list      */\n\n    this.edge = edge;\n    this.xb = edge.xb;\n    this.xt = edge.xt;\n    this.dx = edge.dx;\n    this.prev = prev;\n}\n\n/////////////////////   TopPolygonNode /////////////////\ngpcas.geometry.TopPolygonNode = function () {\n    this.top_node;\n};\nTopPolygonNode = gpcas.geometry.TopPolygonNode;\n\ngpcas.geometry.TopPolygonNode.prototype.add_local_min = function (x, y) {\n    var existing_min = this.top_node;\n    this.top_node = new gpcas.geometry.PolygonNode(existing_min, x, y);\n    return this.top_node;\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_left = function (p, q) {\n    /* Label contour as a hole */\n    q.proxy.hole = true;\n    var top_node = this.top_node;\n\n    if (p.proxy != q.proxy) {\n        /* Assign p's vertex list to the left end of q's list */\n        p.proxy.v[Clip.RIGHT].next = q.proxy.v[Clip.LEFT];\n        q.proxy.v[Clip.LEFT] = p.proxy.v[Clip.LEFT];\n\n        /* Redirect any p.proxy references to q.proxy */\n        var target = p.proxy;\n        for (var node = top_node; (node != null); node = node.next) {\n            if (node.proxy == target) {\n                node.active = 0;\n                node.proxy = q.proxy;\n            }\n        }\n    }\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_right = function (p, q) {\n    var top_node = this.top_node;\n    /* Label contour as external */\n    q.proxy.hole = false;\n\n    if (p.proxy != q.proxy) {\n        /* Assign p's vertex list to the right end of q's list */\n        q.proxy.v[Clip.RIGHT].next = p.proxy.v[Clip.LEFT];\n        q.proxy.v[Clip.RIGHT] = p.proxy.v[Clip.RIGHT];\n\n        /* Redirect any p->proxy references to q->proxy */\n        var target = p.proxy;\n        for (var node = top_node; (node != null ); node = node.next) {\n            if (node.proxy == target) {\n                node.active = 0;\n                node.proxy = q.proxy;\n            }\n        }\n    }\n}\ngpcas.geometry.TopPolygonNode.prototype.count_contours = function () {\n    var nc = 0;\n\n    for (var polygon = this.top_node; (polygon != null); polygon = polygon.next) {\n        if (polygon.active != 0) {\n            /* Count the vertices in the current contour */\n            var nv = 0;\n            for (var v = polygon.proxy.v[Clip.LEFT]; (v != null); v = v.next) {\n                nv++;\n            }\n\n            /* Record valid vertex counts in the active field */\n            if (nv > 2) {\n                polygon.active = nv;\n                nc++;\n            }\n            else {\n                /* Invalid contour: just free the heap */\n//                  VertexNode nextv = null ;\n//                  for (VertexNode v= polygon.proxy.v[Clip.LEFT]; (v != null); v = nextv)\n//                  {\n//                     nextv= v.next;\n//                     v = null ;\n//                  }\n                polygon.active = 0;\n            }\n        }\n    }\n    return nc;\n}\ngpcas.geometry.TopPolygonNode.prototype.getResult = function (polyClass) {\n\n    var top_node = this.top_node;\n    var result = gpcas.geometry.Clip.createNewPoly(polyClass);\n//console.log(polyClass);\n\n\n    var num_contours = this.count_contours();\n\n    if (num_contours > 0) {\n        var c = 0;\n        var npoly_node = null;\n        for (var poly_node = top_node; (poly_node != null); poly_node = npoly_node) {\n            npoly_node = poly_node.next;\n            if (poly_node.active != 0) {\n\n                var poly = result;\n\n\n                if (num_contours > 1) {\n                    poly = gpcas.geometry.Clip.createNewPoly(polyClass);\n                }\n                if (poly_node.proxy.hole) {\n                    poly.setIsHole(poly_node.proxy.hole);\n                }\n\n                // ------------------------------------------------------------------------\n                // --- This algorithm puts the verticies into the poly in reverse order ---\n                // ------------------------------------------------------------------------\n                for (var vtx = poly_node.proxy.v[Clip.LEFT]; (vtx != null); vtx = vtx.next) {\n                    poly.add(vtx.x, vtx.y);\n                }\n                if (num_contours > 1) {\n                    result.addPoly(poly);\n                }\n                c++;\n            }\n        }\n\n        // -----------------------------------------\n        // --- Sort holes to the end of the list ---\n        // -----------------------------------------\n        var orig = result;\n        result = gpcas.geometry.Clip.createNewPoly(polyClass);\n        for (var i = 0; i < orig.getNumInnerPoly(); i++) {\n            var inner = orig.getInnerPoly(i);\n            if (!inner.isHole()) {\n                result.addPoly(inner);\n            }\n        }\n        for (var i = 0; i < orig.getNumInnerPoly(); i++) {\n            var inner = orig.getInnerPoly(i);\n            if (inner.isHole()) {\n                result.addPoly(inner);\n            }\n        }\n    }\n    return result;\n}\ngpcas.geometry.TopPolygonNode.prototype.print = function () {\n    //console.log(\"---- out_poly ----\");\n    var top_node = this.top_node;\n    var c = 0;\n    var npoly_node = null;\n    for (var poly_node = top_node; (poly_node != null); poly_node = npoly_node) {\n        //console.log(\"contour=\"+c+\"  active=\"+poly_node.active+\"  hole=\"+poly_node.proxy.hole);\n        npoly_node = poly_node.next;\n        if (poly_node.active != 0) {\n            var v = 0;\n            for (var vtx = poly_node.proxy.v[Clip.LEFT]; (vtx != null); vtx = vtx.next) {\n                //console.log(\"v=\"+v+\"  vtx.x=\"+vtx.x+\"  vtx.y=\"+vtx.y);\n            }\n            c++;\n        }\n    }\n}\n\n///////////    VertexNode  ///////////////\ngpcas.geometry.VertexNode = function (x, y) {\n    this.x;    // X coordinate component\n    this.y;    // Y coordinate component\n    this.next; // Pointer to next vertex in list\n\n    this.x = x;\n    this.y = y;\n    this.next = null;\n}\nVertexNode = gpcas.geometry.VertexNode;\n\n/////////////   VertexType   /////////////\ngpcas.geometry.VertexType = function () {\n};\ngpcas.geometry.VertexType.NUL = 0;\n/* Empty non-intersection            */\ngpcas.geometry.VertexType.EMX = 1;\n/* External maximum                  */\ngpcas.geometry.VertexType.ELI = 2;\n/* External left intermediate        */\ngpcas.geometry.VertexType.TED = 3;\n/* Top edge                          */\ngpcas.geometry.VertexType.ERI = 4;\n/* External right intermediate       */\ngpcas.geometry.VertexType.RED = 5;\n/* Right edge                        */\ngpcas.geometry.VertexType.IMM = 6;\n/* Internal maximum and minimum      */\ngpcas.geometry.VertexType.IMN = 7;\n/* Internal minimum                  */\ngpcas.geometry.VertexType.EMN = 8;\n/* External minimum                  */\ngpcas.geometry.VertexType.EMM = 9;\n/* External maximum and minimum      */\ngpcas.geometry.VertexType.LED = 10;\n/* Left edge                         */\ngpcas.geometry.VertexType.ILI = 11;\n/* Internal left intermediate        */\ngpcas.geometry.VertexType.BED = 12;\n/* Bottom edge                       */\ngpcas.geometry.VertexType.IRI = 13;\n/* Internal right intermediate       */\ngpcas.geometry.VertexType.IMX = 14;\n/* Internal maximum                  */\ngpcas.geometry.VertexType.FUL = 15;\n/* Full non-intersection             */\ngpcas.geometry.VertexType.getType = function (tr, tl, br, bl) {\n    return tr + (tl << 1) + (br << 2) + (bl << 3);\n}\n\nVertexType = gpcas.geometry.VertexType;\n\n////////////////// WeilerAtherton  /////////////\ngpcas.geometry.WeilerAtherton = function () {\n};\n\ngpcas.geometry.WeilerAtherton.prototype.merge = function (p1, p2) {\n    p1 = p1.clone();\n    p2 = p2.clone();\n}\n","'use strict';\n\n/*jshint -W072 */\nvar intersect = function (a10, a11, a20, a21, b10, b11, b20, b21) {\n    var ua_t = (b20 - b10) * (a11 - b11) - (b21 - b11) * (a10 - b10);\n    var ub_t = (a20 - a10) * (a11 - b11) - (a21 - a11) * (a10 - b10);\n    var u_b = (b21 - b11) * (a20 - a10) - (b20 - b10) * (a21 - a11);\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\nfunction Cell(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.items = [];\n}\n\nCell.prototype.insert = function (item) {\n    if (\n        (item.fromX >= this.x && item.fromY >= this.y && item.toX <= this.x + this.width && item.toY <= this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x + this.width, this.y) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x, this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x + this.width, this.y, this.x + this.width, this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y + this.height, this.x + this.width, this.y + this.height)\n    ) {\n        this.items.push(item);\n    }\n};\n\nmodule.exports = Cell;\n","'use strict';\n\nvar Cell = require('./cell');\nvar DoublyLinkedList = require('../../linkedlist/doublylinkedlist');\n\nfunction Grid(bounds, rows, cols) {\n    this.bounds = bounds;\n    this.rows = rows;\n    this.cols = cols;\n    this.cellX = this.bounds.width / this.cols;\n    this.cellY = this.bounds.height / this.rows;\n    this.cells = [];\n    this.out = new DoublyLinkedList();\n    for (var col = 0; col < this.cols; col++) {\n        this.cells[col] = [];\n        for (var row = 0; row < this.rows; row++) {\n            this.cells[col][row] = new Cell(col * this.cellX, row * this.cellY, this.cellX, this.cellY);\n        }\n    }\n}\n\nGrid.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            n = item.length;\n        while (i < n) {\n            this.insert(item);\n            i++;\n        }\n    } else {\n        for (var col = 0; col < this.cols; col++) {\n            for (var row = 0; row < this.rows; row++) {\n                this.cells[col][row].insert(item);\n            }\n        }\n    }\n};\n\nGrid.prototype.addOut = function (items) {\n    var i = 0,\n        n = items.length;\n    while (i < n) {\n        this.out.add(items[i]);\n        i++;\n    }\n};\n\nGrid.prototype.retrieve = function (item) {\n    // figure out cells\n    var nx = ((item.x % this.cellX) + item.width) > this.cellX ? true : false,\n        ny = ((item.y % this.cellY) + item.height) > this.cellY ? true : false,\n        x = Math.floor(item.x / this.cellX),\n        y = Math.floor(item.y / this.cellY);\n    this.out.clear();\n\n    this.addOut(this.cells[x][y].items);\n    if (nx) {\n        this.addOut(this.cells[x + 1][y].items);\n    }\n    if (ny) {\n        this.addOut(this.cells[x][y + 1].items);\n    }\n    if (nx && ny) {\n        this.addOut(this.cells[x + 1][y + 1].items);\n    }\n    return this.out;\n};\n\nmodule.exports = Grid;\n","module.exports = {\n    Grid: require('./grid'),\n    Cell: require('./cell')\n};\n","module.exports = {\n    Vector2: require('./vector2'),\n    LineSegment2: require('./linesegment2'),\n    Triangle2: require('./triangle2'),\n    Polygon2: require('./polygon2'),\n    RegularPolygon2: require('./regularpolygon2'),\n    gpc: require('./gpc'),\n    VisibilityPolygon: require('./visibilitypolygon'),\n\n    Grid: require('./grid'),\n    QuadTree: require('./quadtree')\n};\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\n\nmodule.exports = LineSegment2;\n\nvar cache = [];\nvar created = 0;\n\nfunction LineSegment2(start, end) {\n    if (!(this instanceof LineSegment2)) {\n        var l = cache.pop();\n        if (!l) {\n            l = new LineSegment2(start, end);\n            created++;\n        } else {\n            l.start.free();\n            l.end.free();\n            l.set(start, end);\n        }\n        return l;\n    }\n    this.start = start || Vector2();\n    this.end = end || Vector2();\n}\n\nLineSegment2.getStats = function () {\n    return [cache.length, created];\n};\n\nLineSegment2.prototype.set = function (start, end) {\n    this.start = start || Vector2();\n    this.end = end || Vector2();\n    return this;\n};\n\nLineSegment2.prototype.free = function () {\n    cache.push(this);\n};\n\nLineSegment2.prototype.lengthSq = function () {\n    return this.start.distanceSq(this.end);\n};\n\nLineSegment2.prototype.length = function () {\n    return this.start.distance(this.end);\n};\n\nLineSegment2.prototype.closestPoint = function (point, full) {\n    var l2 = this.lengthSq();\n    if (l2 === 0) {\n        return this.start.clone();\n    }\n    var t = ((point.x - this.start.x) * (this.end.x - this.start.x) + (point.y - this.start.y) * (this.end.y - this.start.y)) / l2;\n    if (!full) {\n        if (t < 0) {\n            return this.start.clone();\n        }\n        if (t > 1) {\n            return this.end.clone();\n        }\n    }\n    return Vector2(this.start.x + t * (this.end.x - this.start.x), this.start.y + t * (this.end.y - this.start.y));\n};\n\nLineSegment2.prototype.distanceSq = function (point, full) {\n    var c = this.closestPoint(point, full);\n    var d = point.distanceSq(c);\n    c.free();\n    return d;\n};\n\nLineSegment2.prototype.distance = function (point, full) {\n    return Math.sqrt(this.distanceSq(point, full));\n};\n\nLineSegment2.prototype.intersect = function (l, full) {\n    var u_b = (l.end.y - l.start.y) * (this.end.x - this.start.x) - (l.end.x - l.start.x) * (this.end.y - this.start.y);\n    if (u_b !== 0) {\n        var ua_t = (l.end.x - l.start.x) * (this.start.y - l.start.y) - (l.end.y - l.start.y) * (this.start.x - l.start.x);\n        var ub_t = (this.end.x - this.start.x) * (this.start.y - l.start.y) - (this.end.y - this.start.y) * (this.start.x - l.start.x);\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (full || (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)) {\n            return Vector2(this.start.x - ua * (this.start.x - this.end.x), this.start.y - ua * (this.start.y - this.end.y));\n        }\n    } else {\n        return null; // perpendicular\n    }\n    return false;\n};\n\nLineSegment2.prototype.intersectCircle = function (point, radius, full) {\n    var r2 = radius * radius;\n    var closest = this.closestPoint(point, full);\n    var dist_v = point.clone().subtract(closest);\n    var len2 = dist_v.distanceSq();\n    dist_v.free();\n    if (len2 < r2) {\n        return closest;\n    } else {\n        closest.free();\n        return false;\n    }\n};\n\nLineSegment2.prototype.equals = function (other) {\n    return (this.start === other.start && this.end === other.end);\n};\n\nLineSegment2.prototype.inverse = function () {\n    return LineSegment2(this.end.clone(), this.start.clone());\n};\n\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\nvar LineSegment2 = require('./linesegment2');\nvar epsilon = 0.0000001;\n\nmodule.exports = Polygon2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Polygon2(points) {\n    if (!(this instanceof Polygon2)) {\n        var p = cache.pop();\n        if (!p) {\n            p = new Polygon2(points);\n            created++;\n        } else {\n            p.freePoints();\n            p.set(points);\n        }\n        return p;\n    }\n    this.points = points || [];\n}\n\nPolygon2.fromArray = function (points) {\n    var p = Polygon2();\n    for (var i = 0; i < points.length; i++) {\n        p.add(Vector2.fromArray(points[i]));\n    }\n    return p;\n};\n\nPolygon2.getStats = function () {\n    return [cache.length, created];\n};\n\nPolygon2.prototype.free = function () {\n    this.freePoints();\n    cache.push(this);\n};\n\nPolygon2.prototype.freePoints = function () {\n    var p = this.points.pop();\n    while (p) {\n        p.free();\n        p = this.points.pop();\n    }\n    return this;\n};\n\nPolygon2.prototype.set = function (points) {\n    this.points = points || [];\n    return this;\n};\n\nPolygon2.prototype.add = function (point) {\n    this.points.push(point);\n    return this;\n};\n\nPolygon2.prototype.translate = function (vec) {\n    for (var i = 0; i < this.points.length; i++) {\n        this.points[i].add(vec);\n    }\n    return this;\n};\n\nPolygon2.prototype.rotate = function (angle, origin) {\n    for (var i = 0; i < this.points.length; i++) {\n        this.points[i].rotate(angle, origin);\n    }\n    return this;\n};\n\nPolygon2.prototype.containsPoint = function (point) {\n    var inside = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n\n        var intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n\nPolygon2.prototype.intersectsLine = function (line, ignorePoints) {\n    var tempLine = LineSegment2();\n\n    var intersect = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n        tempLine.start.set(xi, yi);\n        tempLine.end.set(xj, yj);\n        var is = tempLine.intersect(line);\n        if (is) {\n            if (ignorePoints && (this.points[i].isEqualEpsilon(is) || this.points[j].isEqualEpsilon(is) || line.start.isEqualEpsilon(is) || line.end.isEqualEpsilon(is) )) {\n                // special perpendicular test\n                var a = this.points[i].clone().subtract(this.points[j]).normalize();\n                var aa = a.angle();\n                a.copy(line.start).subtract(line.end).normalize();\n                var bb = a.angle();\n                a.free();\n                is.free();\n                if (Math.abs(aa - bb) < epsilon) {\n                    intersect = true;\n                    break;\n                }\n                continue;\n            }\n            is.free();\n            intersect = true;\n            break;\n        }\n    }\n    tempLine.free();\n    return intersect;\n};\n\n\nPolygon2.prototype.intersectsTriangle = function (triangle, ignorePoints) {\n    var tempLine = LineSegment2();\n\n    tempLine.start.copy(triangle.v0);\n    tempLine.end.copy(triangle.v1);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v1);\n    tempLine.end.copy(triangle.v2);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v2);\n    tempLine.end.copy(triangle.v0);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n    return false;\n};\n\nPolygon2.prototype.AABB = function () {\n    var min = this.points[0].clone();\n    var max = this.points[0].clone();\n\n    for (var i = 1; i < this.points.length; i++) {\n        var p = this.points[i];\n        if (p.x < min.x) {\n            min.x = p.x;\n        } else if (p.x > max.x) {\n            max.x = p.x;\n        }\n        if (p.y < min.y) {\n            min.y = p.y;\n        } else if (p.y > max.y) {\n            max.y = p.y;\n        }\n    }\n    return [min, max];\n};\n\n// negative = CCW\nPolygon2.prototype.winding = function () {\n    return this.area() > 0;\n};\n\nPolygon2.prototype.rewind = function (cw) {\n    cw = !!cw;\n    var winding = this.winding();\n    if (winding !== cw) {\n        this.points.reverse();\n    }\n    return this;\n};\n\nPolygon2.prototype.area = function () {\n    var area = 0;\n    var first = this.points[0];\n    var p1 = Vector2();\n    var p2 = Vector2();\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        p1.copy(first).subtract(this.points[i]);\n        p2.copy(first).subtract(this.points[j]);\n        area += p1.cross(p2);\n    }\n    p1.free();\n    p2.free();\n    return area / 2;\n};\n\nPolygon2.prototype.clean = function (distance) {\n    var p1 = Vector2();\n    var newpoints = [];\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var length = p1.copy(this.points[i]).subtract(this.points[j]).length();\n        if (length > distance) {\n            newpoints.push(this.points[i]);\n        } else {\n            this.points[i].free();\n        }\n    }\n    this.points = newpoints;\n};\n\nPolygon2.prototype.toArray = function () {\n    var ret = [];\n    for (var i = 0; i < this.points.length; i++) {\n        ret.push(this.points[i].toArray());\n    }\n    return ret;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\nvar PointNode = require('./pointnode');\n\nfunction BoundsNode(bounds, depth, maxChildren, maxDepth) {\n    PointNode.call(this, bounds, depth, maxChildren, maxDepth);\n    this._stuckChildren = [];\n}\n\nBoundsNode.prototype = new PointNode();\nBoundsNode.prototype._classConstructor = BoundsNode;\nBoundsNode.prototype._stuckChildren = null;\n\n//we use this to collect and conctenate items being retrieved. This way\n//we dont have to continuously create new Array instances.\n//Note, when returned from QuadTree.retrieve, we then copy the array\nBoundsNode.prototype._out = [];\n\nBoundsNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        //todo: make _bounds bounds\n        if (item.x >= node._bounds.x &&\n            item.x + item.width <= node._bounds.x + node._bounds.width &&\n            item.y >= node._bounds.y &&\n            item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            this.nodes[index].insert(item);\n\n        } else {\n            this._stuckChildren.push(item);\n        }\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n\n    if (this._depth < this._maxDepth &&\n        len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nBoundsNode.prototype.getChildren = function () {\n    return this.children.concat(this._stuckChildren);\n};\n\nBoundsNode.prototype.retrieve = function (item) {\n    var out = this._out;\n    out.length = 0;\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        if (item.x >= node._bounds.x &&\n            item.x + item.width <= node._bounds.x + node._bounds.width &&\n            item.y >= node._bounds.y &&\n            item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            out.push.apply(out, this.nodes[index].retrieve(item));\n        } else {\n            //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n            if (item.x <= this.nodes[PointNode.TOP_RIGHT]._bounds.x) {\n                if (item.y <= this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_LEFT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_LEFT].retrieve(item));\n                }\n            }\n\n            if (item.x + item.width > this.nodes[PointNode.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                if (item.y <= this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_RIGHT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_RIGHT].retrieve(item));\n                }\n            }\n        }\n    }\n\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n\n    return out;\n};\n\n//Returns all contents of node.\nBoundsNode.prototype.getAllContent = function () {\n    var out = this._out;\n    if (this.nodes.length) {\n\n        var i;\n        for (i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].getAllContent();\n        }\n    }\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n    return out;\n};\n\nBoundsNode.prototype.clear = function () {\n\n    this._stuckChildren.length = 0;\n\n    //array\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    if (!len) {\n        return;\n    }\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    //array\n    this.nodes.length = 0;\n\n    //we could call the super clear function but for now, im just going to inline it\n    //call the hidden super.clear, and make sure its called with this = this instance\n    //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n};\n\nmodule.exports = BoundsNode;\n","module.exports = {\n    QuadTree: require('./quadtree'),\n    PointNode: require('./pointnode'),\n    BoundsNode: require('./boundsnode')\n};\n","'use strict';\n\nfunction PointNode(bounds, depth, maxDepth, maxChildren) {\n    this._bounds = bounds;\n    this.children = [];\n    this.nodes = [];\n\n    if (maxChildren) {\n        this._maxChildren = maxChildren;\n    }\n\n    if (maxDepth) {\n        this._maxDepth = maxDepth;\n    }\n\n    if (depth) {\n        this._depth = depth;\n    }\n}\n\n//subnodes\nPointNode.prototype.nodes = null;\nPointNode.prototype._classConstructor = PointNode;\n\n//children contained directly in the node\nPointNode.prototype.children = null;\nPointNode.prototype._bounds = null;\n\n//read only\nPointNode.prototype._depth = 0;\n\nPointNode.prototype._maxChildren = 4;\nPointNode.prototype._maxDepth = 4;\n\nPointNode.TOP_LEFT = 0;\nPointNode.TOP_RIGHT = 1;\nPointNode.BOTTOM_LEFT = 2;\nPointNode.BOTTOM_RIGHT = 3;\n\n\nPointNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        this.nodes[index].insert(item);\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n    if (this._depth < this._maxDepth &&\n        len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nPointNode.prototype.retrieve = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        return this.nodes[index].retrieve(item);\n    }\n\n    return this.children;\n};\n\nPointNode.prototype._findIndex = function (item) {\n    var b = this._bounds;\n    var left = (item.x > b.x + b.width / 2) ? false : true;\n    var top = (item.y > b.y + b.height / 2) ? false : true;\n\n    //top left\n    var index = PointNode.TOP_LEFT;\n    if (left) {\n        //left side\n        if (!top) {\n            //bottom left\n            index = PointNode.BOTTOM_LEFT;\n        }\n    } else {\n        //right side\n        if (top) {\n            //top right\n            index = PointNode.TOP_RIGHT;\n        } else {\n            //bottom right\n            index = PointNode.BOTTOM_RIGHT;\n        }\n    }\n\n    return index;\n};\n\n\nPointNode.prototype.subdivide = function () {\n    var depth = this._depth + 1;\n\n    var bx = this._bounds.x;\n    var by = this._bounds.y;\n\n    //floor the values\n    var b_w_h = (this._bounds.width / 2) | 0; //todo: Math.floor?\n    var b_h_h = (this._bounds.height / 2) | 0;\n    var bx_b_w_h = bx + b_w_h;\n    var by_b_h_h = by + b_h_h;\n\n    //top left\n    this.nodes[PointNode.TOP_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n\n    //top right\n    this.nodes[PointNode.TOP_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n\n    //bottom left\n    this.nodes[PointNode.BOTTOM_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n\n\n    //bottom right\n    this.nodes[PointNode.BOTTOM_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n        depth, this._maxDepth, this._maxChildren);\n};\n\nPointNode.prototype.clear = function () {\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    this.nodes.length = 0;\n};\n\n\nmodule.exports = PointNode;\n","'use strict';\n\nvar PointNode = require('./pointnode'),\n    BoundsNode = require('./boundsnode');\n\n/**\n * QuadTree data structure.\n * @class QuadTree\n * @constructor\n * @param {Object} An object representing the bounds of the top level of the QuadTree. The object\n * should contain the following properties : x, y, width, height\n * @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds\n * (width / height)(false). Default value is false.\n * @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n * @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n **/\nfunction QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n    var node;\n    if (pointQuad) {\n        node = new PointNode(bounds, 0, maxDepth, maxChildren);\n    } else {\n        node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n    }\n\n    this.root = node;\n}\n\n/**\n * The root node of the QuadTree which covers the entire area being segmented.\n * @property root\n * @type Node\n **/\nQuadTree.prototype.root = null;\n\n\n/**\n * Inserts an item into the QuadTree.\n * @method insert\n * @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y\n * properties that represents its position in 2D space.\n **/\nQuadTree.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            len = item.length;\n        while (i < len) {\n            this.root.insert(item[i]);\n            i++;\n        }\n    } else {\n        this.root.insert(item);\n    }\n};\n\n/**\n * Clears all nodes and children from the QuadTree\n * @method clear\n **/\nQuadTree.prototype.clear = function () {\n    this.root.clear();\n};\n\n/**\n * Retrieves all items / points in the same node as the specified item / point. If the specified item\n * overlaps the bounds of a node, then all children in both nodes will be returned.\n * @method retrieve\n * @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n * with dimensions (x, y, width, height) properties.\n **/\nQuadTree.prototype.retrieve = function (item) {\n    //get a copy of the array of items\n    return this.root.retrieve(item);\n    // var out = this.root.retrieve(item).slice(0);\n    // return out;\n};\n\nmodule.exports = QuadTree;\n","'use strict';\n/* jshint -W064 */\n\nmodule.exports = Rectangle2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Rectangle2(x, y, width, height) {\n    if (!(this instanceof Rectangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Rectangle2(x || 0, y || 0, width || 0, height || 0);\n            created++;\n        } else {\n            v.set(x, y, width, height);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n    this.width = width || 0;\n    this.height = height || 0;\n}\n\nRectangle2.getStats = function () {\n    return [cache.length, created];\n};\n\nRectangle2.fromArray = function (arr) {\n    return Rectangle2(arr[0] || 0, arr[1] || 0, arr[2] || 0, arr[3] || 0);\n};\n\nRectangle2.fromObject = function (obj) {\n    return Rectangle2(obj.x || 0, obj.y || 0, obj.width || 0, obj.height || 0);\n};\n\nRectangle2.prototype.set = function (x, y, width, height) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.width = width || 0;\n    this.height = height || 0;\n    return this;\n};\n\nRectangle2.prototype.free = function () {\n    cache.push(this);\n};\n\nRectangle2.prototype.translate = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nRectangle2.prototype.intersects = function (r) {\n    return !(this.x + this.width < r.x ||\n    this.y + this.height < r.y ||\n    this.x > r.x + r.width ||\n    this.y > r.y + r.height\n    );\n};\n\nRectangle2.prototype.toString = function () {\n    return 'x: ' + this.x + ', y: ' + this.y + ', width: ' + this.width + ', height: ' + this.height;\n};\n\nRectangle2.prototype.toArray = function () {\n    return [this.x, this.y];\n};\n\nRectangle2.prototype.toObject = function () {\n    return {x: this.x, y: this.y, width: this.width, height: this.height};\n};\n\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2'),\n    Polygon2 = require('./polygon2');\n\nmodule.exports = RegularPolygon2;\n\nfunction RegularPolygon2(radius, sides, center) {\n    center = center || Vector2();\n\n    if (!sides || sides < 2) {\n        sides = 3;\n    }\n    if (!radius || radius <= 0) {\n        radius = 1;\n    }\n\n    var p = Polygon2();\n    for (var i = 0; i < sides; i++) {\n        p.add(Vector2(center.x + radius * Math.cos((i * 2 * Math.PI / sides) + 0.25 * Math.PI), center.y + radius * Math.sin((i * 2 * Math.PI / sides) + 0.25 * Math.PI)));\n    }\n    return p;\n}\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nmodule.exports = Triangle2;\n\nvar epsilon = 0.0000001;\nvar cache = [];\nvar created = 0;\n\nfunction Triangle2(v0, v1, v2) {\n    if (!(this instanceof Triangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Triangle2(v0, v1, v2);\n            created++;\n        } else {\n            v.set(v0, v1, v2);\n            //v.calcCircumcircle();\n        }\n        return v;\n    }\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    /*\n     this.center = Vector2();\n     this.radius = 0;\n     this.radius_squared = 0;\n\n     this.calcCircumcircle();\n     */\n}\n\nTriangle2.getStats = function () {\n    return [cache.length, created];\n};\n\nTriangle2.prototype.free = function () {\n    cache.push(this);\n};\n\n\nTriangle2.prototype.set = function (v0, v1, v2) {\n    this.v0.free();\n    this.v1.free();\n    this.v2.free();\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    return this;\n};\n\nTriangle2.prototype.translate = function (vec) {\n    this.v0.add(vec);\n    this.v1.add(vec);\n    this.v2.add(vec);\n    return this;\n};\n\nTriangle2.prototype.calcCircumcircle = function () {\n    // From: http://www.exaflop.org/docs/cgafaq/cga1.html\n\n    var A = this.v1.x - this.v0.x;\n    var B = this.v1.y - this.v0.y;\n    var C = this.v2.x - this.v0.x;\n    var D = this.v2.y - this.v0.y;\n\n    var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);\n    var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);\n\n    var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));\n\n    var dx, dy;\n\n    if (Math.abs(G) < epsilon) {\n        // Collinear - find extremes and use the midpoint\n\n        var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);\n        var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);\n        var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);\n        var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);\n\n        this.center.set((minx + maxx) / 2, (miny + maxy) / 2);\n\n        dx = this.center.x - minx;\n        dy = this.center.y - miny;\n    } else {\n        var cx = (D * E - B * F) / G;\n        var cy = (A * F - C * E) / G;\n\n        this.center.set(cx, cy);\n\n        dx = this.center.x - this.v0.x;\n        dy = this.center.y - this.v0.y;\n    }\n\n    this.radius_squared = dx * dx + dy * dy;\n    this.radius = Math.sqrt(this.radius_squared);\n};\n\nTriangle2.prototype.inCircumcircle = function (v) {\n    var dx = this.center.x - v.x;\n    var dy = this.center.y - v.y;\n    var dist_squared = dx * dx + dy * dy;\n\n    return (dist_squared <= this.radius_squared);\n};\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\nmodule.exports = Vector2;\n\nvar epsilon = 0.0000001;\nvar degrees = 180 / Math.PI;\n\nvar cache = [];\nvar created = 0;\n\nfunction Vector2(x, y) {\n    if (!(this instanceof Vector2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Vector2(x || 0, y || 0);\n            created++;\n        } else {\n            v.set(x, y);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n}\n\nVector2.warmup = function (amount) {\n    while (amount--) {\n        new Vector2().free();\n    }\n};\n\nVector2.getStats = function () {\n    return [cache.length, created];\n};\n\nVector2.fromArray = function (arr) {\n    return Vector2(arr[0] || 0, arr[1] || 0);\n};\n\nVector2.fromObject = function (obj) {\n    return Vector2(obj.x || 0, obj.y || 0);\n};\n\nVector2.prototype.set = function (x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n};\n\nVector2.prototype.free = function () {\n    cache.push(this);\n};\n\nVector2.prototype.add = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nVector2.prototype.addScalar = function (scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    return this;\n};\n\n\nVector2.prototype.subtract = function (vec) {\n    this.x -= vec.x;\n    this.y -= vec.y;\n    return this;\n};\n\nVector2.prototype.subtractScalar = function (scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n};\n\n\nVector2.prototype.divide = function (vec) {\n    this.x /= vec.x;\n    this.y /= vec.y;\n    return this;\n};\n\nVector2.prototype.multiply = function (vec) {\n    this.x *= vec.x;\n    this.y *= vec.y;\n    return this;\n};\n\nVector2.prototype.multiplyScalar = function (scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n};\n\nVector2.prototype.normalize = function () {\n    var length = this.length();\n\n    if (length === 0) {\n        this.x = 0;\n        this.y = 0;\n    } else {\n        this.x /= length;\n        this.y /= length;\n    }\n    return this;\n};\n\nVector2.prototype.clone = function () {\n    return Vector2(this.x, this.y);\n};\n\nVector2.prototype.copy = function (vec) {\n    this.x = vec.x;\n    this.y = vec.y;\n    return this;\n};\n\nVector2.prototype.zero = function () {\n    this.x = this.y = 0;\n    return this;\n};\n\nVector2.prototype.dot = function (vec) {\n    return this.x * vec.x + this.y * vec.y;\n};\n\nVector2.prototype.cross = function (vec) {\n    return (this.x * vec.y ) - (this.y * vec.x );\n};\n\nVector2.prototype.projectOnto = function (vec) {\n    var coeff = ( (this.x * vec.x) + (this.y * vec.y) ) / ((vec.x * vec.x) + (vec.y * vec.y));\n    this.x = coeff * vec.x;\n    this.y = coeff * vec.y;\n    return this;\n};\n\nVector2.prototype.setAngle = function (rad) {\n    var len = this.length();\n    this.x = Math.cos(rad) * len;\n    this.y = Math.sin(rad) * len;\n};\n\nVector2.prototype.horizontalAngle = function () {\n    return Math.atan2(this.y, this.x);\n};\n\nVector2.prototype.horizontalAngleDeg = function () {\n    return radian2degrees(this.horizontalAngle());\n};\n\nVector2.prototype.verticalAngle = function () {\n    return Math.atan2(this.x, this.y);\n};\n\nVector2.prototype.verticalAngleDeg = function () {\n    return radian2degrees(this.verticalAngle());\n};\n\nVector2.prototype.angle = Vector2.prototype.horizontalAngle;\nVector2.prototype.angleDeg = Vector2.prototype.horizontalAngleDeg;\nVector2.prototype.direction = Vector2.prototype.horizontalAngle;\n\nVector2.prototype.rotate = function (angle, origin) {\n    var ox = 0,\n        oy = 0;\n    if (origin) {\n        ox = origin.x || 0;\n        oy = origin.y || 0;\n    }\n\n    var nx = ox + (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));\n    var ny = oy + (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));\n\n    this.x = nx;\n    this.y = ny;\n\n    return this;\n};\n\nVector2.prototype.rotateDeg = function (angle) {\n    angle = degrees2radian(angle);\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateBy = function (rotation) {\n    var angle = this.angle() + rotation;\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateByDeg = function (rotation) {\n    rotation = degrees2radian(rotation);\n    return this.rotateBy(rotation);\n};\n\nVector2.prototype.distance = function (vec) {\n    return Math.sqrt(this.distanceSq(vec));\n};\n\nVector2.prototype.distanceSq = function (vec) {\n    var dx = this.x - vec.x,\n        dy = this.y - vec.y;\n    return dx * dx + dy * dy;\n};\n\nVector2.prototype.length = function () {\n    return Math.sqrt(this.lengthSq());\n};\n\nVector2.prototype.lengthSq = function () {\n    return this.x * this.x + this.y * this.y;\n};\n\nVector2.prototype.magnitude = Vector2.prototype.length;\n\nVector2.prototype.isZero = function () {\n    return this.x === 0 && this.y === 0;\n};\nVector2.prototype.isEqualTo = function (vec) {\n    return this.x === vec.x && this.y === vec.y;\n};\n\nVector2.prototype.isEqualEpsilon = function (vec) {\n    return Math.abs(this.x - vec.x) < epsilon && Math.abs(this.y - vec.y) < epsilon;\n};\n\nVector2.prototype.toString = function () {\n    return 'x: ' + this.x + ', y: ' + this.y;\n};\n\nVector2.prototype.toArray = function () {\n    return [this.x, this.y];\n};\n\nVector2.prototype.toObject = function () {\n    return {x: this.x, y: this.y};\n};\n\nfunction radian2degrees(rad) {\n    return rad * degrees;\n}\n\nfunction degrees2radian(deg) {\n    return deg / degrees;\n}\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\n/*\n Based upon https://code.google.com/p/visibility-polygon-js/\n Made by Byron Knoll in 2013/2014.\n */\n\nvar Polygon2 = require('./polygon2'),\n    Vector2 = require('./vector2'),\n    LineSegment2 = require('./linesegment2');\n\nvar PI = Math.PI;\nvar PI2 = PI * 2;\nvar PImin = -1 * PI;\nvar epsilon = 0.0000001;\n\nvar segmentIter = ['start', 'end'];\nfunction pointsorter(a, b) {\n    return a[2] - b[2];\n}\n\nmodule.exports = VisibilityPolygon;\n\nfunction VisibilityPolygon(segments) {\n    this.polygon = Polygon2();\n    this.segments = segments;\n    this.heap = [];\n    this.map = new Array(this.segments.length);\n    this.points = new Array(this.segments.length * 2);\n    this.position = Vector2();\n}\n\nVisibilityPolygon.prototype.angle = function (p1, p2) {\n    var p = p2.clone().subtract(p1);\n    var a = p.angle();\n    p.free();\n    return a;\n};\n\nVisibilityPolygon.prototype.angle2 = function (a, b, c) {\n    var a1 = this.angle(a, b);\n    var a2 = this.angle(b, c);\n    var a3 = a1 - a2;\n    if (a3 < 0) {\n        a3 += PI2;\n    }\n    if (a3 > PI2) {\n        a3 -= PI2;\n    }\n    return a3;\n};\n\n\nVisibilityPolygon.prototype.compute = function (position) {\n    this.position.copy(position);\n    this.reset();\n    this.sortPoints();\n\n    var start = this.position.clone();\n    start.x += 1; // why?\n\n    var i = 0,\n        n = this.segments.length;\n    while (i < n) {\n        var a1 = this.angle(this.segments[i].start, this.position);\n        var a2 = this.angle(this.segments[i].end, this.position);\n        if (\n            ( a1 > PImin && a1 <= 0 && a2 <= PI && a2 >= 0 && a2 - a1 > PI) ||\n            (a2 > PImin && a2 <= 0 && a1 <= PI && a1 >= 0 && a1 - a2 > PI)\n        ) {\n            this.insert(i, start);\n        }\n        i += 1;\n    }\n    i = 0;\n    n = this.segments.length * 2;\n    while (i < n) {\n        var extend = false;\n        var shorten = false;\n        var orig = i;\n        var vertex = this.segments[this.points[i][0]][this.points[i][1]];\n        var old_segment = this.heap[0];\n        do {\n            if (this.map[this.points[i][0]] !== -1) {\n                if (this.points[i][0] === old_segment) {\n                    extend = true;\n                    vertex = this.segments[this.points[i][0]][this.points[i][1]];\n                }\n                this.remove(this.map[this.points[i][0]], vertex);\n            } else {\n                this.insert(this.points[i][0], vertex);\n                if (this.heap[0] !== old_segment) {\n                    shorten = true;\n                }\n            }\n            ++i;\n            if (i === n) {\n                break;\n            }\n        } while (this.points[i][2] < this.points[orig][2] + epsilon);\n\n        var l = LineSegment2(position.clone(), vertex.clone());\n        if (extend) {\n            this.polygon.add(vertex.clone());\n            var cur = this.segments[this.heap[0]].intersect(l, true);\n            if (cur) {\n                if (!cur.isEqualEpsilon(vertex)) {\n                    this.polygon.add(cur);\n                } else {\n                    cur.free();\n                }\n            }\n        } else if (shorten) {\n            this.polygon.add(this.segments[old_segment].intersect(l, true));\n            this.polygon.add(this.segments[this.heap[0]].intersect(l, true));\n        }\n    }\n    return this.polygon;\n};\n\n\nVisibilityPolygon.prototype.insert = function (index, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var intersect = this.segments[index].intersect(l, true);\n    if (intersect === false) {\n        l.free();\n        return;\n    }\n    intersect.free();\n\n    var cur = this.heap.length;\n    this.heap.push(index);\n    this.map[index] = cur;\n    while (cur > 0) {\n        var parent = this.parent(cur);\n        if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n            break;\n        }\n        this.map[this.heap[parent]] = cur;\n        this.map[this.heap[cur]] = parent;\n        var temp = this.heap[cur];\n        this.heap[cur] = this.heap[parent];\n        this.heap[parent] = temp;\n        cur = parent;\n    }\n};\n\nVisibilityPolygon.prototype.remove = function (index, destination) {\n    this.map[this.heap[index]] = -1;\n    if (index === this.heap.length - 1) {\n        this.heap.pop();\n        return;\n    }\n    this.heap[index] = this.heap.pop();\n    this.map[this.heap[index]] = index;\n    var cur = index;\n    var parent = this.parent(cur);\n    if (cur !== 0 && this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n        while (cur > 0) {\n            parent = this.parent(cur);\n            if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n                break;\n            }\n            this.swap(cur, parent);\n            cur = parent;\n        }\n    } else {\n        while (true) {\n            var left = this.child(cur);\n            var right = left + 1;\n            if (left < this.heap.length && this.lessThan(this.heap[left], this.heap[cur], destination) &&\n                (right === this.heap.length || this.lessThan(this.heap[left], this.heap[right], destination))) {\n                this.swap(cur, left);\n                cur = left;\n            } else if (right < this.heap.length && this.lessThan(this.heap[right], this.heap[cur], destination)) {\n                this.swap(cur, right);\n                cur = right;\n            } else {\n                break;\n            }\n        }\n    }\n};\n\n\nVisibilityPolygon.prototype.lessThan = function (index1, index2, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var inter1 = this.segments[index1].intersect(l, true);\n    var inter2 = this.segments[index2].intersect(l, true);\n    if (!inter1.isEqualEpsilon(inter2)) {\n        var d1 = inter1.distanceSq(this.position);\n        var d2 = inter2.distanceSq(this.position);\n        inter1.free();\n        inter2.free();\n        l.free();\n        return d1 < d2;\n    }\n    var end1 = this.segments[index1].start;\n    if (inter1.isEqualEpsilon(this.segments[index1].start)) {\n        end1 = this.segments[index1].end;\n    }\n    var end2 = this.segments[index2].start;\n    if (inter2.isEqualEpsiolon(this.segments[index2].start)) {\n        end2 = this.segments[index2].end;\n    }\n    var a1 = this.angle2(end1, inter1, this.position);\n    var a2 = this.angle2(end2, inter2, this.position);\n    inter1.free();\n    inter2.free();\n    if (a1 < PI) {\n        if (a2 > PI) {\n            return true;\n        }\n        return a2 < a1;\n    }\n    return a1 < a2;\n};\n\nVisibilityPolygon.prototype.parent = function (index) {\n    return Math.floor((index - 1) / 2);\n};\n\nVisibilityPolygon.prototype.child = function (index) {\n    return 2 * index + 1;\n};\n\nVisibilityPolygon.prototype.swap = function (c, l) {\n    this.map[this.heap[l]] = c;\n    this.map[this.heap[c]] = l;\n    var temp = this.heap[l];\n    this.heap[l] = this.heap[c];\n    this.heap[c] = temp;\n};\n\n\nVisibilityPolygon.prototype.sortPoints = function () {\n    var i = 0,\n        n = this.segments.length,\n        p = null,\n        pp = Vector2();\n    while (i < n) {\n        for (var j = 0; j < 2; ++j) {\n            if (j === 0) {\n                p = this.segments[i][segmentIter[j]];\n            } else {\n                p = this.segments[i][segmentIter[j]];\n            }\n            pp.copy(this.position).subtract(p);\n            var nr = 2 * i + j;\n            if (this.points[nr]) {\n                this.points[nr][0] = i;\n                this.points[nr][1] = segmentIter[j];\n                this.points[nr][2] = pp.angle();\n            } else {\n                this.points[nr] = [i, segmentIter[j], pp.angle()];\n            }\n        }\n        i += 1;\n    }\n    pp.free();\n    this.points = this.points.sort(pointsorter);\n};\n\nVisibilityPolygon.prototype.reset = function () {\n    this.polygon.freePoints();\n    var i = 0,\n        n = this.map.length;\n    while (i < n) {\n        this.map[i] = -1;\n        i += 1;\n    }\n    while (this.heap.length > 0) {\n        this.heap.pop();\n    }\n};\n/* jshint +W064 */\n","var core = {};\n\n\ncore.geometry = require('./geometry');\ncore.linkedlist = require('./linkedlist');\ncore.procedural = require('./procedural');\ncore.timer = require('./timer');\ncore.input = require('./input');\ncore.game = require('./game');\n\nmodule.exports = core;\n\nglobal.ULTRON = core;\n","module.exports = {\n    Unified: require('./unified')\n};\n","//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\n// taken from game-shell\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif (window.addEventListener) {\n    _addEventListener = \"addEventListener\";\n} else {\n    _addEventListener = \"attachEvent\";\n    prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n    document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n        \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener(elem, eventName, callback, useCapture) {\n    elem[_addEventListener](prefix + eventName, support === \"wheel\" ? callback : function (originalEvent) {\n        !originalEvent && ( originalEvent = window.event );\n\n        // create a normalized event object\n        var event = {\n            // keep a ref to the original event object\n            originalEvent: originalEvent,\n            target: originalEvent.target || originalEvent.srcElement,\n            type: \"wheel\",\n            deltaMode: originalEvent.type === \"MozMousePixelScroll\" ? 0 : 1,\n            deltaX: 0,\n            delatZ: 0,\n            preventDefault: function () {\n                originalEvent.preventDefault ?\n                    originalEvent.preventDefault() :\n                    originalEvent.returnValue = false;\n            }\n        };\n\n        // calculate deltaY (and deltaX) according to the event\n        if (support === \"mousewheel\") {\n            event.deltaY = -1 / 40 * originalEvent.wheelDelta;\n            // Webkit also support wheelDeltaX\n            originalEvent.wheelDeltaX && ( event.deltaX = -1 / 40 * originalEvent.wheelDeltaX );\n        } else {\n            event.deltaY = originalEvent.detail;\n        }\n\n        // it's time to fire the callback\n        return callback(event);\n    }, useCapture || false);\n}\n\nmodule.exports = function (elem, callback, useCapture) {\n    _addWheelListener(elem, support, callback, useCapture);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (support === \"DOMMouseScroll\") {\n        _addWheelListener(elem, \"MozMousePixelScroll\", callback, useCapture);\n    }\n};\n","'use strict';\n\n// taken from https://github.com/andyhall/game-inputs\n\nvar vkey = require('vkey');\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\nvar EventEmitter = require('eventemitter3');\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = require('./mousewheel-polyfill');\n\nmodule.exports = Inputs;\n\n// map button index to name\nvar gamepadButtonNames = [\n    'a',\n    'b',\n    'x',\n    'y',\n    'left-shoulder',\n    'right-shoulder',\n    'left-trigger',\n    'right-trigger',\n    'select',\n    'start',\n    'left-stick',\n    'right-stick',\n    'dpad-up',\n    'dpad-down',\n    'dpad-left',\n    'dpad-right'\n];\nvar gamepadAxesNames = [\n    'left-stick-x',\n    'left-stick-y',\n    'right-stick-x',\n    'right-stick-y'\n];\nvar hasGamepadEvents = 'GamepadEvent' in window;\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from)\n *        game-shell: https://github.com/mikolalysenko/game-shell\n *\n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *\n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n */\n\n\nfunction Inputs(element, opts) {\n\n    // settings\n    this.element = element || document;\n    opts = opts || {};\n    this.preventDefaults = !!opts.preventDefaults;\n    this.stopPropagation = !!opts.stopPropagation;\n\n    // emitters\n    this.down = new EventEmitter();\n    this.up = new EventEmitter();\n    this.gamepadconnected = new EventEmitter();\n    this.gamepaddisconnected = new EventEmitter();\n\n    // state object to be queried\n    this.state = {\n        dx: 0, dy: 0,\n        scrollx: 0, scrolly: 0, scrollz: 0\n    };\n\n    // internal state\n    this._keybindmap = {};       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n    this._keyStates = {};        // { 'vkeycode' : boolean }\n    this._bindPressCounts = {};  // { 'binding' : int }\n    this._gamepads = {}; // { 'index' : gamepad }\n    this._gamepadButtonStates = {}; // { 'vcode' : int }\n\n    // raf handle\n    this._gamepadRaf = false;\n\n    // register for dom events\n    this.initEvents();\n}\n\n\n/*\n *\n *   PUBLIC API\n *\n */\n\nInputs.prototype.initEvents = function () {\n    // keys\n    window.addEventListener('keydown', onKeyEvent.bind(undefined, this, true), false);\n    window.addEventListener('keyup', onKeyEvent.bind(undefined, this, false), false);\n    // mouse buttons\n    this.element.addEventListener('mousedown', onMouseEvent.bind(undefined, this, true), false);\n    this.element.addEventListener('mouseup', onMouseEvent.bind(undefined, this, false), false);\n    this.element.oncontextmenu = onContextMenu.bind(undefined, this);\n    // mouse other\n    this.element.addEventListener('mousemove', onMouseMove.bind(undefined, this), false);\n    addMouseWheel(this.element, onMouseWheel.bind(undefined, this), false);\n\n    // gamepads\n    if (hasGamepadEvents) {\n        window.addEventListener('gamepadconnected', onGamepadConnected.bind(undefined, this), false);\n        window.addEventListener('gamepaddisconnected', onGamepadDisconnected.bind(undefined, this), false);\n    } else {\n        window.setInterval(scanGamepads.bind(undefined, this), 500);\n    }\n};\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function (binding) {\n    for (var i = 1; i < arguments.length; ++i) {\n        var vkeyCode = arguments[i];\n        var arr = this._keybindmap[vkeyCode] || [];\n        if (arr.indexOf(binding) === -1) {\n            arr.push(binding);\n        }\n        this._keybindmap[vkeyCode] = arr;\n    }\n    this.state[binding] = !!this.state[binding];\n};\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function (binding) {\n    for (var b in this._keybindmap) {\n        var arr = this._keybindmap[b];\n        var i = arr.indexOf(binding);\n        if (i > -1) {\n            arr.splice(i, 1);\n        }\n    }\n};\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function () {\n    this.state['mouse-dx'] = this.state['mouse-dy'] = 0;\n    this.state['mouse-scrollx'] = this.state['mouse-scrolly'] = this.state['mouse-scrollz'] = 0;\n};\n\n\nInputs.prototype.getBoundKeys = function () {\n    var arr = [];\n    for (var b in this._keybindmap) {\n        arr.push(b);\n    }\n    return arr;\n};\n\n\n/*\n *   INTERNALS - DOM EVENT HANDLERS\n */\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n    handleKeyEvent(ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev);\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n    // simulate a code out of range of vkey\n    var keycode = -1 - ev.button;\n    var vkeycode = '<mouse ' + (ev.button + 1) + '>';\n    handleKeyEvent(keycode, vkeycode, wasDown, inputs, ev);\n    return false;\n}\n\nfunction onContextMenu(inputs) {\n    // cancel context menu if there's a binding for right mousebutton\n    var arr = inputs._keybindmap['<mouse 3>'];\n    if (arr) {\n        return false;\n    }\n}\n\nfunction onMouseMove(inputs, ev) {\n    // for now, just populate the state object with mouse movement\n    var dx = ev.movementX || ev.mozMovementX || ev.webkitMovementX || 0,\n        dy = ev.movementY || ev.mozMovementY || ev.webkitMovementY || 0;\n    inputs.state['mouse-dx'] += dx;\n    inputs.state['mouse-dy'] += dy;\n    // TODO: verify if this is working/useful during pointerlock?\n}\n\nfunction onMouseWheel(inputs, ev) {\n    // basically borrowed from game-shell\n    var scale = 1;\n    switch (ev.deltaMode) {\n        case 0:\n            scale = 1;\n            break;  // Pixel\n        case 1:\n            scale = 12;\n            break;  // Line\n        case 2:  // page\n            // TODO: investigagte when this happens, what correct handling is\n            scale = inputs.element.clientHeight || window.innerHeight;\n            break;\n    }\n    // accumulate state\n    inputs.state['mouse-scrollx'] += ev.deltaX * scale;\n    inputs.state['mouse-scrolly'] += ev.deltaY * scale;\n    inputs.state['mouse-scrollz'] += (ev.deltaZ * scale) || 0;\n    return false;\n}\n\n\n/*\n *   KEY BIND HANDLING\n */\n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n    var arr = inputs._keybindmap[vcode];\n    // don't prevent defaults if there's no binding\n    if (!arr) {\n        return;\n    }\n    if (inputs.preventDefaults) {\n        ev.preventDefault();\n    }\n    if (inputs.stopPropagation) {\n        ev.stopPropagation();\n    }\n\n    // if the key's state has changed, handle an event for all bindings\n    var currstate = inputs._keyStates[keycode];\n    if (XOR(currstate, wasDown)) {\n        // for each binding: emit an event, and update cached state information\n        for (var i = 0; i < arr.length; ++i) {\n            handleBindingEvent(arr[i], wasDown, inputs, ev);\n        }\n    }\n    inputs._keyStates[keycode] = wasDown;\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n    // keep count of presses mapped by binding\n    // (to handle two keys with the same binding pressed at once)\n    var ct = inputs._bindPressCounts[binding] || 0;\n    ct += wasDown ? 1 : -1;\n    if (ct < 0) {\n        ct = 0;\n    } // shouldn't happen\n    inputs._bindPressCounts[binding] = ct;\n\n    // emit event if binding's state has changed\n    var currstate = inputs.state[binding];\n    if (XOR(currstate, ct)) {\n        var emitter = wasDown ? inputs.down : inputs.up;\n        emitter.emit(binding, binding, ev);\n    }\n    inputs.state[binding] = !!ct;\n}\n\n/**\n Gamepad HANDLERS\n */\n\nfunction handleGamePadButtonEvent(val, vcode, inputs) {\n    var arr = inputs._keybindmap[vcode];\n    if (!arr) {\n        return;\n    }\n\n    var pressed = val === 1.0;\n    var isPerc = false;\n    if (typeof(val) === 'object') {\n        pressed = val.pressed;\n        val = val.value;\n        isPerc = true;\n        inputs.state[vcode] = val;\n    } else {\n        var currstate = inputs._buttonStates[vcode];\n        if (XOR(currstate, val)) {\n            var i = 0;\n            for (i = 0; i < arr.length; ++i) {\n                handleBindingEvent(arr[i], pressed, inputs, null); // pass null as fake event\n            }\n        }\n    }\n}\n\nfunction updateGamepads(inputs) {\n    var found = scanGamepads(inputs);\n    if (!found) {\n        if (inputs._gamepadRaf) {\n            cancel(inputs._gamepadRaf);\n            inputs._gamepadRaf = false;\n        }\n        return;\n    }\n\n    var vcode = '';\n    for (var j in inputs._gamepads) {\n        var gamepad = inputs._gamepads[j];\n\n        for (var i = 0; i < gamepad.buttons.length; i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadButtonNames[i] + '>';\n            handleGamePadButtonEvent(gamepad.buttons[i], vcode, inputs);\n        }\n\n        for (i = 0; i < gamepad.axes.length; i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadAxesNames[i] + '>';\n            inputs.state[vcode] = gamepad.axes[i];\n        }\n    }\n    inputs._gamepadRaf = request(updateGamepads);\n}\n\nfunction onGamepadConnected(inputs, ev) {\n    addGamepad(inputs, ev.gamepad);\n}\n\nfunction onGamepadDisconnected(inputs, ev) {\n    removeGamepad(inputs, ev.gamepad);\n}\n\n\nfunction addGamepad(inputs, gamepad) {\n    inputs._gamepads[gamepad.index] = gamepad;\n    inputs.gamepadconnected.emit(gamepad);\n    if (!inputs._gamepadRaf) {\n        inputs._gamepadRaf = request(updateGamepads);\n    }\n}\n\nfunction removeGamepad(inputs, gamepad) {\n    delete inputs._gamepads[gamepad.index];\n    inputs.gamepaddisconnected.emit(gamepad);\n    for (var j in inputs._gamepads) {\n        if (inputs._gamepads.hasOwnProperty(j)) {\n            return;\n        }\n    }\n    if (inputs._gamepadRaf) {\n        cancel(inputs._gamepadRaf);\n        inputs._gamepadRaf = false;\n    }\n}\n\n\nfunction scanGamepads(inputs) {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n    var found = false;\n    for (var i = 0; i < gamepads.length; i++) {\n        if (gamepads[i]) {\n            found = true;\n            if (!(gamepads[i].index in inputs._gamepads)) {\n                addGamepad(inputs, gamepads[i]);\n            } else {\n                inputs._gamepads[gamepads[i].index] = gamepads[i];\n            }\n        }\n    }\n    return found;\n}\n\n/*\n *    HELPERS\n *\n */\n\n\n// how is this not part of Javascript?\nfunction XOR(a, b) {\n    return a ? !b : b;\n}\n","/*\n * Doubly Linked List implementation in JavaScript\n * Copyright (c) 2009 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*\n * Optimizations and data reuse by Wouter Commandeur\n */\n\n'use strict';\n\n/**\n * A linked list implementation in JavaScript.\n * @class DoublyLinkedList\n * @constructor\n */\nfunction DoublyLinkedList() {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    this._head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    this._tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type int\n     * @private\n     */\n    this._length = 0;\n\n    this._nodeCache = [];\n\n}\n\nDoublyLinkedList.prototype = {\n\n    //restore constructor\n    constructor: DoublyLinkedList,\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {variant} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    add: function (data) {\n        //create a new item object, place data in\n        var node = this._allocate(data);\n\n        //special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n        } else {\n            //attach to the tail node\n            this._tail.next = node;\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        //don't forget to update the count\n        this._length++;\n\n    },\n\n\n    set: function (index, data) {\n        // update data at index\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while (i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while (i++ < index) {\n                    current = current.next;\n                }\n            }\n            current.data = data;\n        }\n    },\n\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {int} index The zero-based index of the item whose value\n     *      should be returned.\n     * @return {variant} The value in the \"data\" portion of the given item\n     *      or null if the item doesn't exist.\n     * @method item\n     */\n    item: function (index) {\n\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while (i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while (i++ < index) {\n                    current = current.next;\n                }\n            }\n            return current.data;\n        } else {\n            return null;\n        }\n    },\n\n    pop: function () {\n        return this.remove(this._length - 1);\n    },\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {variant} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    remove: function (index) {\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length) {\n\n            var current = this._head,\n                i = 0;\n\n            //special case: removing first item\n            if (index === 0) {\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head) {\n                    this._tail = null;\n                } else {\n                    this._head.prev = null;\n                }\n\n                //special case: removing last item\n            } else if (index === this._length - 1) {\n                current = this._tail;\n                this._tail = current.prev;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while (i++ < index) {\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.prev.next = current.next;\n            }\n\n            //decrement the length\n            this._length--;\n\n            // release into object pool\n            this._free(current);\n\n            //return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    },\n\n    clear: function () {\n        while (this._length > 0) {\n            this.remove(0);\n        }\n    },\n\n    /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    size: function () {\n        return this._length;\n    },\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    toArray: function () {\n        var result = [],\n            current = this._head;\n\n        while (current) {\n            result.push(current.data);\n            current = current.next;\n        }\n\n        return result;\n    },\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    toString: function () {\n        return this.toArray().toString();\n    },\n\n    _free: function (node) {\n        this._nodeCache.push(node);\n    },\n\n    _allocate: function (data) {\n        var node = this._nodeCache.pop();\n        if (!node) {\n            node = {};\n        }\n        node.data = data;\n        node.prev = null;\n        node.next = null;\n        return node;\n    }\n};\n\nmodule.exports = DoublyLinkedList;\n","module.exports = {\n    DoublyLinkedList: require('./doublylinkedlist')\n};\n","'use strict';\n\n/* jshint -W064 */\nvar RegularPolygon2 = require('../../geometry/regularpolygon2');\nvar Polygon2 = require('../../geometry/polygon2');\nvar Vector2 = require('../../geometry/vector2');\nvar LineSegment2 = require('../../geometry/linesegment2');\nvar gpc = require('../../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('../graph');\n\nmodule.exports = Building;\n\nvar createPoly = function (points) {\n    var res = new gpc.geometry.PolyDefault();\n    for (var i = 0; i < points.length; i++) {\n        res.addPoint(new gpc.geometry.Point(points[i][0], points[i][1]));\n    }\n    return res;\n};\n\nvar getPolygonVertices = function (poly) {\n    var vertices = [];\n    var numPoints = poly.getNumPoints();\n    var i;\n\n    for (i = 0; i < numPoints; i++) {\n        vertices.push([poly.getX(i), poly.getY(i)]);\n    }\n    return vertices;\n};\n\nfunction Building(chance, iterations, minRadius, maxRadius, maxSides, noRotate) {\n    var end, l;\n    this.centers = [];\n    iterations = iterations || 1;\n//\tif ( iterations < 3 ) {\n//\t\titerations = 3;\n//\t}\n    maxSides = maxSides || 6;\n    if (maxSides < 4) {\n        maxSides = 4;\n    }\n    var sidesChanceObj = {min: 4, max: maxSides};\n    var radiusChanceObj = {min: minRadius, max: maxRadius};\n\n    var sides = chance.integer(sidesChanceObj);\n    var polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n    var gpcPoly = createPoly(polygon.toArray());\n    polygon.free();\n    var vec, gpcPoly2, num;\n    this.centers.push(Vector2());\n\n    for (var i = 1; i < iterations; i++) {\n        // new random polygon\n        sides = chance.integer(sidesChanceObj);\n        polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\n        // rotate random\n        if (!noRotate) {\n            polygon.rotate(chance.floating({min: 0, max: 2 * Math.PI / sides}));\n        }\n\n        // random point on prev poly\n        num = chance.integer({min: 0, max: gpcPoly.getNumPoints() - 1});\n        vec = Vector2(gpcPoly.getX(num), gpcPoly.getY(num));\n        this.centers.push(vec);\n\n        // center the polygon on a random point of the previous polygon\n        polygon.translate(vec);\n        gpcPoly2 = createPoly(polygon.toArray());\n        gpcPoly = gpcPoly.union(gpcPoly2);\n\n        // free our stuff for reuse\n        polygon.free();\n    }\n    var arr = getPolygonVertices(gpcPoly);\n\n    // generate final polygon\n    polygon = Polygon2.fromArray(arr);\n    this.polygon = polygon;\n\n    // this.polygon.clean(30);\n\n    // add outer doors\n    var nrdoors = Math.ceil(iterations / 2);\n    this.doors = [];\n\n    var nr;\n    var dooredges = {};\n    for (i = 0; i < nrdoors; i++) {\n        nr = chance.integer({min: 0, max: this.polygon.points.length - 1});\n        while (dooredges[nr]) {\n            nr = chance.integer({min: 0, max: this.polygon.points.length - 1});\n        }\n        dooredges[nr] = true;\n        end = nr + 1;\n        if (end === this.polygon.points.length) {\n            end = 0;\n        }\n        l = LineSegment2(this.polygon.points[nr].clone(), this.polygon.points[end].clone());\n        var p2 = l.end.clone();\n        var p1 = l.start.clone();\n        var length = l.length(); // p2.subtract(l.start).length();\n        p2.subtract(l.start).normalize().multiplyScalar(length / 2);\n        p1.add(p2);\n        // this.centers.push(p1);\n        this.doors.push(p1);\n        p2.free();\n        l.free();\n    }\n\n\n    var c = [];\n    for (i = 0; i < this.centers.length; i++) {\n        c.push(this.centers[i].toArray());\n    }\n\n    this.graph = new Graph();\n    this.delaunay_used = {};\n\n    // delaunay the centers\n    this.delaunay = Delaunay.triangulate(c);\n\n    for (i = 0; i < this.delaunay.length; i += 1) {\n        if (!this.delaunay_used[this.delaunay[i]]) {\n            this.graph.addNode(this.delaunay[i]);\n            this.delaunay_used[this.delaunay[i]] = true;\n        }\n    }\n\n\n    this.delaunay_exists = {};\n\n    this.delaunay_triangles = [];\n    this.delaunay_lines = [];\n    for (i = 0; i < this.delaunay.length; i += 3) {\n        // line 1\n        this.addDelaunayLine(i, i + 1);\n        this.addDelaunayLine(i + 1, i + 2);\n        this.addDelaunayLine(i + 2, i);\n    }\n\n    // connect the doors;\n    nr = this.centers.length;\n    for (i = 0; i < this.doors.length; i++) {\n        this.connectDoor(this.doors[i], nr);\n    }\n\n\n    // calculate the minimal spanning tree\n    var edges = this.graph.prim(); // Prim(this.graph);\n    // console.log(edges);\n    this.mst_lines = [];\n\n    for (i = 0; i < edges.length; i++) {\n        var start = edges[i].source;\n        end = edges[i].sink;\n        l = LineSegment2(this.centers[start].clone(), this.centers[end].clone());\n        this.mst_lines.push(l);\n        //var l = LineSegment2()\n    }\n\n\n    this.outside = this.polygon.AABB();\n\n    this.outside[0].subtractScalar(50);\n    this.outside[1].addScalar(50);\n\n}\n\nBuilding.prototype.connectDoor = function (door, nr) {\n    var min = 9999999;\n    var l, d;\n    var point = false;\n    for (var i = 0; i < nr; i++) {\n        l = LineSegment2(this.centers[i].clone(), door.clone());\n        if (!this.polygon.intersectsLine(l, true)) {\n            d = l.length();\n            if (d < min) {\n                min = d;\n                point = i;\n            }\n        }\n        l.free();\n    }\n    if (point !== false) {\n        this.centers.push(door.clone());\n        this.graph.addNode(this.centers.length - 1);\n        this.graph.addEdge(point, this.centers.length - 1, min);\n        this.delaunay_lines.push(LineSegment2(this.centers[point].clone(), door.clone()));\n    } else {\n        l.free();\n    }\n\n};\n\nBuilding.prototype.addDelaunayLine = function (start, end) {\n    var key1 = start + ':' + end;\n    var key2 = end + ':' + start;\n    if (this.delaunay_exists[key1] || this.delaunay_exists[key2]) {\n        return;\n    }\n    this.delaunay_exists[key1] = true;\n    this.delaunay_exists[key2] = true;\n    var l = LineSegment2(this.centers[this.delaunay[start]].clone(), this.centers[this.delaunay[end]].clone());\n    if (this.polygon.intersectsLine(l)) {\n        l.free();\n    } else {\n        this.graph.addEdge(this.delaunay[start], this.delaunay[end], l.length());\n        this.delaunay_lines.push(l);\n    }\n};\n\n\nBuilding.prototype.translate = function (vec) {\n    this.polygon.translate(vec);\n    for (var i = 0; i < this.centers.length; i++) {\n        this.centers[i].add(vec);\n    }\n    for (i = 0; i < this.delaunay_triangles.length; i++) {\n        this.delaunay_triangles[i].translate(vec);\n    }\n    return this;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\nvar Rectangle2 = require('../../geometry/rectangle2');\nvar Vector2 = require('../../geometry/vector2');\nvar LineSegment2 = require('../../geometry/linesegment2');\nvar gpc = require('../../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('../graph');\nvar avoidance = require('../../ai/steering').avoidance;\n\n/* jshint -W064 */\nmodule.exports = Dungeon;\n\nvar GENERATE_ROOMS = 1,\n    EVADE_ROOMS = 2,\n    SELECT_ROOMS = 3;\n\n\nfunction Dungeon(chance, iterations, radius, minSide, maxSide) {\n    this.sizeChance = {min: minSide, max: maxSide};\n    this.posChance = {min: 0, max: 1};\n    this.rooms = [];\n    this.vectors = [];\n    this.chance = chance;\n    this.iterations = iterations;\n    this.radius = radius;\n    this.minSide = minSide;\n    this.maxSide = maxSide;\n    this.state = GENERATE_ROOMS;\n}\n\n\nDungeon.prototype.step = function () {\n    switch (this.state) {\n        case GENERATE_ROOMS:\n            this.addRoom();\n            break;\n        case EVADE_ROOMS:\n            this.evadeRooms();\n            break;\n        default:\n            break;\n    }\n};\n\nDungeon.prototype.addRoom = function () {\n    var t = 2 * Math.PI * this.chance.floating(this.posChance);\n    var u = this.chance.floating(this.posChance) + this.chance.floating(this.posChance);\n    var r = ( u > 1 ? 2 - u : u );\n    var x = this.radius * r * Math.cos(t);\n    var y = this.radius * r * Math.sin(t);\n    var w = this.chance.integer(this.sizeChance);\n    var h = this.chance.integer(this.sizeChance);\n\n    var room = Rectangle2(x - (w / 2), y - (h / 2), w, h);\n    this.rooms.push(room);\n    this.vectors.push(Vector2());\n\n    if (this.rooms.length === this.iterations) {\n        this.state = EVADE_ROOMS;\n    }\n};\n\nDungeon.prototype.evadeRooms = function () {\n    var l = this.rooms.length;\n    var i, r, v, j, rr, f;\n    var p1 = Vector2();\n    var p2 = Vector2();\n    var avoided = false;\n    var oneAvoided = false;\n    for (i = 0; i < l; i++) {\n        avoided = false;\n        r = this.rooms[i];\n        v = this.vectors[i];\n        for (j = 0; j < l; j++) {\n            if (j !== i) {\n                rr = this.rooms[j];\n                if (r.intersects(rr)) {\n                    // avoidance force\n                    p1.set(r.x, r.y);\n                    p2.set(rr.x, rr.y);\n                    f = avoidance(p2, p1, v, 10, 10, 5); // arbitrary numbers, but it seems to work\n                    v.copy(f);\n                    f.free();\n                    avoided = true;\n                }\n            }\n        }\n        if (avoided) {\n            r.x += v.x;\n            r.y += v.y;\n            oneAvoided = true;\n        }\n    }\n\n    p1.free();\n    p2.free();\n    if (!oneAvoided) {\n        v = this.vectors.pop();\n        while (v) {\n            v.free();\n            v = this.vectors.pop();\n        }\n        this.state = SELECT_ROOMS;\n    }\n};\n/* jshint +W064 */","'use strict';\n\n\n// Represents an edge from source to sink with capacity\nvar Edge = function (source, sink, capacity) {\n    this.source = source;\n    this.sink = sink;\n    this.capacity = capacity;\n};\n\n// Main class to manage the network\nvar Graph = function () {\n    this.edges = {};\n    this.nodes = [];\n    this.nodeMap = {};\n\n    // Add a node to the graph\n    this.addNode = function (node) {\n        this.nodes.push(node);\n        this.nodeMap[node] = this.nodes.length - 1;\n        this.edges[node] = [];\n    };\n\n    // Add an edge from source to sink with capacity\n    this.addEdge = function (source, sink, capacity) {\n        // Create the two edges = one being the reverse of the other\n        this.edges[source].push(new Edge(source, sink, capacity));\n        this.edges[sink].push(new Edge(sink, source, capacity));\n    };\n\n    // Does edge from source to sink exist?\n    this.edgeExists = function (source, sink) {\n        if (this.edges[source] !== undefined) {\n            for (var i = 0; i < this.edges[source].length; i++) {\n                if (this.edges[source][i].sink === sink) {\n                    return this.edges[source][i];\n                }\n            }\n        }\n        return null;\n    };\n\n\n    this.prim = function () {\n        var result = [];\n        var resultEdges = [];\n        var usedNodes = {};\n\n        function findMin(g) {\n            var min = [999999, null];\n            for (var i = 0; i < result.length; i++) {\n                for (var n = 0; n < g.edges[result[i]].length; n++) {\n                    if (g.edges[result[i]][n].capacity < min[0] && usedNodes[g.edges[result[i]][n].sink] === undefined) {\n                        min = [g.edges[result[i]][n].capacity, g.edges[result[i]][n]];\n                    }\n                }\n            }\n            return min;\n        }\n\n        // Pick random start point\n        var node = this.nodes[Math.round(Math.random() * (this.nodes.length - 1))];\n        result.push(node);\n        usedNodes[node] = true;\n\n        var min = findMin(this);\n        while (min[1] !== null) {\n            resultEdges.push(min[1]);\n            result.push(min[1].sink);\n            usedNodes[min[1].sink] = true;\n            min = findMin(this);\n        }\n\n        return resultEdges;\n    };\n\n};\n\nmodule.exports = Graph;\n","module.exports = {\n    Graph: require('./graph'),\n    Building: require('./building'),\n    Dungeon: require('./dungeon')\n};\n ","'use strict';\n\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\n\nvar NOOP = function () {\n};\n\nmodule.exports = GameLoop;\n\nfunction GameLoop() {\n    this.simulationTimestep = 1000 / 60;\n    this.frameDelta = 0;\n    this.lastFrameTimeMs = 0;\n    this.fps = 60;\n    this.lastFpsUpdate = 0;\n    this.framesThisSecond = 0;\n    this.numUpdateSteps = 0;\n    this.minFrameDelay = 0;\n    this.running = false;\n    this.started = false;\n    this.panic = false;\n    this.rafHandle = false;\n    this.boundAnimate = this.animate.bind(this);\n}\n\nGameLoop.prototype.begin = NOOP;\nGameLoop.prototype.update = NOOP;\nGameLoop.prototype.render = NOOP;\nGameLoop.prototype.end = NOOP;\n\nGameLoop.prototype.getSimulationTimestep = function () {\n    return this.simulationTimestep;\n};\n\nGameLoop.prototype.setSimulationTimestep = function (timestep) {\n    this.simulationTimestep = timestep;\n    return this;\n};\n\nGameLoop.prototype.getFPS = function () {\n    return this.fps;\n};\n\nGameLoop.prototype.getMaxAllowedFPS = function () {\n    return 1000 / this.minFrameDelay;\n};\n\nGameLoop.prototype.setMaxAllowedFPS = function (fps) {\n    if (typeof fps === 'undefined') {\n        fps = Infinity;\n    }\n    if (fps === 0) {\n        this.stop();\n    }\n    else {\n        // Dividing by Infinity returns zero.\n        this.minFrameDelay = 1000 / fps;\n    }\n    return this;\n};\n\nGameLoop.prototype.resetFrameDelta = function () {\n    var oldFrameDelta = this.frameDelta;\n    this.frameDelta = 0;\n    return oldFrameDelta;\n};\n\nGameLoop.prototype.setBegin = function (fun) {\n    this.begin = fun || this.begin;\n    return this;\n};\n\nGameLoop.prototype.setUpdate = function (fun) {\n    this.update = fun || this.update;\n    return this;\n};\n\nGameLoop.prototype.setRender = function (fun) {\n    this.render = fun || this.render;\n    return this;\n};\n\nGameLoop.prototype.setEnd = function (fun) {\n    this.end = fun || this.end;\n    return this;\n};\n\nGameLoop.prototype.start = function () {\n    if (!this.started) {\n        this.started = true;\n        var self = this;\n        this.rafHandle = request(function (timestamp) {\n            self.render(1);\n            self.running = true;\n            self.lastFrameTimeMs = timestamp;\n            self.lastFpsUpdate = timestamp;\n            self.framesThisSecond = 0;\n            self.rafHandle = request(self.boundAnimate);\n        });\n    }\n    return this;\n};\n\nGameLoop.prototype.stop = function () {\n    this.running = false;\n    this.started = false;\n    cancel(this.rafHandle);\n    return this;\n};\n\nGameLoop.prototype.isRunning = function () {\n    return this.running;\n};\n\nGameLoop.prototype.animate = function animate(timestamp) {\n\n    if (timestamp < this.lastFrameTimeMs + this.minFrameDelay) {\n        this.rafHandle = request(this.boundAnimate);\n        return;\n    }\n\n    this.frameDelta += timestamp - this.lastFrameTimeMs;\n    this.lastFrameTimeMs = timestamp;\n\n    this.begin(timestamp, this.frameDelta);\n\n    if (timestamp > this.lastFpsUpdate + 1000) {\n        this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;\n        this.lastFpsUpdate = timestamp;\n        this.framesThisSecond = 0;\n    }\n    this.framesThisSecond++;\n\n    /* - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    this.numUpdateSteps = 0;\n    while (this.frameDelta >= this.simulationTimestep) {\n        this.update(this.simulationTimestep);\n        this.frameDelta -= this.simulationTimestep;\n\n        if (++this.numUpdateSteps >= 240) {\n            this.panic = true;\n            break;\n        }\n    }\n\n    this.render(this.frameDelta / this.simulationTimestep);\n\n    this.end(this.fps, this.panic);\n\n    this.panic = false;\n\n    this.rafHandle = request(this.boundAnimate);\n};\n","module.exports = {\n    GameLoop: require('./gameloop')\n};\n"],"sourceRoot":"./"}