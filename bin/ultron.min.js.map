{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/delaunay-fast/delaunay.js","ultron.min.js","node_modules/eventemitter3/index.js","node_modules/request-frame/dist/request-frame.js","node_modules/vkey/index.js","src/geometry/gpc.js","src/geometry/grid/cell.js","src/geometry/grid/grid.js","src/geometry/grid/index.js","src/geometry/index.js","src/geometry/linesegment2.js","src/geometry/polygon2.js","src/geometry/quadtree/boundsnode.js","src/geometry/quadtree/index.js","src/geometry/quadtree/pointnode.js","src/geometry/quadtree/quadtree.js","src/geometry/regularpolygon2.js","src/geometry/triangle2.js","src/geometry/vector2.js","src/geometry/visibilitypolygon.js","src/src/index.js","src/input/index.js","src/input/mousewheel-polyfill.js","src/input/unified.js","src/linkedlist/doublylinkedlist.js","src/linkedlist/index.js","src/procedural/building.js","src/procedural/graph.js","src/procedural/index.js","src/timer/gameloop.js","src/timer/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","ULTRON","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"Delaunay","supertriangle","vertices","dx","dy","dmax","xmid","ymid","xmin","Number","POSITIVE_INFINITY","ymin","xmax","NEGATIVE_INFINITY","ymax","Math","max","circumcircle","j","k","xc","yc","m1","m2","mx1","mx2","my1","my2","x1","y1","x2","y2","x3","y3","fabsy1y2","abs","fabsy2y3","EPSILON","x","y","dedup","edges","b","m","splice","triangulate","key","indices","st","open","closed","c","slice","Array","sort","push","contains","tri","p","d","v",2,"EE","fn","context","once","EventEmitter","prefix","Object","create","prototype","_events","undefined","listeners","event","exists","evt","available","ee","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","apply","on","listener","events","removeAllListeners","off","addListener","setMaxListeners","prefixed",3,"requestFrame","type","hasIOS6RequestAnimationFrameBug","bugCheckresults","timingFnA","timingFnB","notice","console","warn","displayResults","hasIOS6Bug","webkitRAF","rAF","iOS6Notice","webkitRequestAnimationFrame","requestAnimationFrame","hasMobileDeviceWidth","screen","width","requiresWebkitprefix","hasNoNavigationTiming","performance","clearTimeoutWithId","id","clearTimeout","setTimeoutWithTimestamp","callback","immediateTime","Date","now","lapsedTime","previousTime","setTimeout","queryRequestAnimationFrame","filter","assignedRequestAnimationFrame","aF","vendors","vendor","rqAF","queryCancelAnimationFrame","prefixedCancelAnimationFrame","prefixedNames","cancellationFunction","cancellationNames","map","cancellationNamePrefix","assignedCancelAnimationFrame","getRequestFn","hasMozMismatch","getCancelFn","setNativeFn","cancelAnimationFrame","func","mozRAF","mozRequestAnimationFrame","mozCAF","mozCancelAnimationFrame","getTime",4,"ua","navigator","userAgent","isOSX","test","isOpera","maybeFirefox","output",5,6,8,9,12,13,16,17,18,19,20,21,23,24,25,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,91,92,93,95,106,107,108,109,110,111,144,145,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,186,187,188,189,190,191,192,219,220,221,222,223,224,226,229,231,246,247,248,249,250,251,252,253,254,"String","fromCharCode","equals","toString","gpcas","util","geometry","Clip","BundleState","LmtNode","TopPolygonNode","AetTree","HState","VertexType","VertexNode","ItNodeTable","StNode","Point","ArrayHelper","gpcstatic","create2DArray","valueEqual","obj1","obj2","sortPointsClockwise","isArrayList","ArrayList","toArray","maxLeftIndex","maxTop","maxBottom","maxLeft","maxRight","newVertices","vertex","reverse","arr","_array","add","value","get","index","size","clear","list","hashCode","isEmpty","DEBUG","GPC_EPSILON","GPC_VERSION","LEFT","RIGHT","ABOVE","BELOW","CLIP","SUBJ","intersection","p1","p2","polyClass","clip","OperationType","GPC_INT","union","GPC_UNION","xor","GPC_XOR","difference","GPC_DIFF","createNewPoly","PolySimple","PolyDefault","op","subj","result","minimax_test","lmt_table","LmtTable","sbte","ScanBeamTreeEntries","s_heap","c_heap","build_lmt","print","top_node","sbt","build_sbt","parity","local_min","out_poly","aet","scanbeam","yb","yt","edge","first_bound","next_bound","add_edge_to_aet","next","px","MAX_VALUE","e0","e1","bundle","top","bstate","UNBUNDLED","next_edge","ne_type","ne_type_opp","EQ","xb","BUNDLE_HEAD","BUNDLE_TAIL","horiz","NH","cf","bside","contributing","br","bl","tr","tl","next_h_state","vclass","getType","EMN","IMN","outp","add_local_min","ERI","add_right","ELI","add_left","EMX","merge_right","ILI","IRI","IMX","merge_left","IMM","EMM","LED","bot","RED","prev_edge","prev","xt","sbt_entries","it_table","build_intersection_table","intersect","ie","q","ix","point","iy","in_clip","in_subj","search","succ_edge","succ","getResult","PREV_INDEX","NEXT_INDEX","OPTIMAL","getY","getNumPoints","create_contour_bboxes","box","getNumInnerPoly","inner_poly","getInnerPoly","getBounds","s_bbox","c_bbox","subj_num_poly","clip_num_poly","o_table","getMaxX","getMinX","getMaxY","getMinY","overlap","setContributing","bound_list","node","done","existing_node","insert_bound","lmt_node","prev_bound","current_bound","current_edge","add_to_sbtree","sb_tree","ScanBeamTree","tree_node","less","more","edge_table","EdgeTable","ip","isContributing","num_vertices","e_index","getX","addNode","min","FWD_MIN","num_edges","NOT_FMAX","getNode","ei","ev","pred","REV_MIN","NOT_RMAX","add_st_edge","it","den","add_intersection","it_node","edge0","edge1","ItNode","state","m_State","EdgeNode","m_List","ith","BH","TH","IntersectionPoint","p3","polygonPoint1","polygonPoint2","intersectionPoint","Line","start","end","LineHelper","equalPoint","equalVertex","s1","s2","e2","distancePoints","sqrt","clonePoint","cloneLine","line","res","addLineToLine","line1","line2","roundPoint","round","lineIntersectLine","A","B","E","F","as_seg","b1","b2","c1","c2","denom","pow","LineIntersection","iteratePoints","points","direction","pl","s1Ind","indexOf","s2Ind","newPoints","intersectPoly","poly","p4","numPoints","firstIntersection","lastIntersection","firstIntersectionLineIndex","lastIntersectionLineIndex","firstFound","maxDist","minDist","dist","getPoint","distance","newLine","poly1","finPoly1","finPoly2","checkPoly","points1","getPoints","concat","points2","poly2","noHoles","innerPoly","isHole","yvalue","lmt","m_Type","m_IsHole","obj","that","arg0","arg1","addPointXY","addPoint","addPoly","alert","Rectangle","log","polyIndex","isPointInside","setIsHole","contributes","getArea","area","tarea","Polygon","fromArray","pointArr","normalize","getVertexIndex","insertVertex","vertex1","vertex2","newVertex","vertex1Index","vertex2Index","clone","PolygonNode","active","hole","proxy","vn","nv","m_Contributes","this_num","that_num","this_x","this_y","that_first_index","that_index","that_x","that_y","this_index","Poly","val","oddNodes","ax","ay","bx","by","cx","cy","_x","_y","_w","_h","w","h","entries","inner_build_sbt","sbt_node","existing_min","target","count_contours","nc","polygon","num_contours","npoly_node","poly_node","vtx","orig","inner","NUL","TED","BED","FUL","WeilerAtherton","merge","Cell","height","items","a10","a11","a20","a21","b10","b11","b20","b21","ua_t","ub_t","u_b","ub","insert","item","fromX","fromY","toX","toY",7,"Grid","bounds","rows","cols","cellX","cellY","cells","out","DoublyLinkedList","col","row","addOut","retrieve","nx","ny","floor","../../linkedlist/doublylinkedlist","./cell","./grid","Vector2","LineSegment2","Triangle2","Polygon2","RegularPolygon2","gpc","VisibilityPolygon","QuadTree","./gpc","./linesegment2","./polygon2","./quadtree","./regularpolygon2","./triangle2","./vector2","./visibilitypolygon",10,"cache","pop","free","set","created","getStats","lengthSq","distanceSq","closestPoint","full","l2","intersectCircle","radius","r2","closest","dist_v","subtract","len2","other","inverse",11,"freePoints","epsilon","translate","vec","rotate","angle","origin","containsPoint","inside","xi","yi","xj","yj","intersectsLine","ignorePoints","tempLine","is","isEqualEpsilon","aa","copy","bb","intersectsTriangle","triangle","v0","v1","v2","AABB","winding","rewind","cw","first","cross","clean","newpoints","ret","BoundsNode","depth","maxChildren","maxDepth","PointNode","_stuckChildren","_classConstructor","_out","nodes","_findIndex","_bounds","children","_depth","_maxDepth","_maxChildren","subdivide","getChildren","TOP_RIGHT","BOTTOM_LEFT","TOP_LEFT","BOTTOM_RIGHT","getAllContent","./pointnode","./boundsnode",14,"left","b_w_h","b_h_h","bx_b_w_h","by_b_h_h",15,"pointQuad","root","sides","center","cos","PI","sin","calcCircumcircle","C","D","G","minx","miny","maxx","maxy","radius_squared","inCircumcircle","dist_squared","radian2degrees","rad","degrees","degrees2radian","deg","fromObject","addScalar","scalar","subtractScalar","divide","multiply","multiplyScalar","zero","dot","projectOnto","coeff","horizontalAngle","atan2","horizontalAngleDeg","verticalAngle","verticalAngleDeg","angleDeg","ox","oy","rotateDeg","rotateBy","rotation","rotateByDeg","magnitude","isZero","isEqualTo","toObject","pointsorter","segments","heap","position","PI2","PImin","segmentIter","angle2","compute","reset","sortPoints","extend","shorten","old_segment","remove","cur","destination","parent","lessThan","temp","swap","child","right","index1","index2","inter1","inter2","d1","d2","end1","end2","isEqualEpsiolon","pp","nr","core","linkedlist","procedural","timer","input","./geometry","./input","./linkedlist","./procedural","./timer","Unified","./unified",22,"_addWheelListener","elem","eventName","useCapture","_addEventListener","support","originalEvent","srcElement","deltaMode","deltaX","delatZ","preventDefault","returnValue","deltaY","wheelDelta","wheelDeltaX","detail","addEventListener","document","createElement","onmousewheel","Inputs","element","opts","preventDefaults","stopPropagation","down","up","gamepadconnected","gamepaddisconnected","scrollx","scrolly","scrollz","_keybindmap","_keyStates","_bindPressCounts","_gamepads","_gamepadButtonStates","_gamepadRaf","initEvents","onKeyEvent","inputs","wasDown","handleKeyEvent","keyCode","vkey","onMouseEvent","keycode","button","vkeycode","onContextMenu","onMouseMove","movementX","mozMovementX","webkitMovementX","movementY","mozMovementY","webkitMovementY","onMouseWheel","scale","clientHeight","innerHeight","deltaZ","vcode","currstate","XOR","handleBindingEvent","binding","ct","emitter","handleGamePadButtonEvent","pressed","isPerc","_buttonStates","updateGamepads","found","scanGamepads","cancel","gamepad","buttons","gamepadButtonNames","axes","gamepadAxesNames","request","onGamepadConnected","addGamepad","onGamepadDisconnected","removeGamepad","hasOwnProperty","gamepads","getGamepads","webkitGetGamepads","addMouseWheel","domElement","options","hasGamepadEvents","bind","oncontextmenu","setInterval","vkeyCode","unbind","tick","getBoundKeys","./mousewheel-polyfill","eventemitter3","request-frame","_head","_tail","_length","_nodeCache","constructor","data","_allocate","current","_free","./doublylinkedlist",26,"Building","chance","iterations","minRadius","maxRadius","maxSides","noRotate","centers","sidesChanceObj","radiusChanceObj","integer","floating","gpcPoly","createPoly","gpcPoly2","num","getPolygonVertices","nrdoors","ceil","doors","dooredges","graph","Graph","delaunay_used","delaunay","delaunay_exists","delaunay_triangles","delaunay_lines","addDelaunayLine","connectDoor","prim","mst_lines","source","sink","outside","door","addEdge","key1","key2","../geometry/gpc","../geometry/linesegment2","../geometry/polygon2","../geometry/regularpolygon2","../geometry/vector2","./graph","delaunay-fast","Edge","capacity","nodeMap","edgeExists","findMin","usedNodes","resultEdges","random","./building","GameLoop","simulationTimestep","frameDelta","lastFrameTimeMs","fps","lastFpsUpdate","framesThisSecond","numUpdateSteps","minFrameDelay","running","started","panic","rafHandle","boundAnimate","animate","NOOP","begin","update","render","getSimulationTimestep","setSimulationTimestep","timestep","getFPS","getMaxAllowedFPS","setMaxAllowedFPS","Infinity","stop","resetFrameDelta","oldFrameDelta","setBegin","fun","setUpdate","setRender","setEnd","timestamp","isRunning","./gameloop"],"mappings":"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","file":"ultron.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var Delaunay;\n\n(function() {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i, dx, dy, dmax, xmid, ymid;\n\n    for(i = vertices.length; i--; ) {\n      if(vertices[i][0] < xmin) xmin = vertices[i][0];\n      if(vertices[i][0] > xmax) xmax = vertices[i][0];\n      if(vertices[i][1] < ymin) ymin = vertices[i][1];\n      if(vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n\n    return [\n      [xmid - 20 * dmax, ymid -      dmax],\n      [xmid            , ymid + 20 * dmax],\n      [xmid + 20 * dmax, ymid -      dmax]\n    ];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;\n\n    /* Check for coincident points */\n    if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)\n      throw new Error(\"Eek! Coincident points!\");\n\n    if(fabsy1y2 < EPSILON) {\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (x2 + x1) / 2.0;\n      yc  = m2 * (xc - mx2) + my2;\n    }\n\n    else if(fabsy2y3 < EPSILON) {\n      m1  = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc  = (x3 + x2) / 2.0;\n      yc  = m1 * (xc - mx1) + my1;\n    }\n\n    else {\n      m1  = -((x2 - x1) / (y2 - y1));\n      m2  = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc  = (fabsy1y2 > fabsy2y3) ?\n        m1 * (xc - mx1) + my1 :\n        m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for(j = edges.length; j; ) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for(i = j; i; ) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if((a === m && b === n) || (a === n && b === m)) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function(vertices, key) {\n      var n = vertices.length,\n          i, j, indices, st, open, closed, edges, dx, dy, a, b, c;\n\n      /* Bail if there aren't enough vertices to form any triangles. */\n      if(n < 3)\n        return [];\n\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n      vertices = vertices.slice(0);\n\n      if(key)\n        for(i = n; i--; )\n          vertices[i] = vertices[i][key];\n\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n      indices = new Array(n);\n\n      for(i = n; i--; )\n        indices[i] = i;\n\n      indices.sort(function(i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      \n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n      open   = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges  = [];\n\n      /* Incrementally add each vertex to the mesh. */\n      for(i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n        for(j = open.length; j--; ) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n          if(dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n\n          /* If we're outside the circumcircle, skip this triangle. */\n          dy = vertices[c][1] - open[j].y;\n          if(dx * dx + dy * dy - open[j].r > EPSILON)\n            continue;\n\n          /* Remove the triangle and add it's edges to the edge list. */\n          edges.push(\n            open[j].i, open[j].j,\n            open[j].j, open[j].k,\n            open[j].k, open[j].i\n          );\n          open.splice(j, 1);\n        }\n\n        /* Remove any doubled edges. */\n        dedup(edges);\n\n        /* Add a new triangle for each edge. */\n        for(j = edges.length; j; ) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n      for(i = open.length; i--; )\n        closed.push(open[i]);\n      open.length = 0;\n\n      for(i = closed.length; i--; )\n        if(closed[i].i < n && closed[i].j < n && closed[i].k < n)\n          open.push(closed[i].i, closed[i].j, closed[i].k);\n\n      /* Yay, we're done! */\n      return open;\n    },\n    contains: function(tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||\n         (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||\n         (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||\n         (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))\n        return null;\n\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n\n      /* Degenerate tri. */\n      if(i === 0.0)\n        return null;\n\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n\n      /* If we're outside the tri, fail. */\n      if(u < 0.0 || v < 0.0 || (u + v) > 1.0)\n        return null;\n\n      return [u, v];\n    }\n  };\n\n  if(typeof module !== \"undefined\")\n    module.exports = Delaunay;\n})();\n",null,"'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\n *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for\n *   optimal cross-browser development.\n *    Version:  v1.2.3\n *     License:  MIT\n *      Copyright Julien Etienne 2015 All Rights Reserved.\n *        github:  https://github.com/julienetie/request-frame\n *\n */\n(function (window) {\n\n/**\n * @param  {String} type - request | cancel | native.\n * @return {Function} Timing function.\n */\nfunction requestFrame(type) {\n    // The only vendor prefixes required.\n    var vendors = ['moz', 'webkit'],\n\n        // Disassembled timing function abbreviations.\n        aF = 'AnimationFrame',\n        rqAF = 'Request' + aF,\n\n        // Final assigned functions.\n        assignedRequestAnimationFrame,\n        assignedCancelAnimationFrame,\n\n        // Initial time of the timing lapse.\n        previousTime = 0,\n\n        mozRAF = window.mozRequestAnimationFrame,\n        mozCAF = window.mozCancelAnimationFrame,\n\n        // Checks for firefox 4 - 10 function pair mismatch.\n        hasMozMismatch = mozRAF && !mozCAF,\n\n        func;\n\n    // Date.now polyfill, mainly for legacy IE versions.\n    if (!Date.now) {\n        Date.now = function() {\n            return new Date().getTime();\n        };\n    }\n\n    /**\n     * hasIOS6RequestAnimationFrameBug.\n     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}\n     * - for Commentary.\n     * @Copyright 2015 - Julien Etienne. \n     * @License: MIT.\n     */\n    function hasIOS6RequestAnimationFrameBug() {\n        var webkitRAF = window.webkitRequestAnimationFrame,\n            rAF = window.requestAnimationFrame,\n\n            // CSS/ Device with max for iOS6 Devices.\n            hasMobileDeviceWidth = screen.width <= 768 ? true : false,\n\n            // Only supports webkit prefixed requestAnimtionFrane.\n            requiresWebkitprefix = !(webkitRAF && rAF),\n\n            // iOS6 webkit browsers don't support performance now.\n            hasNoNavigationTiming = window.performance ? false : true,\n\n            iOS6Notice = 'setTimeout is being used as a substitiue for' +\n            'requestAnimationFrame due to a bug within iOS 6 builds',\n\n            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&\n            hasNoNavigationTiming;\n\n        function bugCheckresults(timingFnA, timingFnB, notice) {\n            if (timingFnA || timingFnB) {\n                console.warn(notice);\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function displayResults() {\n            if (hasIOS6Bug) {\n                return bugCheckresults(webkitRAF, rAF, iOS6Notice);\n            } else {\n                return false;\n            }\n        }\n\n        return displayResults();\n    }\n\n    /**\n     * Native clearTimeout function.\n     * @return {Function}\n     */\n    function clearTimeoutWithId(id) {\n        clearTimeout(id);\n    }\n\n    /**\n     * Based on a polyfill by Erik, introduced by Paul Irish & \n     * further improved by Darius Bacon.\n     * @see  {@link http://www.paulirish.com/2011/\n     * requestanimationframe-for-smart-animating}\n     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/\n     * master/requestAnimationFrame.js}\n     * @callback {Number} Timestamp.\n     * @return {Function} setTimeout Function.\n     */\n    function setTimeoutWithTimestamp(callback) {\n        var immediateTime = Date.now(),\n            lapsedTime = Math.max(previousTime + 16, immediateTime);\n        return setTimeout(function() {\n                callback(previousTime = lapsedTime);\n            },\n            lapsedTime - immediateTime);\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the setTimeoutWithTimestamp function.\n     * @return {Function}\n     */\n    function queryRequestAnimationFrame() {\n        if (Array.prototype.filter) {\n            assignedRequestAnimationFrame = window['request' + aF] ||\n                window[vendors.filter(function(vendor) {\n                    if (window[vendor + rqAF] !== undefined)\n                        return vendor;\n                }) + rqAF] || setTimeoutWithTimestamp;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedRequestAnimationFrame;\n        } else {\n            return setTimeoutWithTimestamp;\n        }\n    }\n\n    /**\n     * Queries the native function, prefixed function \n     * or use the clearTimeoutWithId function.\n     * @return {Function}\n     */\n    function queryCancelAnimationFrame() {\n        var cancellationNames = [];\n        if (Array.prototype.map) {\n            vendors.map(function(vendor) {\n                return ['Cancel', 'CancelRequest'].map(\n                    function(cancellationNamePrefix) {\n                        cancellationNames.push(vendor +\n                            cancellationNamePrefix + aF);\n                    });\n            });\n        } else {\n            return clearTimeoutWithId;\n        }\n\n        /**\n         * Checks for the prefixed cancelAnimationFrame implementation.\n         * @param  {Array} prefixedNames - An array of the prefixed names. \n         * @param  {Number} i - Iteration start point.\n         * @return {Function} prefixed cancelAnimationFrame function.\n         */\n        function prefixedCancelAnimationFrame(prefixedNames, i) {\n            var cancellationFunction;\n            for (; i < prefixedNames.length; i++) {\n                if (window[prefixedNames[i]]) {\n                    cancellationFunction = window[prefixedNames[i]];\n                    break;\n                }\n            }\n            return cancellationFunction;\n        }\n\n        // Use truthly function\n        assignedCancelAnimationFrame = window['cancel' + aF] ||\n            prefixedCancelAnimationFrame(cancellationNames, 0) ||\n            clearTimeoutWithId;\n\n        // Check for iOS 6 bug\n        if (!hasIOS6RequestAnimationFrameBug()) {\n            return assignedCancelAnimationFrame;\n        } else {\n            return clearTimeoutWithId;\n        }\n    }\n\n    function getRequestFn() {\n        if (hasMozMismatch) {\n            return setTimeoutWithTimestamp;\n        } else {\n            return queryRequestAnimationFrame();\n        }\n    }\n\n    function getCancelFn() {\n        return queryCancelAnimationFrame();\n    }\n\n    function setNativeFn() {\n        if (hasMozMismatch) {\n            window.requestAnimationFrame = setTimeoutWithTimestamp;\n            window.cancelAnimationFrame = clearTimeoutWithId;\n        } else {\n            window.requestAnimationFrame = queryRequestAnimationFrame();\n            window.cancelAnimationFrame = queryCancelAnimationFrame();\n        }\n    }\n\n    /**\n     * The type value \"request\" singles out firefox 4 - 10 and \n     * assigns the setTimeout function if plausible.\n     */\n\n    switch (type) {\n        case 'request':\n        case '':\n            func = getRequestFn();\n            break;\n\n        case 'cancel':\n            func = getCancelFn();\n            break;\n\n        case 'native':\n            setNativeFn();\n            break;\n        default:\n            throw new Error('RequestFrame parameter is not a type.');\n    }\n    return func;\n}\n\n\n// Node.js/ CommonJS\nif (typeof module === 'object' && typeof module.exports === 'object') {\nmodule.exports = exports = requestFrame;\n}\n\n// AMD\nelse if (typeof define === 'function' && define.amd) {\ndefine(function() {\n  return requestFrame;\n});\n}\n\n// Default to window as global\nelse if (typeof window === 'object') {\nwindow.requestFrame = requestFrame;\n}\n/* global -module, -exports, -define */\n\n}(window));\n","var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n","'use strict';\n\nvar gpcas = gpcas || {};\ngpcas.util = {};\ngpcas.geometry = {};\n\nexports = module.exports = gpcas;\n\n//////////\nvar Clip, BundleState, LmtNode, TopPolygonNode, AetTree, HState, VertexType, VertexNode, ItNodeTable, StNode;\n\n//Object.prototype.equals = function(x) {\nfunction equals(x1, x) {\n\n    var p;\n    for(p in x1) {\n        if(typeof(x[p])==='undefined') {return false;}\n    }\n\n    for(p in x1) {\n        if (x1[p]) {\n            switch(typeof(x1[p])) {\n                case 'object':\n                    if (!equals(x1[p], x[p])) { return false; } break;\n                case 'function':\n                    if (typeof(x[p])==='undefined' ||\n                        (p !== 'equals' && x1[p].toString() !== x[p].toString()))\n                        return false;\n                    break;\n                default:\n                    if (x1[p] !== x[p]) { return false; }\n            }\n        } else {\n            if (x[p])\n                return false;\n        }\n    }\n\n    for(p in x) {\n        if(typeof(x1[p])==='undefined') {return false;}\n    }\n\n    return true;\n}\n///point\nvar Point = function(x,y) {\n    this.x = x;\n    this.y = y;\n};\ngpcas.geometry.Point = Point;\n\n////////////// CLASS ArrayHelper ////////////////////////////////////\ngpcas.util.ArrayHelper = function() {};\nvar gpcstatic = gpcas.util.ArrayHelper;\n\ngpcstatic.create2DArray = function(x,y){\n    var a = [];\n    for (var i=0; i<x; i++){\n        a[i]= [];\n    }\n    return a;\n};\ngpcstatic.valueEqual = function(obj1, obj2) {\n    if (obj1===obj2) return true;\n    if(equals(obj1, obj2)) return true;\n\n    return false;\n}\ngpcstatic.sortPointsClockwise = function(vertices) {\n    var isArrayList  = false;\n\n    if (vertices instanceof gpcas.util.ArrayList){\n        vertices= vertices.toArray();\n        isArrayList=true;\n    }\n\n    //point\n    var maxTop   = null;\n    var maxBottom  = null;\n    var maxLeft   = null;\n    var maxRight  = null;\n\n\n    var maxLeftIndex;\n    var newVertices = vertices;\n\n\n\n    for (var i  = 0; i<vertices.length; i++){\n        var vertex  = vertices[i] ;\n\n        if ((maxTop===null)||(maxTop.y>vertex.y)||((maxTop.y===vertex.y)&&(vertex.x<maxTop.x))){\n            maxTop=vertex;\n        }\n        if ((maxBottom===null)||(maxBottom.y<vertex.y)||((maxBottom.y===vertex.y)&&(vertex.x>maxBottom.x))){\n            maxBottom=vertex;\n        }\n        if ((maxLeft===null)||(maxLeft.x>vertex.x)||((maxLeft.x===vertex.x)&&(vertex.y>maxLeft.y))){\n            maxLeft=vertex;\n            maxLeftIndex=i;\n        }\n        if ((maxRight===null)||(maxRight.x<vertex.x)||((maxRight.x===vertex.x)&&(vertex.y<maxRight.y))){\n            maxRight=vertex;\n        }\n    }\n\n    if (maxLeftIndex>0){\n        newVertices = []\n        var j = 0;\n        for (var i=maxLeftIndex; i<vertices.length;i++){\n            newVertices[j++]=vertices[i];\n        }\n        for (var i=0; i<maxLeftIndex; i++){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n\n    var reverse  = false;\n    for(var i=0 ; i<vertices.length;i++) {\n        var vertex = vertices[i];\n        if (equals(vertex, maxBottom)){\n            reverse=true;\n            break;\n        } else if (equals(vertex, maxTop)){\n            break;\n        }\n    }\n    if (reverse){\n        newVertices=[]\n        newVertices[0]=vertices[0];\n        var j =1;\n        for (var i=vertices.length-1; i>0; i--){\n            newVertices[j++]=vertices[i];\n        }\n        vertices=newVertices;\n    }\n\n    return (isArrayList?(new gpcas.util.ArrayList(vertices)):(vertices));\n}\n\n/////////////// END ArrayHelper  ////////////////////////////////////////////////\n\nvar ArrayHelper = gpcas.util.ArrayHelper;\n////////////////// CLASS ArrayList  /////////////////////////\n\ngpcas.util.ArrayList = function(arr) {\n\tthis._array = [];\n\tif(arr != null) {\n\t\tthis._array=arr;\n\t}\n\n};\nvar p = gpcas.util.ArrayList.prototype;\n\np.add = function(value) {\n    this._array.push(value);\n};\np.get = function(index) {\n    return this._array[index];\n};\np.size = function() {\n\treturn this._array.length;\n};\np.clear = function() {\n    this._array  = [];\n\n};\np.equals = function(list) {\n    if (this._array.length != list.size()) return false;\n\n    for (var i = 0; i<this._array.length ; i++){\n        var obj1  = this._array[i];\n        var obj2  = list.get(i);\n\n        if (!ArrayHelper.valueEqual(obj1,obj2)){\n            return false;\n        }\n    }\n    return true;\n}\np.hashCode = function(){\n    return 0;\n};\np.isEmpty = function() {\n    return (this._array.length == 0);\n}\np.toArray = function(){\n    return this._array;\n}\n///////////////// END ArrayList ////////////////////////\n\n\n\n\n\n\ngpcas.geometry.Clip = function(){};\ngpcas.geometry.Clip.DEBUG = false;\ngpcas.geometry.Clip.GPC_EPSILON = 2.2204460492503131e-016;\ngpcas.geometry.Clip.GPC_VERSION = \"2.31\";\ngpcas.geometry.Clip.LEFT = 0;\ngpcas.geometry.Clip.RIGHT = 1;\ngpcas.geometry.Clip.ABOVE = 0;\ngpcas.geometry.Clip.BELOW = 1;\ngpcas.geometry.Clip.CLIP = 0;\ngpcas.geometry.Clip.SUBJ = 1;\nClip = gpcas.geometry.Clip;\n\n\n\nvar p = gpcas.geometry.Clip.prototype;\nvar gpcstatic = gpcas.geometry.Clip;\n\n// ----------------------\n// --- gpcstatic Methods ---\n// ----------------------\n\n/**\n * Return the intersection of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he intersection with\n * @param p2        One of the polygons to performt he intersection with\n * @param polyClass The type of <code>Poly</code> to return\n */\n\ngpcstatic.intersection = function(p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_INT, p1, p2, polyClass );\n};\n\n\n\n/**\n * Return the union of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he union with\n * @param p2        One of the polygons to performt he union with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.union = function(p1, p2, polyClass) {\n\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n\n\treturn gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_UNION, p1, p2, polyClass );\n};\n\n\n/**\n * Return the xor of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        One of the polygons to performt he xor with\n * @param p2        One of the polygons to performt he xor with\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.xor = function( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip( gpcas.geometry.OperationType.GPC_XOR, p1, p2, polyClass );\n};\n\n\n/**\n * Return the difference of <code>p1</code> and <code>p2</code> where the\n * return type is of <code>polyClass</code>.  See the note in the class description\n * for more on <ocde>polyClass</code>.\n *\n * @param p1        Polygon from which second polygon will be substracted\n * @param p2        Second polygon\n * @param polyClass The type of <code>Poly</code> to return\n */\ngpcstatic.difference = function ( p1, p2, polyClass) {\n    if(polyClass==null || polyClass==undefined) {\n        polyClass = \"PolyDefault\";\n    }\n    return gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_DIFF, p2, p1, polyClass );\n}\ngpcstatic.intersection = function( p1, p2) {\n\treturn gpcas.geometry.Clip.clip(gpcas.geometry.OperationType.GPC_INT, p1, p2, \"PolyDefault.class\" );\n}\n\n\n// -----------------------\n// --- Private Methods ---\n// -----------------------\n\n/**\n * Create a new <code>Poly</code> type object using <code>polyClass</code>.\n */\ngpcstatic.createNewPoly = function ( polyClass) {\n    /* TODO :\n     try\n     {\n     return (Poly)polyClass.newInstance();\n     }\n     catch( var e:Exception)\n     {\n     throw new RuntimeException(e);\n     }*/\n    if (polyClass==\"PolySimple\"){\n        return new gpcas.geometry.PolySimple();\n    }\n    if (polyClass==\"PolyDefault\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\tif (polyClass==\"PolyDefault.class\"){\n        return new gpcas.geometry.PolyDefault();\n    }\n\n    return null;\n}\n\n/**\n * <code>clip()</code> is the main method of the clipper algorithm.\n * This is where the conversion from really begins.\n */\ngpcstatic.clip = function ( op, subj, clip, polyClass) {\n    var result = gpcas.geometry.Clip.createNewPoly( polyClass ) ;\n\n    /* Test for trivial NULL result cases */\n    if( (subj.isEmpty() && clip.isEmpty()) ||\n        (subj.isEmpty() && ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF))) ||\n        (clip.isEmpty() &&  (op == gpcas.geometry.OperationType.GPC_INT)) )\n    {\n        return result ;\n    }\n\n\n\n    /* Identify potentialy contributing contours */\n    if( ((op == gpcas.geometry.OperationType.GPC_INT) || (op == gpcas.geometry.OperationType.GPC_DIFF)) &&\n        !subj.isEmpty() && !clip.isEmpty() )\n    {\n        gpcas.geometry.Clip.minimax_test(subj, clip, op);\n    }\n\n\t//console.log(\"SUBJ \" + subj);\n    //console.log(\"CLIP \" + clip);\n\n\n\n    /* Build LMT */\n    var lmt_table = new gpcas.geometry.LmtTable();\n    var sbte = new gpcas.geometry.ScanBeamTreeEntries();\n    var s_heap= null ;\n    var c_heap= null ;\n\n\n\n    if (!subj.isEmpty())\n    {\n        s_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, subj, gpcas.geometry.Clip.SUBJ, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for subj ---------\");\n        lmt_table.print();\n    }\n    if (!clip.isEmpty())\n    {\n        c_heap = gpcas.geometry.Clip.build_lmt(lmt_table, sbte, clip, gpcas.geometry.Clip.CLIP, op);\n    }\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(\"\");\n        //console.log(\" ------------ After build_lmt for clip ---------\");\n        lmt_table.print();\n    }\n\n    /* Return a NULL result if no contours contribute */\n    if (lmt_table.top_node == null)\n    {\n        return result;\n    }\n\n    /* Build scanbeam table from scanbeam tree */\n    var sbt = sbte.build_sbt();\n\n\n\n    var parity= [];\n    parity[0] = gpcas.geometry.Clip.LEFT ;\n    parity[1] = gpcas.geometry.Clip.LEFT ;\n\n    /* Invert clip polygon for difference operation */\n    if (op == gpcas.geometry.OperationType.GPC_DIFF)\n    {\n        parity[Clip.CLIP]= gpcas.geometry.Clip.RIGHT;\n    }\n\n    if( gpcas.geometry.Clip.DEBUG )\n    {\n        //console.log(sbt);\n    }\n\n    var local_min = lmt_table.top_node ;\n\n    var out_poly = new TopPolygonNode(); // used to create resulting Poly\n\n    var aet = new AetTree();\n    var scanbeam = 0;\n\n\n\n    /* Process each scanbeam */\n    while( scanbeam < sbt.length )\n    {\n        /* Set yb and yt to the bottom and top of the scanbeam */\n        var yb = sbt[scanbeam++];\n        var yt = 0.0;\n        var dy = 0.0;\n        if( scanbeam < sbt.length )\n        {\n            yt = sbt[scanbeam];\n            dy = yt - yb;\n        }\n\n\n\n        /* === SCANBEAM BOUNDARY PROCESSING ================================ */\n\n        /* If LMT node corresponding to yb exists */\n        if (local_min != null )\n        {\n            if (local_min.y == yb)\n            {\n                /* Add edges starting at this local minimum to the AET */\n                for( var edge= local_min.first_bound; (edge != null) ; edge= edge.next_bound)\n                {\n                    gpcas.geometry.Clip.add_edge_to_aet( aet, edge );\n                }\n\n                local_min = local_min.next;\n            }\n        }\n\n        if( gpcas.geometry.Clip.DEBUG )\n        {\n            aet.print();\n        }\n        /* Set dummy previous x value */\n        var px = -Number.MAX_VALUE;\n\n        /* Create bundles within AET */\n        var e0 = aet.top_node ;\n        var e1 = aet.top_node ;\n\n\n\n        /* Set up bundle fields of first edge */\n        aet.top_node.bundle[Clip.ABOVE][ aet.top_node.type ] = (aet.top_node.top.y != yb) ? 1: 0;\n        aet.top_node.bundle[Clip.ABOVE][ ((aet.top_node.type==0) ? 1: 0) ] = 0;\n        aet.top_node.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n        for (var next_edge= aet.top_node.next ; (next_edge != null); next_edge = next_edge.next)\n        {\n            var ne_type= next_edge.type ;\n            var ne_type_opp= ((next_edge.type==0) ? 1: 0); //next edge type opposite\n\n            /* Set up bundle fields of next edge */\n            next_edge.bundle[Clip.ABOVE][ ne_type     ]= (next_edge.top.y != yb) ? 1: 0;\n            next_edge.bundle[Clip.ABOVE][ ne_type_opp ] = 0;\n            next_edge.bstate[Clip.ABOVE] = BundleState.UNBUNDLED;\n\n            /* Bundle edges above the scanbeam boundary if they coincide */\n            if ( next_edge.bundle[Clip.ABOVE][ne_type] == 1)\n            {\n                if (Clip.EQ(e0.xb, next_edge.xb) && gpcas.geometry.Clip.EQ(e0.dx, next_edge.dx) && (e0.top.y != yb))\n                {\n                    next_edge.bundle[Clip.ABOVE][ ne_type     ] ^= e0.bundle[Clip.ABOVE][ ne_type     ];\n                    next_edge.bundle[Clip.ABOVE][ ne_type_opp ]  = e0.bundle[Clip.ABOVE][ ne_type_opp ];\n                    next_edge.bstate[Clip.ABOVE] = BundleState.BUNDLE_HEAD;\n                    e0.bundle[Clip.ABOVE][Clip.CLIP] = 0;\n                    e0.bundle[Clip.ABOVE][Clip.SUBJ] = 0;\n                    e0.bstate[Clip.ABOVE] = BundleState.BUNDLE_TAIL;\n                }\n                e0 = next_edge;\n\n            }\n        }\n\n        var horiz= [] ;\n        horiz[Clip.CLIP]= HState.NH;\n        horiz[Clip.SUBJ]= HState.NH;\n\n        var exists= [] ;\n        exists[Clip.CLIP] = 0;\n        exists[Clip.SUBJ] = 0;\n\n        var cf= null ;\n\n        /* Process each edge at this scanbeam boundary */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next )\n        {\n            exists[Clip.CLIP] = edge.bundle[Clip.ABOVE][Clip.CLIP] + (edge.bundle[Clip.BELOW][Clip.CLIP] << 1);\n            exists[Clip.SUBJ] = edge.bundle[Clip.ABOVE][Clip.SUBJ] + (edge.bundle[Clip.BELOW][Clip.SUBJ] << 1);\n\n            if( (exists[Clip.CLIP] != 0) || (exists[Clip.SUBJ] != 0) )\n            {\n                /* Set bundle side */\n                edge.bside[Clip.CLIP] = parity[Clip.CLIP];\n                edge.bside[Clip.SUBJ] = parity[Clip.SUBJ];\n\n                var contributing= false ;\n                var br=0;\n                var bl=0;\n                var tr=0;\n                var tl=0;\n                /* Determine contributing status and quadrant occupancies */\n                if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && ((parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && ((parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br = ((parity[Clip.CLIP]!=0) && (parity[Clip.SUBJ]!=0)) ? 1: 0;\n                    bl = ( ((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1: 0;\n                    tr = ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) !=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0)) !=0) ) ? 1: 0;\n                    tl = (((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) &&\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0))?1:0;\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                {\n                    contributing= (exists[Clip.CLIP]!=0) || (exists[Clip.SUBJ]!=0);\n                    br= (parity[Clip.CLIP]) ^ (parity[Clip.SUBJ]);\n                    bl= (parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP]) ^ (parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    tr= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0)) ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0));\n                    tl= (parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])\n                        ^ (parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ]);\n                }\n                else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                {\n                    contributing= ((exists[Clip.CLIP]!=0) && (!(parity[Clip.SUBJ]!=0) || (horiz[Clip.SUBJ]!=0))) ||\n                        ((exists[Clip.SUBJ]!=0) && (!(parity[Clip.CLIP]!=0) || (horiz[Clip.CLIP]!=0))) ||\n                        ((exists[Clip.CLIP]!=0) && (exists[Clip.SUBJ]!=0) && (parity[Clip.CLIP] == parity[Clip.SUBJ]));\n                    br= ((parity[Clip.CLIP]!=0) || (parity[Clip.SUBJ]!=0))?1:0;\n                    bl= (((parity[Clip.CLIP] ^ edge.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((parity[Clip.SUBJ] ^ edge.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                    tr= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0))!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0))!=0) ) ?1:0;\n                    tl= ( ((parity[Clip.CLIP] ^ ((horiz[Clip.CLIP]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.CLIP])!=0) ||\n                        ((parity[Clip.SUBJ] ^ ((horiz[Clip.SUBJ]!=HState.NH)?1:0) ^ edge.bundle[Clip.BELOW][Clip.SUBJ])!=0) ) ? 1:0;\n                }\n                else\n                {\n                    //console.log(\"ERROR : Unknown op\");\n                }\n\n                /* Update parity */\n                parity[Clip.CLIP] ^= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                parity[Clip.SUBJ] ^= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n\n                /* Update horizontal state */\n                if (exists[Clip.CLIP]!=0)\n                {\n                    horiz[Clip.CLIP] = HState.next_h_state[horiz[Clip.CLIP]][((exists[Clip.CLIP] - 1) << 1) + parity[Clip.CLIP]];\n                }\n                if( exists[Clip.SUBJ]!=0)\n                {\n                    horiz[Clip.SUBJ] = HState.next_h_state[horiz[Clip.SUBJ]][((exists[Clip.SUBJ] - 1) << 1) + parity[Clip.SUBJ]];\n                }\n\n                if (contributing)\n                {\n                    var xb= edge.xb;\n\n\n\n                    var vclass= VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                        case VertexType.IMN:\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            px = xb;\n                            cf = edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.ELI:\n                            edge.outp[Clip.BELOW].add_left( xb, yb);\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            break;\n                        case VertexType.EMX:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            break;\n                        case VertexType.ILI:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            edge.outp[Clip.ABOVE]= cf;\n                            cf= null;\n                            break;\n                        case VertexType.IRI:\n                            edge.outp[Clip.BELOW].add_right( xb, yb );\n                            px= xb;\n                            cf= edge.outp[Clip.BELOW];\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMX:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb );\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            cf= null;\n                            edge.outp[Clip.BELOW]= null;\n                            break;\n                        case VertexType.IMM:\n                            if (xb != px)\n                            {\n                                cf.add_right( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_left(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.EMM:\n                            if (xb != px)\n                            {\n                                cf.add_left( xb, yb);\n                                px= xb;\n                            }\n                            out_poly.merge_right(cf, edge.outp[Clip.BELOW]);\n                            edge.outp[Clip.BELOW]= null;\n                            edge.outp[Clip.ABOVE] = out_poly.add_local_min(xb, yb);\n                            cf= edge.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.LED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_left( xb, yb);\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        case VertexType.RED:\n                            if (edge.bot.y == yb)\n                                edge.outp[Clip.BELOW].add_right( xb, yb );\n                            edge.outp[Clip.ABOVE]= edge.outp[Clip.BELOW];\n                            px= xb;\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing conditional */\n            } /* End of edge exists conditional */\n            if( gpcas.geometry.Clip.DEBUG )\n            {\n                out_poly.print();\n            }\n\t\t\tout_poly.print();\n        } /* End of AET loop */\n\n\n\n        /* Delete terminating edges from the AET, otherwise compute xt */\n        for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n        {\n            if (edge.top.y == yb)\n            {\n                var prev_edge= edge.prev;\n                var next_edge= edge.next;\n\n                if (prev_edge != null)\n                    prev_edge.next = next_edge;\n                else\n                    aet.top_node = next_edge;\n\n                if (next_edge != null )\n                    next_edge.prev = prev_edge;\n\n                /* Copy bundle head state to the adjacent tail edge if required */\n                if ((edge.bstate[Clip.BELOW] == BundleState.BUNDLE_HEAD) && (prev_edge!=null))\n                {\n                    if (prev_edge.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                    {\n                        prev_edge.outp[Clip.BELOW]= edge.outp[Clip.BELOW];\n                        prev_edge.bstate[Clip.BELOW]= BundleState.UNBUNDLED;\n                        if ( prev_edge.prev != null)\n                        {\n                            if (prev_edge.prev.bstate[Clip.BELOW] == BundleState.BUNDLE_TAIL)\n                            {\n                                prev_edge.bstate[Clip.BELOW] = BundleState.BUNDLE_HEAD;\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if (edge.top.y == yt)\n                    edge.xt= edge.top.x;\n                else\n                    edge.xt= edge.bot.x + edge.dx * (yt - edge.bot.y);\n            }\n        }\n\n        if (scanbeam < sbte.sbt_entries )\n        {\n            /* === SCANBEAM INTERIOR PROCESSING ============================== */\n\n            /* Build intersection table for the current scanbeam */\n            var it_table= new ItNodeTable();\n            it_table.build_intersection_table(aet, dy);\n\n\n\n            /* Process each node in the intersection table */\n\n            for (var intersect= it_table.top_node ; (intersect != null); intersect = intersect.next)\n            {\n\n\n\t\t\t\te0= intersect.ie[0];\n\t\t\t\te1= intersect.ie[1];\n\n                /* Only generate output for contributing intersections */\n\n                if ( ((e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)) &&\n                    ((e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) || (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)))\n                {\n                    var p= e0.outp[Clip.ABOVE];\n                    var q= e1.outp[Clip.ABOVE];\n                    var ix= intersect.point.x;\n                    var iy= intersect.point.y + yb;\n\n                    var in_clip= ( ( (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e0.bside[Clip.CLIP]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&  (e1.bside[Clip.CLIP]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.CLIP]!=0) && !(e1.bundle[Clip.ABOVE][Clip.CLIP]!=0) &&\n                        (e0.bside[Clip.CLIP]!=0) && (e1.bside[Clip.CLIP]!=0) ) ) ? 1: 0;\n\n                    var in_subj= ( ( (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e0.bside[Clip.SUBJ]!=0)) ||\n                    ( (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&  (e1.bside[Clip.SUBJ]!=0)) ||\n                    (!(e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0) && !(e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0) &&\n                        (e0.bside[Clip.SUBJ]!=0) && (e1.bside[Clip.SUBJ]!=0) ) ) ? 1: 0;\n\n                    var tr=0\n                    var tl=0;\n                    var br=0;\n                    var bl=0;\n                    /* Determine quadrant occupancies */\n                    if( (op == gpcas.geometry.OperationType.GPC_DIFF) || (op == gpcas.geometry.OperationType.GPC_INT) )\n                    {\n                        tr= ((in_clip!=0) && (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) && ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0))?1:0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) &&\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0) ) ? 1:0;\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_XOR )\n                    {\n                        tr= in_clip^ in_subj;\n                        tl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        br= (in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP]) ^ (in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                        bl= (in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])\n                            ^ (in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ]);\n                    }\n                    else if( op == gpcas.geometry.OperationType.GPC_UNION )\n                    {\n                        tr= ((in_clip!=0) || (in_subj!=0)) ? 1: 0;\n                        tl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        br= (((in_clip ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) || ((in_subj ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                        bl= (((in_clip ^ e1.bundle[Clip.ABOVE][Clip.CLIP] ^ e0.bundle[Clip.ABOVE][Clip.CLIP])!=0) ||\n                            ((in_subj ^ e1.bundle[Clip.ABOVE][Clip.SUBJ] ^ e0.bundle[Clip.ABOVE][Clip.SUBJ])!=0)) ? 1: 0;\n                    }\n                    else\n                    {\n                        //console.log(\"ERROR : Unknown op type, \"+op);\n                    }\n\n                    var vclass = VertexType.getType( tr, tl, br, bl );\n                    switch (vclass)\n                    {\n                        case VertexType.EMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ERI:\n                            if (p != null)\n                            {\n                                p.add_right(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.ELI:\n                            if (q != null)\n                            {\n                                q.add_left(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.EMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left( ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMN:\n                            e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                            e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            break;\n                        case VertexType.ILI:\n                            if (p != null)\n                            {\n                                p.add_left(ix, iy);\n                                e1.outp[Clip.ABOVE]= p;\n                                e0.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IRI:\n                            if (q!=null)\n                            {\n                                q.add_right(ix, iy);\n                                e0.outp[Clip.ABOVE]= q;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMX:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE]= null;\n                                e1.outp[Clip.ABOVE]= null;\n                            }\n                            break;\n                        case VertexType.IMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_right(ix, iy);\n                                out_poly.merge_left(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE]= e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        case VertexType.EMM:\n                            if ((p!=null) && (q!=null))\n                            {\n                                p.add_left(ix, iy);\n                                out_poly.merge_right(p, q);\n                                e0.outp[Clip.ABOVE] = out_poly.add_local_min(ix, iy);\n                                e1.outp[Clip.ABOVE] = e0.outp[Clip.ABOVE];\n                            }\n                            break;\n                        default:\n                            break;\n                    } /* End of switch */\n                } /* End of contributing intersection conditional */\n\n                /* Swap bundle sides in response to edge crossing */\n                if (e0.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e1.bside[Clip.CLIP] = (e1.bside[Clip.CLIP]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.CLIP]!=0)\n                    e0.bside[Clip.CLIP]= (e0.bside[Clip.CLIP]==0)?1:0;\n                if (e0.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e1.bside[Clip.SUBJ]= (e1.bside[Clip.SUBJ]==0)?1:0;\n                if (e1.bundle[Clip.ABOVE][Clip.SUBJ]!=0)\n                    e0.bside[Clip.SUBJ]= (e0.bside[Clip.SUBJ]==0)?1:0;\n\n                /* Swap e0 and e1 bundles in the AET */\n                var prev_edge= e0.prev;\n                var next_edge= e1.next;\n                if (next_edge != null)\n                {\n                    next_edge.prev = e0;\n                }\n\n                if (e0.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD)\n                {\n                    var search= true;\n                    while (search)\n                    {\n                        prev_edge= prev_edge.prev;\n                        if (prev_edge != null)\n                        {\n                            if (prev_edge.bstate[Clip.ABOVE] != BundleState.BUNDLE_TAIL)\n                            {\n                                search= false;\n                            }\n                        }\n                        else\n                        {\n                            search= false;\n                        }\n                    }\n                }\n                if (prev_edge == null)\n                {\n                    aet.top_node.prev = e1;\n                    e1.next           = aet.top_node;\n                    aet.top_node      = e0.next;\n                }\n                else\n                {\n                    prev_edge.next.prev = e1;\n                    e1.next             = prev_edge.next;\n                    prev_edge.next      = e0.next;\n                }\n                e0.next.prev = prev_edge;\n                e1.next.prev = e1;\n                e0.next      = next_edge;\n                if( gpcas.geometry.Clip.DEBUG )\n                {\n                    out_poly.print();\n                }\n            } /* End of IT loop*/\n\n            /* Prepare for next scanbeam */\n            for ( var edge= aet.top_node; (edge != null); edge = edge.next)\n            {\n                var next_edge= edge.next;\n                var succ_edge= edge.succ;\n                if ((edge.top.y == yt) && (succ_edge!=null))\n                {\n                    /* Replace AET edge by its successor */\n                    succ_edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    succ_edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    succ_edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    succ_edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    var prev_edge= edge.prev;\n                    if ( prev_edge != null )\n                        prev_edge.next = succ_edge;\n                    else\n                        aet.top_node = succ_edge;\n                    if (next_edge != null)\n                        next_edge.prev= succ_edge;\n                    succ_edge.prev = prev_edge;\n                    succ_edge.next = next_edge;\n                }\n                else\n                {\n                    /* Update this edge */\n                    edge.outp[Clip.BELOW]= edge.outp[Clip.ABOVE];\n                    edge.bstate[Clip.BELOW]= edge.bstate[Clip.ABOVE];\n                    edge.bundle[Clip.BELOW][Clip.CLIP]= edge.bundle[Clip.ABOVE][Clip.CLIP];\n                    edge.bundle[Clip.BELOW][Clip.SUBJ]= edge.bundle[Clip.ABOVE][Clip.SUBJ];\n                    edge.xb= edge.xt;\n                }\n                edge.outp[Clip.ABOVE]= null;\n            }\n        }\n    } /* === END OF SCANBEAM PROCESSING ================================== */\n\n    /* Generate result polygon from out_poly */\n    result = out_poly.getResult(polyClass);\n\t//console.log(\"result = \"+result);\n\n    return result ;\n}\n\ngpcstatic.EQ = function(a, b) {\n    return (Math.abs(a - b) <= gpcas.geometry.Clip.GPC_EPSILON);\n}\n\ngpcstatic.PREV_INDEX = function( i, n) {\n    return ((i - 1+ n) % n);\n}\n\ngpcstatic.NEXT_INDEX = function(i, n) {\n    return ((i + 1) % n);\n}\n\ngpcstatic.OPTIMAL = function ( p, i) {\n    return (p.getY(gpcas.geometry.Clip.PREV_INDEX (i, p.getNumPoints())) != p.getY(i)) ||\n        (p.getY(gpcas.geometry.Clip.NEXT_INDEX(i, p.getNumPoints())) != p.getY(i)) ;\n}\n\ngpcstatic.create_contour_bboxes = function (p)\n{\n    var box= [] ;\n\n    /* Construct contour bounding boxes */\n    for ( var c= 0; c < p.getNumInnerPoly(); c++)\n    {\n        var inner_poly= p.getInnerPoly(c);\n        box[c] = inner_poly.getBounds();\n    }\n    return box;\n}\n\ngpcstatic.minimax_test = function ( subj, clip, op){\n    var s_bbox= gpcas.geometry.Clip.create_contour_bboxes(subj);\n\tvar c_bbox= gpcas.geometry.Clip.create_contour_bboxes(clip);\n\n\tvar subj_num_poly= subj.getNumInnerPoly();\n\tvar clip_num_poly= clip.getNumInnerPoly();\n\tvar o_table = ArrayHelper.create2DArray(subj_num_poly,clip_num_poly);\n\n\t/* Check all subject contour bounding boxes against clip boxes */\n\tfor( var s= 0; s < subj_num_poly; s++ )\n\t{\n\t    for( var c= 0; c < clip_num_poly ; c++ )\n\t    {\n\t        o_table[s][c] =\n\t            (!((s_bbox[s].getMaxX() < c_bbox[c].getMinX()) ||\n\t                (s_bbox[s].getMinX() > c_bbox[c].getMaxX()))) &&\n\t                (!((s_bbox[s].getMaxY() < c_bbox[c].getMinY()) ||\n\t                    (s_bbox[s].getMinY() > c_bbox[c].getMaxY())));\n\t    }\n\t}\n\n\t/* For each clip contour, search for any subject contour overlaps */\n\tfor( var c= 0; c < clip_num_poly; c++ )\n\t{\n\t    var overlap= false;\n\t    for( var s= 0; !overlap && (s < subj_num_poly) ; s++)\n\t    {\n\t        overlap = o_table[s][c];\n\t    }\n\t    if (!overlap)\n\t    {\n\t        clip.setContributing( c, false ); // Flag non contributing status\n\t    }\n\t}\n\n\tif (op == gpcas.geometry.OperationType.GPC_INT)\n\t{\n\t    /* For each subject contour, search for any clip contour overlaps */\n\t    for ( var s= 0; s < subj_num_poly; s++)\n\t    {\n\t        var overlap= false;\n\t        for ( var c= 0; !overlap && (c < clip_num_poly); c++)\n\t        {\n\t            overlap = o_table[s][c];\n\t        }\n\t        if (!overlap)\n\t        {\n\t            subj.setContributing( s, false ); // Flag non contributing status\n\t        }\n\t    }\n\t}\n}\n\ngpcstatic.bound_list = function( lmt_table, y) {\n    if( lmt_table.top_node == null )\n    {\n        lmt_table.top_node = new LmtNode(y);\n        return lmt_table.top_node ;\n    }\n    else\n    {\n        var prev= null ;\n        var node= lmt_table.top_node ;\n        var done= false ;\n        while( !done )\n        {\n            if( y < node.y )\n            {\n                /* Insert a new LMT node before the current node */\n                var existing_node= node ;\n                node = new LmtNode(y);\n                node.next = existing_node ;\n                if( prev == null )\n                {\n                    lmt_table.top_node = node ;\n                }\n                else\n                {\n                    prev.next = node ;\n                }\n                //               if( existing_node == lmt_table.top_node )\n                //               {\n                //                  lmt_table.top_node = node ;\n                //               }\n                done = true ;\n            }\n            else if ( y > node.y )\n            {\n                /* Head further up the LMT */\n                if( node.next == null )\n                {\n                    node.next = new LmtNode(y);\n                    node = node.next ;\n                    done = true ;\n                }\n                else\n                {\n                    prev = node ;\n                    node = node.next ;\n                }\n            }\n            else\n            {\n                /* Use this existing LMT node */\n                done = true ;\n            }\n        }\n        return node ;\n    }\n}\n\ngpcstatic.insert_bound = function ( lmt_node, e) {\n    if( lmt_node.first_bound == null )\n{\n    /* Link node e to the tail of the list */\n    lmt_node.first_bound = e ;\n}\nelse\n{\n    var done= false ;\n    var prev_bound= null ;\n    var current_bound= lmt_node.first_bound ;\n    while( !done )\n    {\n        /* Do primary sort on the x field */\n        if (e.bot.x <  current_bound.bot.x)\n        {\n            /* Insert a new node mid-list */\n            if( prev_bound == null )\n            {\n                lmt_node.first_bound = e ;\n            }\n            else\n            {\n                prev_bound.next_bound = e ;\n            }\n            e.next_bound = current_bound ;\n\n            //               EdgeNode existing_bound = current_bound ;\n            //               current_bound = e ;\n            //               current_bound.next_bound = existing_bound ;\n            //               if( lmt_node.first_bound == existing_bound )\n            //               {\n            //                  lmt_node.first_bound = current_bound ;\n            //               }\n            done = true ;\n        }\n        else if (e.bot.x == current_bound.bot.x)\n        {\n            /* Do secondary sort on the dx field */\n            if (e.dx < current_bound.dx)\n            {\n                /* Insert a new node mid-list */\n                if( prev_bound == null )\n                {\n                    lmt_node.first_bound = e ;\n                }\n                else\n                {\n                    prev_bound.next_bound = e ;\n                }\n                e.next_bound = current_bound ;\n                //                  EdgeNode existing_bound = current_bound ;\n                //                  current_bound = e ;\n                //                  current_bound.next_bound = existing_bound ;\n                //                  if( lmt_node.first_bound == existing_bound )\n                //                  {\n                //                     lmt_node.first_bound = current_bound ;\n                //                  }\n                done = true ;\n            }\n            else\n            {\n                /* Head further down the list */\n                if( current_bound.next_bound == null )\n                {\n                    current_bound.next_bound = e ;\n                    done = true ;\n                }\n                else\n                {\n                    prev_bound = current_bound ;\n                    current_bound = current_bound.next_bound ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further down the list */\n            if( current_bound.next_bound == null )\n            {\n                current_bound.next_bound = e ;\n                done = true ;\n            }\n            else\n            {\n                prev_bound = current_bound ;\n                current_bound = current_bound.next_bound ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_edge_to_aet = function ( aet, edge) {\n    if ( aet.top_node == null )\n{\n    /* Append edge onto the tail end of the AET */\n    aet.top_node = edge;\n    edge.prev = null ;\n    edge.next= null;\n}\nelse\n{\n    var current_edge= aet.top_node ;\n    var prev= null ;\n    var done= false ;\n    while( !done )\n    {\n        /* Do primary sort on the xb field */\n        if (edge.xb < current_edge.xb)\n        {\n            /* Insert edge here (before the AET edge) */\n            edge.prev= prev;\n            edge.next= current_edge ;\n            current_edge.prev = edge ;\n            if( prev == null )\n            {\n                aet.top_node = edge ;\n            }\n            else\n            {\n                prev.next = edge ;\n            }\n            //               if( current_edge == aet.top_node )\n            //               {\n            //                  aet.top_node = edge ;\n            //               }\n            //               current_edge = edge ;\n            done = true;\n        }\n        else if (edge.xb == current_edge.xb)\n        {\n            /* Do secondary sort on the dx field */\n            if (edge.dx < current_edge.dx)\n            {\n                /* Insert edge here (before the AET edge) */\n                edge.prev= prev;\n                edge.next= current_edge ;\n                current_edge.prev = edge ;\n                if( prev == null )\n                {\n                    aet.top_node = edge ;\n                }\n                else\n                {\n                    prev.next = edge ;\n                }\n                //                  if( current_edge == aet.top_node )\n                //                  {\n                //                     aet.top_node = edge ;\n                //                  }\n                //                  current_edge = edge ;\n                done = true;\n            }\n            else\n            {\n                /* Head further into the AET */\n                prev = current_edge ;\n                if( current_edge.next == null )\n                {\n                    current_edge.next = edge ;\n                    edge.prev = current_edge ;\n                    edge.next = null ;\n                    done = true ;\n                }\n                else\n                {\n                    current_edge = current_edge.next ;\n                }\n            }\n        }\n        else\n        {\n            /* Head further into the AET */\n            prev = current_edge ;\n            if( current_edge.next == null )\n            {\n                current_edge.next = edge ;\n                edge.prev = current_edge ;\n                edge.next = null ;\n                done = true ;\n            }\n            else\n            {\n                current_edge = current_edge.next ;\n            }\n        }\n    }\n}\n}\n\ngpcstatic.add_to_sbtree = function ( sbte, y) {\n    if( sbte.sb_tree == null )\n\t\t{\n\t\t    /* Add a new tree node here */\n\t\t    sbte.sb_tree = new gpcas.geometry.ScanBeamTree( y );\n\t\t    sbte.sbt_entries++ ;\n\t\t    return ;\n\t\t}\n\tvar tree_node= sbte.sb_tree ;\n\tvar done= false ;\n\twhile( !done )\n\t{\n\t    if ( tree_node.y > y)\n\t    {\n\t        if( tree_node.less == null )\n\t        {\n\t            tree_node.less = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.less ;\n\t        }\n\t    }\n\t    else if ( tree_node.y < y)\n\t    {\n\t        if( tree_node.more == null )\n\t        {\n\t            tree_node.more = new gpcas.geometry.ScanBeamTree(y);\n\t            sbte.sbt_entries++ ;\n\t            done = true ;\n\t        }\n\t        else\n\t        {\n\t            tree_node = tree_node.more ;\n\t        }\n\t    }\n\t    else\n\t    {\n\t        done = true ;\n\t    }\n\t}\n}\n\n\ngpcstatic.build_lmt = function( lmt_table,\n\t\t\t\t\t\t\tsbte,\n\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\ttype, //poly type SUBJ/Clip.CLIP\n\t\t\t\t\t\t\top) {\n\t\t\t/* Create the entire input polygon edge table in one go */\n\t\t\tvar edge_table= new gpcas.geometry.EdgeTable();\n\n\t\t\tfor ( var c= 0; c < p.getNumInnerPoly(); c++)\n\t\t\t{\n\t\t\t\tvar ip= p.getInnerPoly(c);\n\t\t\t\tif( !ip.isContributing(0) )\n\t\t\t\t{\n\t\t\t\t\t/* Ignore the non-contributing contour */\n\t\t\t\t\tip.setContributing(0, true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\n\t\t\t\t\t/* Perform contour optimisation */\n\t\t\t\t\tvar num_vertices= 0;\n\t\t\t\t\tvar e_index= 0;\n\t\t\t\t\tedge_table = new gpcas.geometry.EdgeTable();\n\t\t\t\t\tfor ( var i= 0; i < ip.getNumPoints(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( gpcas.geometry.Clip.OPTIMAL(ip, i) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x= ip.getX(i);\n\t\t\t\t\t\t\tvar y= ip.getY(i);\n\t\t\t\t\t\t\tedge_table.addNode( x, y );\n\n\t\t\t\t\t\t\t/* Record vertex in the scanbeam table */\n                            gpcas.geometry.Clip.add_to_sbtree( sbte, ip.getY(i) );\n\n\t\t\t\t\t\t\tnum_vertices++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour forward pass */\n\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a forward local minimum... */\n\t\t\t\t\t\tif( edge_table.FWD_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the next local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.NEXT_INDEX( min, num_vertices );\n\t\t\t\t\t\t\twhile( edge_table.NOT_FMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.NEXT_INDEX( max, num_vertices );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the next edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = gpcas.geometry.BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor ( var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv = gpcas.geometry.Clip.NEXT_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x= ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y= ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx= (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null ;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"fwd\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index += num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Do the contour reverse pass */\n\t\t\t\t\tfor ( var min= 0; min < num_vertices; min++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* If a reverse local minimum... */\n\t\t\t\t\t\tif ( edge_table.REV_MIN( min ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Search for the previous local maximum... */\n\t\t\t\t\t\t\tvar num_edges= 1;\n\t\t\t\t\t\t\tvar max= gpcas.geometry.Clip.PREV_INDEX(min, num_vertices);\n\t\t\t\t\t\t\twhile( edge_table.NOT_RMAX( max ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum_edges++;\n\t\t\t\t\t\t\t\tmax = gpcas.geometry.Clip.PREV_INDEX(max, num_vertices);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Build the previous edge list */\n\t\t\t\t\t\t\tvar v= min;\n\t\t\t\t\t\t\tvar e= edge_table.getNode( e_index );\n\t\t\t\t\t\t\te.bstate[gpcas.geometry.Clip.BELOW] = BundleState.UNBUNDLED;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.CLIP] = 0;\n\t\t\t\t\t\t\te.bundle[gpcas.geometry.Clip.BELOW][gpcas.geometry.Clip.SUBJ] = 0;\n\n\t\t\t\t\t\t\tfor (var i= 0; i < num_edges; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar ei= edge_table.getNode( e_index+i );\n\t\t\t\t\t\t\t\tvar ev= edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.xb    = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.bot.y = ev.vertex.y;\n\n\t\t\t\t\t\t\t\tv= gpcas.geometry.Clip.PREV_INDEX(v, num_vertices);\n\t\t\t\t\t\t\t\tev = edge_table.getNode( v );\n\n\t\t\t\t\t\t\t\tei.top.x = ev.vertex.x;\n\t\t\t\t\t\t\t\tei.top.y = ev.vertex.y;\n\t\t\t\t\t\t\t\tei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n\t\t\t\t\t\t\t\tei.type = type;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.ABOVE] = null;\n\t\t\t\t\t\t\t\tei.outp[gpcas.geometry.Clip.BELOW] = null;\n\t\t\t\t\t\t\t\tei.next = null ;\n\t\t\t\t\t\t\t\tei.prev = null;\n\t\t\t\t\t\t\t\tei.succ = ((num_edges > 1) && (i < (num_edges - 1))) ? edge_table.getNode(e_index+i+1) : null;\n\t\t\t\t\t\t\t\tei.pred = ((num_edges > 1) && (i > 0)) ? edge_table.getNode(e_index+i-1) : null ;\n\t\t\t\t\t\t\t\tei.next_bound = null ;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.CLIP] = (op == gpcas.geometry.OperationType.GPC_DIFF) ? gpcas.geometry.Clip.RIGHT : gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t\tei.bside[gpcas.geometry.Clip.SUBJ] = gpcas.geometry.Clip.LEFT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClip.insert_bound( gpcas.geometry.Clip.bound_list(lmt_table, edge_table.getNode(min).vertex.y), e);\n\t\t\t\t\t\t\tif( gpcas.geometry.Clip.DEBUG )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//console.log(\"rev\");\n\t\t\t\t\t\t\t\tlmt_table.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te_index+= num_edges;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn edge_table;\n\t\t}\n\n\ngpcstatic.add_st_edge = function( st, it, edge, dy) {\n    if (st == null)\n    {\n        /* Append edge onto the tail end of the ST */\n        st = new gpcas.geometry.StNode( edge, null );\n    }\n    else\n    {\n        var den= (st.xt - st.xb) - (edge.xt - edge.xb);\n\n        /* If new edge and ST edge don't cross */\n        if( (edge.xt >= st.xt) || (edge.dx == st.dx) || (Math.abs(den) <= gpcas.geometry.Clip.GPC_EPSILON))\n        {\n            /* No intersection - insert edge here (before the ST edge) */\n            var existing_node= st;\n            st = new StNode( edge, existing_node );\n        }\n        else\n        {\n            /* Compute intersection between new edge and ST edge */\n            var r= (edge.xb - st.xb) / den;\n            var x= st.xb + r * (st.xt - st.xb);\n            var y= r * dy;\n\n            /* Insert the edge pointers and the intersection point in the IT */\n            it.top_node = gpcas.geometry.Clip.add_intersection(it.top_node, st.edge, edge, x, y);\n\n            /* Head further into the ST */\n            st.prev = gpcas.geometry.Clip.add_st_edge(st.prev, it, edge, dy);\n        }\n    }\n    return st ;\n}\n\n\n\ngpcstatic.add_intersection = function ( it_node,\n    edge0,\n    edge1,\n    x,\n    y) {\n    if (it_node == null)\n    {\n        /* Append a new node to the tail of the list */\n        it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, null );\n    }\n    else\n    {\n        if ( it_node.point.y > y)\n        {\n            /* Insert a new node mid-list */\n            var existing_node= it_node ;\n            it_node = new gpcas.geometry.ItNode( edge0, edge1, x, y, existing_node );\n        }\n        else\n        {\n            /* Head further down the list */\n            it_node.next = gpcas.geometry.Clip.add_intersection( it_node.next, edge0, edge1, x, y);\n        }\n    }\n    return it_node ;\n}\n\n\n/////////// AetTree ////////////////////////////////////\ngpcas.geometry.AetTree = function(){\n    this.top_node = null; //EdgeNode\n};\nAetTree = gpcas.geometry.AetTree;\ngpcas.geometry.AetTree.prototype.print = function() {\n    //console.log(\"aet\");\n    for( var edge= this.top_node ; (edge != null) ; edge = edge.next ) {\n        //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n    }\n}\n\n\n///////////////  BundleState  //////////////////////////////\ngpcas.geometry.BundleState = function(state){\n    this.m_State = state ; //String\n};\ngpcas.geometry.BundleState.UNBUNDLED = new gpcas.geometry.BundleState(\"UNBUNDLED\");\ngpcas.geometry.BundleState.BUNDLE_HEAD = new gpcas.geometry.BundleState(\"BUNDLE_HEAD\");\ngpcas.geometry.BundleState.BUNDLE_TAIL = new gpcas.geometry.BundleState(\"BUNDLE_TAIL\");\ngpcas.geometry.BundleState.prototype.toString = function() {\n    return this.m_State;\n};\nBundleState = gpcas.geometry.BundleState;\n\n/////////////// EdgeNode ////////////////////////////\ngpcas.geometry.EdgeNode = function(){\n\tthis.vertex= new Point(); /* Piggy-backed contour vertex data  */\n\tthis.bot= new Point(); /* Edge lower (x, y) coordinate      */\n\tthis.top= new Point(); /* Edge upper (x, y) coordinate      */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.type;         /* Clip / subject edge flag          */\n\tthis.bundle = ArrayHelper.create2DArray(2,2);      /* Bundle edge flags                 */\n\tthis.bside= [];         /* Bundle left / right indicators    */\n\tthis.bstate= []; /* Edge bundle state                 */\n\tthis.outp= []; /* Output polygon / tristrip pointer */\n\tthis.prev;         /* Previous edge in the AET          */\n\tthis.next;         /* Next edge in the AET              */\n\tthis.pred;         /* Edge connected at the lower end   */\n\tthis.succ;         /* Edge connected at the upper end   */\n\tthis.next_bound;   /* Pointer to next bound in LMT      */\n};\n\n\n\n////////////////   EdgeTable /////////////////////////////////////////\n\n\ngpcas.geometry.EdgeTable = function() {\n\tthis.m_List = new gpcas.util.ArrayList();\n};\ngpcas.geometry.EdgeTable.prototype.addNode = function(x,y){\n\tvar node= new gpcas.geometry.EdgeNode();\n    node.vertex.x = x ;\n    node.vertex.y = y ;\n    this.m_List.add( node );\n\n}\ngpcas.geometry.EdgeTable.prototype.getNode = function (index) {\n\treturn this.m_List.get(index);\n}\ngpcas.geometry.EdgeTable.prototype.FWD_MIN = function(i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n\n    return ((prev.vertex.y >= ith.vertex.y) &&\n                 (next.vertex.y >  ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_FMAX = function ( i) {\n\tvar m_List = this.m_List;\n\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return(next.vertex.y > ith.vertex.y);\n}\ngpcas.geometry.EdgeTable.prototype.REV_MIN = function ( i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var next= (m_List.get(Clip.NEXT_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return ((prev.vertex.y >  ith.vertex.y) && (next.vertex.y >= ith.vertex.y));\n}\ngpcas.geometry.EdgeTable.prototype.NOT_RMAX = function (i) {\n\tvar m_List = this.m_List;\n\n    var prev= (m_List.get(Clip.PREV_INDEX(i, m_List.size())));\n    var ith= (m_List.get(i));\n    return (prev.vertex.y > ith.vertex.y) ;\n}\n\n\n/////////////////////   HState   //////////////////////////////////////\ngpcas.geometry.HState = function(){};\ngpcas.geometry.HState.NH = 0; /* No horizontal edge                */\ngpcas.geometry.HState.BH = 1; /* Bottom horizontal edge            */\ngpcas.geometry.HState.TH = 2; /* Top horizontal edge               */\n\nHState = gpcas.geometry.HState;\n\nvar NH = gpcas.geometry.HState.NH;\nvar BH = gpcas.geometry.HState.BH;\nvar TH = gpcas.geometry.HState.TH;\n\n/* Horizontal edge state transitions within scanbeam boundary */\ngpcas.geometry.HState.next_h_state =\n      [\n      /*        ABOVE     BELOW     CROSS */\n      /*        L   R     L   R     L   R */\n      /* NH */ [BH, TH,   TH, BH,   NH, NH],\n      /* BH */ [NH, NH,   NH, NH,   TH, TH],\n      /* TH */ [NH, NH,   NH, NH,   BH, BH]\n      ];\n\n\n\n///////////////////////    \t  IntersectionPoint /////////////////////////////\ngpcas.geometry.IntersectionPoint = function(p1,p2,p3){\n\tthis.polygonPoint1 = p1; /* of Point */;\n\tthis.polygonPoint2 = p2;  /* of Point */;\n\tthis.intersectionPoint = p3 ;\n};\ngpcas.geometry.IntersectionPoint.prototype.toString = function (){\n\treturn \"P1 :\"+polygonPoint1.toString()+\" P2:\"+polygonPoint2.toString()+\" IP:\"+intersectionPoint.toString();\n}\n\n\n///////////////////////////    ItNode   ///////////////\ngpcas.geometry.ItNode = function(edge0, edge1, x, y, next){\n\tthis.ie= [];     /* Intersecting edge (bundle) pair   */\n\tthis.point= new Point(x,y); /* Point of intersection             */\n\tthis.next=next;                         /* The next intersection table node  */\n\n\tthis.ie[0] = edge0 ;\n    this.ie[1] = edge1 ;\n\n};\n\n\n///////////////////////////    ItNodeTable   ///////////////\ngpcas.geometry.ItNodeTable = function(){\n\tthis.top_node;\n}\nItNodeTable = gpcas.geometry.ItNodeTable;\n\ngpcas.geometry.ItNodeTable.prototype.build_intersection_table = function (aet, dy) {\n    var st= null ;\n\n    /* Process each AET edge */\n    for (var edge= aet.top_node ; (edge != null); edge = edge.next)\n    {\n        if( (edge.bstate[Clip.ABOVE] == BundleState.BUNDLE_HEAD) ||\n                (edge.bundle[Clip.ABOVE][Clip.CLIP] != 0) ||\n                (edge.bundle[Clip.ABOVE][Clip.SUBJ] != 0) )\n        {\n            st = gpcas.geometry.Clip.add_st_edge(st, this, edge, dy);\n        }\n\n\n    }\n}\n\n////////////// Line //////////////////////////\ngpcas.geometry.Line = function(){\n\tthis.start;\n\tthis.end;\n}\n\n////////////   LineHelper /////////////////////\n\ngpcas.geometry.LineHelper = function(){};\ngpcas.geometry.LineHelper.equalPoint = function (p1,p2){\n\treturn ((p1[0]==p2[0])&&(p1[1]==p2[1]));\n}\ngpcas.geometry.LineHelper.equalVertex = function(s1,e1,s2,e2) {\n\treturn (\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,s2))&&(gpcas.geometry.LineHelper.equalPoint(e1,e2)))\n\t\t||\n\t\t((gpcas.geometry.LineHelper.equalPoint(s1,e2))&&(gpcas.geometry.LineHelper.equalPoint(e1,s2)))\n\t\t);\n}\ngpcas.geometry.LineHelper.distancePoints = function(p1, p2){\n\treturn Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\n}\ngpcas.geometry.LineHelper.clonePoint = function(p){\n\treturn [p[0],p[1]];\n}\ngpcas.geometry.LineHelper.cloneLine = function(line){\n\tvar res  = [];\n\tfor (var i = 0; i<line.length; i++){\n\t\tres[i]=[line[i][0],line[i][1]];\n\t}\n\treturn res;\n}\ngpcas.geometry.LineHelper.addLineToLine = function(line1,line2) {\n\tfor (var i = 0; i<line2.length; i++){\n\t\tline1.push(clonePoint(line2[i]));\n\t}\n}\ngpcas.geometry.LineHelper.roundPoint = function(p) {\n\tp[0]=Math.round(p[0]);\n\tp[1]=Math.round(p[1]);\n}\n//---------------------------------------------------------------\n//Checks for intersection of Segment if as_seg is true.\n//Checks for intersection of Line if as_seg is false.\n//Return intersection of Segment \"AB\" and Segment \"EF\" as a Point\n//Return null if there is no intersection\n//---------------------------------------------------------------\ngpcas.geometry.LineHelper.lineIntersectLine = function(A,B,E,F,as_seg)\n{\n\tif(as_seg == null) as_seg = true;\n\tvar ip;\n\tvar a1;\n\tvar a2;\n\tvar b1;\n\tvar b2;\n\tvar c1;\n\tvar c2;\n\n\ta1= B.y-A.y;\n\tb1= A.x-B.x;\n\tc1= B.x*A.y - A.x*B.y;\n\ta2= F.y-E.y;\n\tb2= E.x-F.x;\n\tc2= F.x*E.y - E.x*F.y;\n\n\tvar denom=a1*b2 - a2*b1;\n\tif(denom == 0){\n\t\treturn null;\n\t}\n\tip=new Point();\n\tip.x=(b1*c2 - b2*c1)/denom;\n\tip.y=(a2*c1 - a1*c2)/denom;\n\n\t//---------------------------------------------------\n\t//Do checks to see if intersection to endpoints\n\t//distance is longer than actual Segments.\n\t//Return null if it is with any.\n\t//---------------------------------------------------\n\tif(as_seg){\n\t\tif(Math.pow((ip.x - B.x) + (ip.y - B.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - A.x) + (ip.y - A.y), 2) > Math.pow((A.x - B.x) + (A.y - B.y), 2)){\n\t\t\treturn null;\n\t\t}\n\n\t\tif(Math.pow((ip.x - F.x) + (ip.y - F.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t\tif(Math.pow((ip.x - E.x) + (ip.y - E.y), 2) > Math.pow((E.x - F.x) + (E.y - F.y), 2)){\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn new Point(Math.round(ip.x),Math.round(ip.y));\n}\n\n\n//////////////  LineIntersection  ///////////////////////\ngpcas.geometry.LineIntersection = function(){};\ngpcas.geometry.LineIntersection.iteratePoints = function(points, s1, s2,e1,e2) {\n\tvar direction=true;\n\tvar pl = points.length;\n\tvar s1Ind = points.indexOf(s1);\n\tvar s2Ind = points.indexOf(s2);\n\tvar start = s1Ind;\n\n\tif (s2Ind>s1Ind) direction=false;\n\tvar newPoints  = [];\n\tvar point  ;\n\n\tif (direction){\n\t\tfor (var i =0; i<pl; i++){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var i =pl; i>=0; i--){\n\t\t\tpoint=(i+start<pl)?points[i+start]:points[i+start-pl];\n\t\t\tnewPoints.push(point);\n\t\t\tif ((equals(point, e1))||(equals(point, e2))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newPoints;\n}\n\ngpcas.geometry.LineIntersection.intersectPoly = function(poly, line /* of Points */){\n\tvar res = [];\n\tvar numPoints = poly.getNumPoints();\n\n\t//points\n\tvar ip ;\n\tvar p1 ;\n\tvar p2 ;\n\tvar p3 ;\n\tvar p4 ;\n\tvar firstIntersection  = null;\n\tvar lastIntersection   = null;\n\tvar firstIntersectionLineIndex=-1;\n\tvar lastIntersectionLineIndex=-1;\n\tvar firstFound  = false;\n\n\tfor (var i  = 1; i<line.length; i++){\n\t\tp1=line[i-1];\n\t\tp2=line[i];\n\t\tvar maxDist  = 0;\n\t\tvar minDist\t = Number.MAX_VALUE;\n\t\tvar dist  = -1;\n\t\tfor (var j  = 0; j<numPoints; j++){\n\t\t\tp3=poly.getPoint(j==0?numPoints-1:j-1);\n\t\t\tp4=poly.getPoint(j);\n\t\t\tif ((ip=LineHelper.lineIntersectLine(p1,p2,p3,p4))!=null){\n\t\t\t\tdist=Point.distance(ip,p2);\n\n\t\t\t\tif ((dist>maxDist)&&(!firstFound)){\n\t\t\t\t\tmaxDist=dist;\n\t\t\t\t\tfirstIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tfirstIntersectionLineIndex=i;\n\t\t\t\t}\n\t\t\t\tif (dist<minDist){\n\t\t\t\t\tminDist=dist;\n\t\t\t\t\tlastIntersection=new IntersectionPoint(p3,p4,ip);\n\t\t\t\t\tlastIntersectionLineIndex=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfirstFound=(firstIntersection!=null);\n\t}\n\t\t\t/*\n\t\t\tAlert.show(firstIntersection.toString());\n\t\t\tAlert.show(lastIntersection.toString());*/\n\tif ((firstIntersection!=null)&&(lastIntersection!=null)){\n\t\tvar newLine /* of Point */ = [];\n\t\tnewLine[0]=firstIntersection.intersectionPoint;\n\t\tvar j  = 1;\n\t\tfor (var i = firstIntersectionLineIndex; i<=lastIntersectionLineIndex; i++){\n\t\t\tnewLine[j++] = line[i];\n\t\t}\n\t\tnewLine[newLine.length-1]=lastIntersection.intersectionPoint;\n\t\tif (\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint1))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint2))\n\t\t\t)||\n\t\t\t(\n\t\t\t\t(equals(firstIntersection.polygonPoint1, lastIntersection.polygonPoint2))&&\n\t\t\t\t(equals(firstIntersection.polygonPoint2, lastIntersection.polygonPoint1))\n\t\t\t\t)\n\t\t){\n\t\t\t\tvar poly1 = new gpcas.geometry.PolySimple();\n\t\t\t\tpoly1.add(newLine);\n\t\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\t\tvar finPoly2  = poly.xor(poly1);\n\t\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t} else {\n\t\t\tvar points1 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint1,firstIntersection.polygonPoint2, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints1=points1.concat(newLine.reverse());\n\t\t\tvar points2 = iteratePoints(poly.getPoints(),firstIntersection.polygonPoint2,firstIntersection.polygonPoint1, lastIntersection.polygonPoint1, lastIntersection.polygonPoint2);\n\t\t\tpoints2=points2.concat(newLine);\n\t\t\tvar poly1  = new gpcas.geometry.PolySimple();\n\t\t\tpoly1.add(points1);\n\t\t\tvar poly2  = new gpcas.geometry.PolySimple();\n\t\t\tpoly2.add(points2);\n\t\t\tvar finPoly1  = poly.intersection(poly1);\n\t\t\tvar finPoly2  = poly.intersection(poly2);\n\n\t\t\tif ((checkPoly(finPoly1))&&(checkPoly(finPoly2))){\n\t\t\t\t\treturn [finPoly1,finPoly2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n}\ngpcas.geometry.LineIntersection.checkPoly = function(poly) {\n\tvar noHoles =0;\n\tfor (var i  = 0; i<poly.getNumInnerPoly(); i++){\n\t\tvar innerPoly  = poly.getInnerPoly(i);\n\t\tif (innerPoly.isHole()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\tnoHoles++;\n\t\t}\n\t\tif (noHoles>1) return false;\n\t}\n\treturn true;\n}\n\n\n///////////  LmtNode //////////////////////////\n\ngpcas.geometry.LmtNode = function(yvalue) {\n\tthis.y = yvalue;            /* Y coordinate at local minimum     */\n\tthis.first_bound;  /* Pointer to bound list             */\n\tthis.next;         /* Pointer to next local minimum     */\n};\nLmtNode = gpcas.geometry.LmtNode;\n\n////////////// LmtTable ///////////////\n\ngpcas.geometry.LmtTable = function(){\n\tthis.top_node;\n};\ngpcas.geometry.LmtTable.prototype.print = function() {\n    var n= 0;\n    var lmt= this.top_node ;\n    while( lmt != null )\n    {\n\t\t//console.log(\"lmt(\"+n+\")\");\n\t\tfor( var edge= lmt.first_bound ; (edge != null) ; edge = edge.next_bound )\n\t\t{\n\t\t   //console.log(\"edge.vertex.x=\"+edge.vertex.x+\"  edge.vertex.y=\"+edge.vertex.y);\n\t\t}\n\t\tn++ ;\n\t\tlmt = lmt.next ;\n    }\n}\n\n/////////////   OperationType //////////////////////////////////\ngpcas.geometry.OperationType = function(type){\n\tthis.m_Type = type;\n}\ngpcas.geometry.OperationType.GPC_DIFF= new gpcas.geometry.OperationType( \"Difference\" );\ngpcas.geometry.OperationType.GPC_INT= new gpcas.geometry.OperationType( \"Intersection\" );\ngpcas.geometry.OperationType.GPC_XOR= new gpcas.geometry.OperationType( \"Exclusive or\" );\ngpcas.geometry.OperationType.GPC_UNION= new gpcas.geometry.OperationType( \"Union\" );\n\n//////////// Poly  /////////////////////\n// ---> an interface\n\n\n/////////////// PolyDefault  /////////////////////\n/**\n * <code>PolyDefault</code> is a default <code>Poly</code> implementation.\n * It provides support for both complex and simple polygons.  A <i>complex polygon</i>\n * is a polygon that consists of more than one polygon.  A <i>simple polygon</i> is a\n * more traditional polygon that contains of one inner polygon and is just a\n * collection of points.\n * <p>\n * <b>Implementation Note:</b> If a point is added to an empty <code>PolyDefault</code>\n * object, it will create an inner polygon of type <code>PolySimple</code>.\n *\n * @see PolySimple\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolyDefault = function(isHole) {\n\tif(isHole == null) isHole = false;\n\n\t   /**\n    * Only applies to the first poly and can only be used with a poly that contains one poly\n    */\n\tthis.m_IsHole= isHole ;\n    this.m_List= new gpcas.util.ArrayList();\n}\n /**\n    * Return true if the given object is equal to this one.\n    */\ngpcas.geometry.PolyDefault.prototype.equals = function ( obj) {\n    if(!(obj instanceof PolyDefault)){\n\t\treturn false;\n    }\n    var that = obj;\n\n    if( this.m_IsHole != that.m_IsHole ) return false ;\n    if( !equals(this.m_List, that.m_List ) ) return false ;\n\n    return true ;\n}\n   /**\n    * Return the hashCode of the object.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    **/\ngpcas.geometry.PolyDefault.prototype.hashCode = function () {\n\tvar m_List = this.m_List;\n\n    var result= 17;\n    result = 37*result + m_List.hashCode();\n    return result;\n}\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.clear = function() {\n    this.m_List.clear();\n}\n\ngpcas.geometry.PolyDefault.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\tif (args.length==2){\n\t\tthis.addPointXY(args[0], args[1]);\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n   \t\t\tthis.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof gpcas.geometry.PolySimple){\n   \t\t\tthis.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n   \t\t\tvar arr  = args[0];\n   \t\t\tif ((arr.length==2)&&(arr[0] instanceof Number)&&(arr[1] instanceof Number)){\n   \t\t\t\tthis.add(arr[0] ,arr[1] )\n   \t\t\t} else {\n   \t\t\t\tfor(var i=0; i<args[0].length ; i++) {\n\t\t\t\t\tthis.add(args[0][i]);\n\t\t\t\t}\n   \t\t\t}\n   \t\t}\n   \t}\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPointXY = function(x, y) {\n    this.addPoint(new Point( x, y ));\n}\n   /**\n    * Add a point to the first inner polygon.\n    * <p>\n    * <b>Implementation Note:</b> If a point is added to an empty PolyDefault object,\n    * it will create an inner polygon of type <code>PolySimple</code>.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoint = function( p) {\n\n\n\tvar m_List = this.m_List;\n\n    if( m_List.size() == 0)\n    {\n        m_List.add(new gpcas.geometry.PolySimple());\n    }\n    (m_List.get(0)).addPoint(p);\n}\n /**\n    * Add an inner polygon to this polygon - assumes that adding polygon does not\n    * have any inner polygons.\n    *\n    * @throws IllegalStateException if the number of inner polygons is greater than\n    * zero and this polygon was designated a hole.  This would break the assumption\n    * that only simple polygons can be holes.\n    */\ngpcas.geometry.PolyDefault.prototype.addPoly = function( p) {\n\n\tvar m_IsHole = this.m_IsHole;\n\tvar m_List = this.m_List;\n\n    if( (m_List.size() > 0) && m_IsHole )\n      {\n         alert(\"ERROR : Cannot add polys to something designated as a hole.\");\n      }\n    m_List.add( p );\n}\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolyDefault.prototype.isEmpty = function() {\n    return this.m_List.isEmpty();\n}\n /**\n    * Returns the bounding rectangle of this polygon.\n    * <strong>WARNING</strong> Not supported on complex polygons.\n    */\ngpcas.geometry.PolyDefault.prototype.getBounds = function () {\n\tvar m_List = this.m_List;\n    if( m_List.size() == 0)\n    {\n        return new Rectangle();\n    }\n    else if( m_List.size() == 1)\n    {\n         var ip= this.getInnerPoly(0);\n         return ip.getBounds();\n    }\n    else\n    {\n         console.log(\"getBounds not supported on complex poly.\");\n    }\n}\n   /**\n    * Returns the polygon at this index.\n    */\ngpcas.geometry.PolyDefault.prototype.getInnerPoly = function(polyIndex) {\n      return this.m_List.get(polyIndex);\n}\n   /**\n    * Returns the number of inner polygons - inner polygons are assumed to return one here.\n    */\ngpcas.geometry.PolyDefault.prototype.getNumInnerPoly = function() {\n\tvar m_List = this.m_List;\n      return m_List.size();\n}\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getNumPoints = function () {\n    return (this.m_List.get(0)).getNumPoints() ;\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getX = function(index) {\n      return (this.m_List.get(0)).getX(index) ;\n}\ngpcas.geometry.PolyDefault.prototype.getPoint = function(index){\n\t\treturn (this.m_List.get(0)).getPoint(index) ;\n}\n\ngpcas.geometry.PolyDefault.prototype.getPoints = function(){\n\treturn (this.m_List.get(0)).getPoints();\n}\n\n\ngpcas.geometry.PolyDefault.prototype.isPointInside = function (point) {\n\tvar m_List = this.m_List;\n   \tif (!(m_List.get(0)).isPointInside(point)) return false;\n\n\tfor (var i  = 0; i<m_List.size(); i++){\n   \t\tvar poly  = m_List.get(i);\n   \t\t\tif ((poly.isHole())&&(poly.isPointInside(point))) return false;\n   \t\t}\n   \t\treturn true;\n}\n     /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolyDefault.prototype.getY = function (index) {\n\tvar m_List = this.m_List;\n      return (m_List.get(0)).getY(index) ;\n}\n\n   /**\n    * Return true if this polygon is a hole.  Holes are assumed to be inner polygons of\n    * a more complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.isHole = function () {\n\tvar m_List = this.m_List;\n\tvar m_IsHole = this.m_IsHole;\n\n      if( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n      return m_IsHole ;\n}\n\n   /**\n    * Set whether or not this polygon is a hole.  Cannot be called on a complex polygon.\n    *\n    * @throws IllegalStateException if called on a complex polygon.\n    */\ngpcas.geometry.PolyDefault.prototype.setIsHole = function(isHole) {\n    var m_List = this.m_List;\n\tif( m_List.size() > 1)\n      {\n         alert( \"Cannot call on a poly made up of more than one poly.\" );\n      }\n    this.m_IsHole = isHole ;\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    */\ngpcas.geometry.PolyDefault.prototype.isContributing = function( polyIndex) {\n      var m_List = this.m_List;\n\t  return (m_List.get(polyIndex)).isContributing(0);\n}\n\n    /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if called on a complex polygon\n    */\ngpcas.geometry.PolyDefault.prototype.setContributing = function( polyIndex, contributes) {\n    var m_List = this.m_List;\n\tif( m_List.size() != 1)\n      {\n        alert( \"Only applies to polys of size 1\" );\n      }\n     (m_List.get(polyIndex)).setContributing( 0, contributes );\n}\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.union = function(p) {\n\treturn gpcas.geometry.Clip.union( p, this, \"PolyDefault\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon could be complex.\n    *\n    * @return the returned Poly will be an instance of PolyDefault.\n    */\ngpcas.geometry.PolyDefault.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolyDefault\" );\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolyDefault.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolyDefault\");\n}\n\n   /**\n    * Return the area of the polygon in square units.\n    */\ngpcas.geometry.PolyDefault.prototype.getArea = function() {\n      var area= 0.0;\n      for( var i= 0; i < getNumInnerPoly() ; i++ )\n      {\n         var p= getInnerPoly(i);\n         var tarea = p.getArea() * (p.isHole() ? -1.0: 1.0);\n         area += tarea ;\n      }\n      return area ;\n}\n\n   // -----------------------\n   // --- Package Methods ---\n   // -----------------------\ngpcas.geometry.PolyDefault.prototype.toString = function() {\n    var res  = \"\";\n\tvar m_List = this.m_List;\n    for( var i= 0; i < m_List.size() ; i++ )\n    {\n         var p = this.getInnerPoly(i);\n         res+=(\"InnerPoly(\"+i+\").hole=\"+p.isHole());\n         var points = [];\n         for( var j= 0; j < p.getNumPoints() ; j++ )\n         {\n         \tpoints.push(new Point(p.getX(j),p.getY(j)));\n         }\n         points = ArrayHelper.sortPointsClockwise(points) ;\n\n\t\t for(var k =0 ; k< points.length ; k++) {\n\t\t\tres+=points[k].toString();\n\t\t }\n\n      }\n      return res;\n   }\n\n///////////////  Polygon   /////////////////////////////////\ngpcas.geometry.Polygon = function(){\n\tthis.maxTop ;\n\tthis.maxBottom ;\n\tthis.maxLeft ;\n\tthis.maxRight ;\n\tthis.vertices  /* of Point */;\n};\ngpcas.geometry.Polygon.prototype.fromArray = function(v) {\n\tthis.vertices = [];\n\n\tfor(var i=0 ; i<v.length ; i++) {\n\t\tvar pointArr = v[i];\n\t\tthis.vertices.push(new Point(pointArr[0],pointArr[1]));\n\t}\n}\n\n\t\t/*Normalize vertices in polygon to be ordered clockwise from most left point*/\ngpcas.geometry.Polygon.prototype.normalize = function() {\n\tvar maxLeftIndex ;\n\tvar vertices = this.vertices;\n\tvar newVertices = this.vertices;\n\n\tfor (var i  = 0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\n\t\tif ((maxTop==null)||(maxTop.y>vertex.y)||((maxTop.y==vertex.y)&&(vertex.x<maxTop.x))){\n\t\t\tmaxTop=vertex;\n\t\t}\n\t\tif ((maxBottom==null)||(maxBottom.y<vertex.y)||((maxBottom.y==vertex.y)&&(vertex.x>maxBottom.x))){\n\t\t\tmaxBottom=vertex;\n\t\t}\n \t\tif ((maxLeft==null)||(maxLeft.x>vertex.x)||((maxLeft.x==vertex.x)&&(vertex.y>maxLeft.y))){\n\t\t\tmaxLeft=vertex;\n\t\t\tmaxLeftIndex=i;\n\t\t}\n\t\tif ((maxRight==null)||(maxRight.x<vertex.x)||((maxRight.x==vertex.x)&&(vertex.y<maxRight.y))){\n\t\t\tmaxRight=vertex;\n\t\t}\n\t}\n\n\tif (maxLeftIndex>0){\n\t\tnewVertices = [];\n\t\tvar j = 0;\n\t\tfor (var i=maxLeftIndex; i<vertices.length;i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tfor (var i=0; i<maxLeftIndex; i++){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n\tvar reverse   = false;\n\tfor(var k=0; k<this.vertices.length ; k++) {\n\t\tvar vertex  =  this.vertices[k];\n\t    if (equals(vertex, maxBottom)){\n\t\t\treverse=true;\n\t\t\tbreak;\n\t\t} else if (equals(vertex, maxTop)){\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reverse){\n\t\tnewVertices= [];\n\t\tnewVertices[0]=vertices[0];\n\t\tvar j =1;\n\t\tfor (var i=vertices.length-1; i>0; i--){\n\t\t\tnewVertices[j++]=this.vertices[i];\n\t\t}\n\t\tvertices=newVertices;\n\t}\n}\ngpcas.geometry.Polygon.prototype.getVertexIndex = function(vertex){\n\tfor (var i=0; i<this.vertices.length; i++){\n\t\tif (equals(vertices[i], vertex)){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\ngpcas.geometry.Polygon.prototype.insertVertex = function(vertex1,vertex2, newVertex){\n\tvar vertex1Index  = getVertexIndex(vertex1);\n\tvar vertex2Index  = getVertexIndex(vertex2);\n\tif ((vertex1Index==-1)||(vertex2Index==-1)){\n\t\treturn false;\n\t}\n\n\tif (vertex2Index<vertex1Index){\n\t\tvar i  = vertex1Index;\n\t\tvertex1Index=vertex2Index;\n\t\tvertex2Index=i;\n\t}\n\tif (vertex2Index==vertex1Index+1){\n\t\tvar newVertices  = [];\n\t\tfor (var i =0; i<=vertex1Index; i++){\n\t\t\tnewVertices[i]=this.vertices[i];\n\t\t}\n\t\tnewVertices[vertex2Index]=newVertex;\n\t\tfor (var i =vertex2Index; i<this.vertices.length; i++){\n\t\t\tnewVertices[i+1]=this.vertices[i];\n\t\t}\n\t\tthis.vertices=newVertices;\n\t} else if ((vertex2Index==vertices.length-1)&&(vertex1Index==0)){\n\t\tthis.vertices.push(newVertex);\n\t}\n\treturn true;\n}\ngpcas.geometry.Polygon.prototype.clone = function() {\n\tvar res = new gpcas.geometry.Polygon();\n\tres.vertices=vertices.slice(this.vertices.length-1);\n\treturn res;\n}\ngpcas.geometry.Polygon.prototype.toString = function() {\n\tvar vertices = this.vertices;\n\tvar res  = \"[\";\n\tfor (var i  =0; i<vertices.length; i++){\n\t\tvar vertex  = vertices[i];\n\t\tres+=(i>0?\",\":\"\")+\"[\"+vertex.x+\",\"+vertex.y+\"]\";\n\t}\n\tres+=\"]\";\n\treturn res;\n}\n\n\n////////////////////  PolygonNode ///////////////////////////\ngpcas.geometry.PolygonNode = function(next, x, y) {\n\n\n\tthis.active;                 /* Active flag / vertex count        */\n\tthis.hole;                /* Hole / external contour flag      */\n\tthis.v= [] ; /* Left and right vertex list ptrs   */\n\tthis.next;                   /* Pointer to next polygon contour   */\n\tthis.proxy;                  /* Pointer to actual structure used  */\n\n\t/* Make v[Clip.LEFT] and v[Clip.RIGHT] point to new vertex */\n\tvar vn= new VertexNode( x, y );\n\n\tthis.v[Clip.LEFT ] = vn ;\n\tthis.v[Clip.RIGHT] = vn ;\n\n\tthis.next = next ;\n\tthis.proxy = this ; /* Initialise proxy to point to p itself */\n\tthis.active = 1; //TRUE\n}\ngpcas.geometry.PolygonNode.prototype.add_right = function( x, y) {\n\tvar nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the right end of the polygon's vertex list */\n\t this.proxy.v[Clip.RIGHT].next= nv;\n\n\t /* Update proxy->v[Clip.RIGHT] to point to nv */\n\t this.proxy.v[Clip.RIGHT]= nv;\n}\ngpcas.geometry.PolygonNode.prototype.add_left = function( x, y) {\n\t var proxy = this.proxy;\n\n\t var nv= new VertexNode( x, y );\n\n\t /* Add vertex nv to the left end of the polygon's vertex list */\n\t nv.next= proxy.v[Clip.LEFT];\n\n\t /* Update proxy->[Clip.LEFT] to point to nv */\n\t proxy.v[Clip.LEFT]= nv;\n}\n\n\n//////////////////   PolySimple ////////////////\n\n/**\n * <code>PolySimple</code> is a simple polygon - contains only one inner polygon.\n * <p>\n * <strong>WARNING:</strong> This type of <code>Poly</code> cannot be used for an\n * inner polygon that is a hole.\n *\n * @author  Dan Bridenbecker, Solution Engineering, Inc.\n */\ngpcas.geometry.PolySimple = function(){\n\t/**\n    * The list of Point objects in the polygon.\n    */\n   this.m_List= new gpcas.util.ArrayList();\n\n   /** Flag used by the Clip algorithm */\n   this.m_Contributes= true ;\n};\n\n   /**\n    * Return true if the given object is equal to this one.\n    * <p>\n    * <strong>WARNING:</strong> This method failse if the first point\n    * appears more than once in the list.\n    */\ngpcas.geometry.PolySimple.prototype.equals = function(obj) {\n  if( !(obj instanceof PolySimple) )\n  {\n\t return false;\n  }\n\n  var that= obj;\n\n  var this_num= this.m_List.size();\n  var that_num= that.m_List.size();\n  if( this_num != that_num ) return false ;\n\n\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING: This is not the greatest algorithm.  It fails if !!!\n  // !!! the first point in \"this\" poly appears more than once.    !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  if( this_num > 0)\n  {\n\t var this_x= this.getX(0);\n\t var this_y= this.getY(0);\n\t var that_first_index = -1;\n\t for( var that_index= 0; (that_first_index == -1) && (that_index < that_num) ; that_index++ )\n\t {\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\t\tif( (this_x == that_x) && (this_y == that_y) )\n\t\t{\n\t\t   that_first_index = that_index ;\n\t\t}\n\t }\n\t if( that_first_index == -1) return false ;\n\t var that_index= that_first_index ;\n\t for( var this_index= 0; this_index < this_num ; this_index++ )\n\t {\n\t\tthis_x = this.getX(this_index);\n\t\tthis_y = this.getY(this_index);\n\t\tvar that_x= that.getX(that_index);\n\t\tvar that_y= that.getY(that_index);\n\n\t\tif( (this_x != that_x) || (this_y != that_y) ) return false;\n\n\t\tthat_index++ ;\n\t\tif( that_index >= that_num )\n\t\t{\n\t\t   that_index = 0;\n\t\t}\n\t }\n  }\n  return true ;\n}\n\n   /**\n    * Return the hashCode of the object.\n    * <p>\n    * <strong>WARNING:</strong>Hash and Equals break contract.\n    *\n    * @return an integer value that is the same for two objects\n    * whenever their internal representation is the same (equals() is true)\n    */\ngpcas.geometry.PolySimple.prototype.hashCode = function() {\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // !!! WARNING:  This hash and equals break the contract. !!!\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  var result= 17;\n  result = 37*result + this.m_List.hashCode();\n  return result;\n}\n\n   /**\n    * Return a string briefly describing the polygon.\n    */\ngpcas.geometry.PolySimple.prototype.toString = function() {\n    return \"PolySimple: num_points=\"+getNumPoints();\n}\n\n   // --------------------\n   // --- Poly Methods ---\n   // --------------------\n   /**\n    * Remove all of the points.  Creates an empty polygon.\n    */\ngpcas.geometry.PolySimple.prototype.clear = function() {\n      this.m_List.clear();\n}\n\n\ngpcas.geometry.PolySimple.prototype.add = function(arg0,arg1) {\n\tvar args = [];\n\targs[0] = arg0;\n\tif(arg1) {\n\t\targs[1] = arg1;\n\t}\n\n   \tif (args.length==2){\n\t\tthis.addPointXY(args[0] , args[1] );\n   \t} else if (args.length==1){\n   \t\tif (args[0] instanceof Point){\n               this.addPoint(args[0]);\n   \t\t} else if (args[0] instanceof Poly){\n               this.addPoly(args[0]);\n   \t\t} else if (args[0] instanceof Array){\n\t\t\tfor(var k=0 ; k<args[0].length ; k++) {\n\t\t\t\tvar val = args[0][k];\n                this.add(val);\n\t\t\t}\n   \t\t}\n   \t}\n}\n\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPointXY = function(x, y) {\n    this.addPoint( new Point( x, y ) );\n}\n\n   /**\n    * Add a point to the first inner polygon.\n    */\ngpcas.geometry.PolySimple.prototype.addPoint = function(p) {\n      this.m_List.add( p );\n}\n\n   /**\n    * Throws IllegalStateexception if called\n    */\ngpcas.geometry.PolySimple.prototype.addPoly = function(p) {\n    alert(\"Cannot add poly to a simple poly.\");\n}\n\n   /**\n    * Return true if the polygon is empty\n    */\ngpcas.geometry.PolySimple.prototype.isEmpty = function() {\n      return this.m_List.isEmpty();\n}\n\n   /**\n    * Returns the bounding rectangle of this polygon.\n    */\ngpcas.geometry.PolySimple.prototype.getBounds = function() {\n\t  var xmin=  Number.MAX_VALUE ;\n\t  var ymin=  Number.MAX_VALUE ;\n\t  var xmax= -Number.MAX_VALUE ;\n\t  var ymax= -Number.MAX_VALUE ;\n\n      for( var i= 0; i < this.m_List.size() ; i++ )\n      {\n         var x= this.getX(i);\n         var y= this.getY(i);\n         if( x < xmin ) xmin = x;\n         if( x > xmax ) xmax = x;\n         if( y < ymin ) ymin = y;\n         if( y > ymax ) ymax = y;\n      }\n\n      return new Rectangle( xmin, ymin, (xmax-xmin), (ymax-ymin) );\n   }\n\n   /**\n    * Returns <code>this</code> if <code>polyIndex = 0</code>, else it throws\n    * IllegalStateException.\n    */\ngpcas.geometry.PolySimple.prototype.getInnerPoly = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this ;\n}\n\n   /**\n    * Always returns 1.\n    */\ngpcas.geometry.PolySimple.prototype.getNumInnerPoly = function() {\n    return 1;\n}\n\n   /**\n    * Return the number points of the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getNumPoints = function() {\n      return this.m_List.size();\n}\n\n   /**\n    * Return the X value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getX = function(index) {\n    return (this.m_List.get(index)).x;\n}\n\n   /**\n    * Return the Y value of the point at the index in the first inner polygon\n    */\ngpcas.geometry.PolySimple.prototype.getY = function(index) {\n    return (this.m_List.get(index)).y;\n}\n\ngpcas.geometry.PolySimple.prototype.getPoint = function(index){\n\treturn (this.m_List.get(index));\n}\n\ngpcas.geometry.PolySimple.prototype.getPoints = function() {\n\treturn this.m_List.toArray();\n}\n\ngpcas.geometry.PolySimple.prototype.isPointInside = function(point) {\n\t var points  = this.getPoints();\n\t var j  = points.length - 1;\n\t var oddNodes = false;\n\n\t for (var i  = 0; i < points.length; i++)\n\t {\n\t\t if (points[i].y < point.y && points[j].y >= point.y ||\n\t\t\t points[j].y < point.y && points[i].y >= point.y)\n\t\t {\n\t\t\t if (points[i].x +\n\t\t\t\t (point.y - points[i].y)/(points[j].y - points[i].y)*(points[j].x - points[i].x) < point.x)\n\t\t\t {\n\t\t\t\t oddNodes = !oddNodes;\n\t\t\t}\n\t\t }\n\t\t j = i;\n\t }\n\t return oddNodes;\n}\n\n\n   /**\n    * Always returns false since PolySimples cannot be holes.\n    */\ngpcas.geometry.PolySimple.prototype.isHole = function() {\n      return false ;\n}\n\n   /**\n    * Throws IllegalStateException if called.\n    */\ngpcas.geometry.PolySimple.prototype.setIsHole =function(isHole) {\n    alert(\"PolySimple cannot be a hole\");\n}\n\n   /**\n    * Return true if the given inner polygon is contributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.isContributing = function(polyIndex) {\n  if( polyIndex != 0)\n  {\n\t alert(\"PolySimple only has one poly\");\n  }\n  return this.m_Contributes ;\n}\n\n   /**\n    * Set whether or not this inner polygon is constributing to the set operation.\n    * This method should NOT be used outside the Clip algorithm.\n    *\n    * @throws IllegalStateException if <code>polyIndex != 0</code>\n    */\ngpcas.geometry.PolySimple.prototype.setContributing = function( polyIndex, contributes) {\n      if( polyIndex != 0)\n      {\n         alert(\"PolySimple only has one poly\");\n      }\n      this.m_Contributes = contributes ;\n   }\n\n   /**\n    * Return a Poly that is the intersection of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.intersection = function(p) {\n    return gpcas.geometry.Clip.intersection( this, p,\"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the union of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.union = function(p) {\n      return gpcas.geometry.Clip.union( this, p, \"PolySimple\");\n}\n\n   /**\n    * Return a Poly that is the exclusive-or of this polygon with the given polygon.\n    * The returned polygon is simple.\n    *\n    * @return The returned Poly is of type PolySimple\n    */\ngpcas.geometry.PolySimple.prototype.xor = function(p) {\n    return gpcas.geometry.Clip.xor( p, this, \"PolySimple\");\n}\n\n   /**\n\t* Return a Poly that is the difference of this polygon with the given polygon.\n\t* The returned polygon could be complex.\n\t*\n\t* @return the returned Poly will be an instance of PolyDefault.\n\t*/\ngpcas.geometry.PolySimple.prototype.difference = function(p){\n\treturn gpcas.geometry.Clip.difference(p,this,\"PolySimple\");\n}\n\n   /**\n    * Returns the area of the polygon.\n    * <p>\n    * The algorithm for the area of a complex polygon was take from\n    * code by Joseph O'Rourke author of \" Computational Geometry in C\".\n    */\ngpcas.geometry.PolySimple.prototype.getArea = function() {\n      if( this.getNumPoints() < 3)\n      {\n         return 0.0;\n      }\n      var ax= this.getX(0);\n      var ay= this.getY(0);\n\n      var area= 0.0;\n      for( var i= 1; i < (this.getNumPoints()-1) ; i++ )\n      {\n         var bx= this.getX(i);\n         var by= this.getY(i);\n         var cx= this.getX(i+1);\n         var cy= this.getY(i+1);\n         var tarea= ((cx - bx)*(ay - by)) - ((ax - bx)*(cy - by));\n         area += tarea ;\n      }\n      area = 0.5*Math.abs(area);\n      return area ;\n   }\n\n  /////////////////////// Rectangle  ///////////////////\ngpcas.geometry.Rectangle = function(_x, _y, _w, _h) {\n\tthis.x = _x;\n\tthis.y = _y;\n\tthis.w = _w;\n\tthis.h = _h;\n}\ngpcas.geometry.Rectangle.prototype.getMaxY = function(){\n\treturn this.y+this.h;\n}\ngpcas.geometry.Rectangle.prototype.getMinY = function(){\n\treturn this.y;\n}\ngpcas.geometry.Rectangle.prototype.getMaxX = function() {\n\treturn this.x+this.w;\n}\ngpcas.geometry.Rectangle.prototype.getMinX = function(){\n\treturn this.x;\n}\ngpcas.geometry.Rectangle.prototype.toString = function(){\n\treturn \"[\"+x.toString()+\" \"+y.toString()+\" \"+w.toString()+\" \"+h.toString()+\"]\";\n}\n\n/////////////////// ScanBeamTree //////////////////////\ngpcas.geometry.ScanBeamTree = function(yvalue) {\n\tthis.y = yvalue;         /* Scanbeam node y value             */\n\tthis.less;         /* Pointer to nodes with lower y     */\n\tthis.more;         /* Pointer to nodes with higher y    */\n}\n\n///////////////////////// ScanBeamTreeEntries /////////////////\ngpcas.geometry.ScanBeamTreeEntries = function(){\n\tthis.sbt_entries=0;\n\tthis.sb_tree;\n};\ngpcas.geometry.ScanBeamTreeEntries.prototype.build_sbt = function() {\n\tvar sbt= [];\n\n\tvar entries= 0;\n\tentries = this.inner_build_sbt( entries, sbt, this.sb_tree );\n\n\t//console.log(\"SBT = \"+this.sbt_entries);\n\n\tif( entries != this.sbt_entries )\n\t{\n\t//console.log(\"Something went wrong buildign sbt from tree.\");\n\t}\n\treturn sbt ;\n}\ngpcas.geometry.ScanBeamTreeEntries.prototype.inner_build_sbt = function( entries, sbt, sbt_node) {\n\tif( sbt_node.less != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.less);\n\t }\n\t sbt[entries]= sbt_node.y;\n\t entries++;\n\t if( sbt_node.more != null )\n\t {\n\t\tentries = this.inner_build_sbt(entries, sbt, sbt_node.more );\n\t }\n\t return entries ;\n}\n\n///////////////////////////  StNode\nStNode = gpcas.geometry.StNode = function( edge, prev) {\n\tthis.edge;         /* Pointer to AET edge               */\n\tthis.xb;           /* Scanbeam bottom x coordinate      */\n\tthis.xt;           /* Scanbeam top x coordinate         */\n\tthis.dx;           /* Change in x for a unit y increase */\n\tthis.prev;         /* Previous edge in sorted list      */\n\n\tthis.edge = edge ;\n\t this.xb = edge.xb ;\n\t this.xt = edge.xt ;\n\t this.dx = edge.dx ;\n\t this.prev = prev ;\n}\n\n/////////////////////   TopPolygonNode /////////////////\ngpcas.geometry.TopPolygonNode = function(){\n\tthis.top_node;\n};\nTopPolygonNode = gpcas.geometry.TopPolygonNode;\n\ngpcas.geometry.TopPolygonNode.prototype.add_local_min = function( x, y) {\n\t var existing_min= this.top_node;\n\t this.top_node = new gpcas.geometry.PolygonNode( existing_min, x, y );\n\t return this.top_node ;\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_left = function( p, q) {\n /* Label contour as a hole */\n q.proxy.hole = true ;\n var top_node = this.top_node;\n\n if (p.proxy != q.proxy) {\n\t/* Assign p's vertex list to the left end of q's list */\n\tp.proxy.v[Clip.RIGHT].next= q.proxy.v[Clip.LEFT];\n\tq.proxy.v[Clip.LEFT]= p.proxy.v[Clip.LEFT];\n\n\t/* Redirect any p.proxy references to q.proxy */\n\tvar target= p.proxy ;\n\tfor(var node= top_node; (node != null); node = node.next)\n\t{\n\t   if (node.proxy == target)\n\t   {\n\t\t  node.active= 0;\n\t\t  node.proxy= q.proxy;\n\t   }\n\t}\n }\n}\ngpcas.geometry.TopPolygonNode.prototype.merge_right = function( p, q) {\n\t var top_node = this.top_node;\n\t /* Label contour as external */\n\t q.proxy.hole = false ;\n\n\t if (p.proxy != q.proxy)\n\t {\n\t\t/* Assign p's vertex list to the right end of q's list */\n\t\tq.proxy.v[Clip.RIGHT].next= p.proxy.v[Clip.LEFT];\n\t\tq.proxy.v[Clip.RIGHT]= p.proxy.v[Clip.RIGHT];\n\n\t\t/* Redirect any p->proxy references to q->proxy */\n\t\tvar target= p.proxy ;\n\t\tfor (var node = top_node ; (node != null ); node = node.next)\n\t\t{\n\t\t   if (node.proxy == target)\n\t\t   {\n\t\t\t  node.active = 0;\n\t\t\t  node.proxy= q.proxy;\n\t\t   }\n\t\t}\n\t }\n  }\ngpcas.geometry.TopPolygonNode.prototype.count_contours = function() {\nvar nc= 0;\n\nfor ( var polygon= this.top_node; (polygon != null) ; polygon = polygon.next)\n\t {\n\t\tif (polygon.active != 0)\n\t\t{\n\t\t   /* Count the vertices in the current contour */\n\t\t   var nv= 0;\n\t\t   for (var v= polygon.proxy.v[Clip.LEFT]; (v != null); v = v.next)\n\t\t   {\n\t\t\t  nv++;\n\t\t   }\n\n\t\t   /* Record valid vertex counts in the active field */\n\t\t   if (nv > 2)\n\t\t   {\n\t\t\t  polygon.active = nv;\n\t\t\t  nc++;\n\t\t   }\n\t\t   else\n\t\t   {\n\t\t\t  /* Invalid contour: just free the heap */\n//                  VertexNode nextv = null ;\n//                  for (VertexNode v= polygon.proxy.v[Clip.LEFT]; (v != null); v = nextv)\n//                  {\n//                     nextv= v.next;\n//                     v = null ;\n//                  }\n\t\t\t  polygon.active= 0;\n\t\t   }\n\t\t}\n\t }\n\t return nc;\n  }\ngpcas.geometry.TopPolygonNode.prototype.getResult = function(polyClass) {\n\nvar top_node = this.top_node;\nvar result= gpcas.geometry.Clip.createNewPoly( polyClass );\n//console.log(polyClass);\n\n\nvar num_contours = this.count_contours();\n\nif (num_contours > 0)\n\t {\n\t\tvar c= 0;\n\t\tvar npoly_node= null ;\n\t\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t\t{\n\t\t   npoly_node = poly_node.next;\n\t\t   if (poly_node.active != 0)\n\t\t   {\n\n\t\t\t  var poly = result ;\n\n\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t poly = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\t\t  }\n\t\t\t  if( poly_node.proxy.hole )\n\t\t\t  {\n\t\t\t\t poly.setIsHole( poly_node.proxy.hole );\n\t\t\t  }\n\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  // --- This algorithm puts the verticies into the poly in reverse order ---\n\t\t\t  // ------------------------------------------------------------------------\n\t\t\t  for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t\t  {\n\t\t\t\t poly.add( vtx.x, vtx.y );\n\t\t\t  }\n\t\t\t  if( num_contours > 1)\n\t\t\t  {\n\t\t\t\t result.addPoly( poly );\n\t\t\t  }\n\t\t\t  c++;\n\t\t   }\n\t\t}\n\n\t\t// -----------------------------------------\n\t\t// --- Sort holes to the end of the list ---\n\t\t// -----------------------------------------\n\t\tvar orig= result ;\n\t\tresult = gpcas.geometry.Clip.createNewPoly( polyClass );\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( !inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t\tfor( var i= 0; i < orig.getNumInnerPoly() ; i++ )\n\t\t{\n\t\t   var inner= orig.getInnerPoly(i);\n\t\t   if( inner.isHole() )\n\t\t   {\n\t\t\t  result.addPoly(inner);\n\t\t   }\n\t\t}\n\t }\n\t return result ;\n  }\ngpcas.geometry.TopPolygonNode.prototype.print = function() {\n    //console.log(\"---- out_poly ----\");\n\tvar top_node = this.top_node;\n    var c= 0;\n    var npoly_node= null ;\n\tfor (var poly_node= top_node; (poly_node != null); poly_node = npoly_node)\n\t {\n\t\t//console.log(\"contour=\"+c+\"  active=\"+poly_node.active+\"  hole=\"+poly_node.proxy.hole);\n\t\tnpoly_node = poly_node.next;\n\t\tif (poly_node.active != 0)\n\t\t{\n\t\t   var v=0;\n\t\t   for (var vtx= poly_node.proxy.v[Clip.LEFT]; (vtx != null) ; vtx = vtx.next )\n\t\t   {\n\t\t\t  //console.log(\"v=\"+v+\"  vtx.x=\"+vtx.x+\"  vtx.y=\"+vtx.y);\n\t\t   }\n\t\t   c++;\n\t\t}\n\t }\n}\n\n  ///////////    VertexNode  ///////////////\ngpcas.geometry.VertexNode = function( x, y) {\n\tthis.x;    // X coordinate component\n\tthis.y;    // Y coordinate component\n\tthis.next; // Pointer to next vertex in list\n\n\tthis.x = x ;\n    this.y = y ;\n    this.next = null ;\n}\nVertexNode = gpcas.geometry.VertexNode;\n\n/////////////   VertexType   /////////////\ngpcas.geometry.VertexType = function(){};\ngpcas.geometry.VertexType.NUL=  0; /* Empty non-intersection            */\ngpcas.geometry.VertexType.EMX=  1; /* External maximum                  */\ngpcas.geometry.VertexType.ELI=  2; /* External left intermediate        */\ngpcas.geometry.VertexType.TED=  3; /* Top edge                          */\ngpcas.geometry.VertexType.ERI=  4; /* External right intermediate       */\ngpcas.geometry.VertexType.RED=  5; /* Right edge                        */\ngpcas.geometry.VertexType.IMM=  6; /* Internal maximum and minimum      */\ngpcas.geometry.VertexType.IMN=  7; /* Internal minimum                  */\ngpcas.geometry.VertexType.EMN=  8; /* External minimum                  */\ngpcas.geometry.VertexType.EMM=  9; /* External maximum and minimum      */\ngpcas.geometry.VertexType.LED= 10; /* Left edge                         */\ngpcas.geometry.VertexType.ILI= 11; /* Internal left intermediate        */\ngpcas.geometry.VertexType.BED= 12; /* Bottom edge                       */\ngpcas.geometry.VertexType.IRI= 13; /* Internal right intermediate       */\ngpcas.geometry.VertexType.IMX= 14; /* Internal maximum                  */\ngpcas.geometry.VertexType.FUL= 15; /* Full non-intersection             */\ngpcas.geometry.VertexType.getType = function( tr, tl ,br ,bl) {\n    return tr + (tl << 1) + (br << 2) + (bl << 3);\n}\n\nVertexType = gpcas.geometry.VertexType;\n\n////////////////// WeilerAtherton  /////////////\ngpcas.geometry.WeilerAtherton = function(){};\n\ngpcas.geometry.WeilerAtherton.prototype.merge = function(p1,p2) {\n\tp1=p1.clone();\n\tp2=p2.clone();\n}\n","'use strict';\n\n/*jshint -W072 */\nvar intersect = function (a10, a11, a20, a21, b10, b11, b20, b21) {\n    var ua_t = (b20 - b10) * (a11 - b11) - (b21 - b11) * (a10 - b10);\n    var ub_t = (a20 - a10) * (a11 - b11) - (a21 - a11) * (a10 - b10);\n    var u_b = (b21 - b11) * (a20 - a10) - (b20 - b10) * (a21 - a11);\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\nfunction Cell(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.items = [];\n}\n\nCell.prototype.insert = function(item) {\n    if (\n        (item.fromX >= this.x && item.fromY >= this.y && item.toX <= this.x + this.width && item.toY <= this.y + this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x+this.width, this.y) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y, this.x, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x+this.width, this.y, this.x+this.width, this.y+this.height) ||\n        intersect(item.fromX, item.fromY, item.toX, item.toY, this.x, this.y+this.height, this.x+this.width, this.y+this.height)\n    ) {\n        this.items.push(item);\n    }\n};\n\nexports = module.exports = Cell;\n","'use strict';\n\nvar Cell = require('./cell');\nvar DoublyLinkedList = require('../../linkedlist/doublylinkedlist');\n\nfunction Grid(bounds, rows, cols) {\n    this.bounds = bounds;\n    this.rows = rows;\n    this.cols = cols;\n    this.cellX = this.bounds.width / this.cols;\n    this.cellY = this.bounds.height / this.rows;\n    this.cells = [];\n    this.out = new DoublyLinkedList();\n    for( var col = 0;col<this.cols;col++) {\n        this.cells[col] = [];\n        for ( var row=0;row<this.rows;row++) {\n            this.cells[col][row] = new Cell(col*this.cellX, row*this.cellY, this.cellX, this.cellY);\n        }\n    }\n}\n\nGrid.prototype.insert = function(item) {\n    if (item instanceof Array) {\n        var i = 0,\n            n = item.length;\n            while (i<n) {\n                this.insert(item);\n                i++;\n            }\n    } else {\n        for( var col = 0;col<this.cols;col++) {\n            for ( var row=0;row<this.rows;row++) {\n                this.cells[col][row].insert(item);\n            }\n        }\n    }\n};\n\nGrid.prototype.addOut = function(items) {\n    var i = 0,\n        n = items.length;\n    while (i<n) {\n        this.out.add(items[i]);\n        i++;\n    }\n};\n\nGrid.prototype.retrieve = function(item) {\n    // figure out cells\n    var nx = ((item.x%this.cellX) + item.width) > this.cellX ? true : false,\n        ny = ((item.y%this.cellY) + item.height) > this.cellY ? true : false,\n        x = Math.floor(item.x / this.cellX),\n        y = Math.floor(item.y / this.cellY);\n    this.out.clear();\n\n    this.addOut(this.cells[x][y].items);\n    if (nx) {\n        this.addOut(this.cells[x+1][y].items);\n    }\n    if (ny) {\n        this.addOut(this.cells[x][y+1].items);\n    }\n    if (nx && ny) {\n        this.addOut(this.cells[x+1][y+1].items);\n    }\n    return this.out;\n};\n\nexports = module.exports = Grid;\n","module.exports = {\n  Grid: require('./grid'),\n  Cell: require('./cell')\n};\n","module.exports = {\n  Vector2: require('./vector2'),\n  LineSegment2: require('./linesegment2'),\n  Triangle2: require('./triangle2'),\n  Polygon2: require('./polygon2'),\n  RegularPolygon2: require('./regularpolygon2'),\n  gpc: require('./gpc'),\n  VisibilityPolygon: require('./visibilitypolygon'),\n\n  Grid: require('./grid'),\n  QuadTree: require('./quadtree')\n};\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\n\nexports = module.exports = LineSegment2;\n\nvar cache = [];\nvar created = 0;\n\nfunction LineSegment2 (start, end) {\n\tif (!(this instanceof LineSegment2)) {\n\t\tvar l = cache.pop();\n\t\tif (!l) {\n\t\t\tl = new LineSegment2(start, end);\n\t\t\tcreated++;\n\t\t} else {\n\t\t\tl.start.free();\n\t\t\tl.end.free();\n\t\t\tl.set(start, end);\n\t\t}\n\t\treturn l;\n\t}\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n}\n\nLineSegment2.getStats = function() {\n\treturn [cache.length, created];\n};\n\nLineSegment2.prototype.set = function (start, end) {\n\tthis.start = start || Vector2();\n\tthis.end = end || Vector2();\n\treturn this;\n};\n\nLineSegment2.prototype.free = function () {\n\tcache.push(this);\n};\n\nLineSegment2.prototype.lengthSq = function () {\n\treturn this.start.distanceSq(this.end);\n};\n\nLineSegment2.prototype.length = function() {\n\treturn this.start.distance(this.end);\n};\n\nLineSegment2.prototype.closestPoint = function (point, full) {\n\tvar l2 = this.lengthSq();\n\tif (l2 === 0) {\n\t\treturn this.start.clone();\n\t}\n\tvar t = ((point.x - this.start.x) * (this.end.x - this.start.x) + (point.y - this.start.y)*(this.end.y - this.start.y)) / l2;\n\tif (!full) {\n\t\tif (t < 0) {\n\t\t\treturn this.start.clone();\n\t\t}\n\t\tif (t > 1) {\n\t\t\treturn this.end.clone();\n\t\t}\n\t}\n\treturn Vector2(this.start.x + t * (this.end.x-this.start.x), this.start.y + t * (this.end.y - this.start.y));\n};\n\nLineSegment2.prototype.distanceSq = function (point, full) {\n\tvar c = this.closestPoint(point, full);\n\tvar d = point.distanceSq(c);\n\tc.free();\n\treturn d;\n};\n\nLineSegment2.prototype.distance = function (point, full) {\n\treturn Math.sqrt(this.distanceSq(point, full));\n};\n\nLineSegment2.prototype.intersect = function (l, full) {\n\tvar u_b = (l.end.y - l.start.y) * (this.end.x - this.start.x) - (l.end.x - l.start.x) * (this.end.y - this.start.y);\n\tif (u_b !== 0) {\n\t\tvar ua_t = (l.end.x - l.start.x) * (this.start.y - l.start.y) - (l.end.y - l.start.y) * (this.start.x - l.start.x);\n\t\tvar ub_t = (this.end.x - this.start.x) * (this.start.y - l.start.y) - (this.end.y - this.start.y) * (this.start.x - l.start.x);\n\t\tvar ua = ua_t / u_b;\n\t\tvar ub = ub_t / u_b;\n\t\tif (full || (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)) {\n\t\t\treturn Vector2(this.start.x - ua * (this.start.x - this.end.x), this.start.y - ua * (this.start.y - this.end.y));\n\t\t}\n\t} else {\n\t\treturn null; // perpendicular\n\t}\n\treturn false;\n};\n\nLineSegment2.prototype.intersectCircle = function (point, radius, full) {\n\tvar r2 = radius*radius;\n\tvar closest = this.closestPoint(point, full);\n\tvar dist_v = point.clone().subtract(closest);\n\tvar len2 = dist_v.distanceSq();\n\tdist_v.free();\n\tif (len2 < r2) {\n\t\treturn closest;\n\t} else {\n\t\tclosest.free();\n\t\treturn false;\n\t}\n};\n\nLineSegment2.prototype.equals = function(other) {\n\treturn (this.start === other.start && this.end === other.end);\n};\n\nLineSegment2.prototype.inverse = function() {\n\treturn LineSegment2(this.end.clone(), this.start.clone());\n};\n\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2');\nvar LineSegment2 = require('./linesegment2');\nvar epsilon = 0.0000001;\n\nexports = module.exports = Polygon2;\n\nvar cache = [];\nvar created = 0;\n\nfunction Polygon2 (points) {\n    if (!(this instanceof Polygon2)) {\n        var p = cache.pop();\n        if (!p) {\n            p = new Polygon2(points);\n            created++;\n        } else {\n            p.freePoints();\n            p.set(points);\n        }\n        return p;\n    }\n    this.points = points || [];\n}\n\nPolygon2.fromArray = function (points)\n{\n    var p = Polygon2();\n    for (var i = 0;i<points.length; i++) {\n        p.add(Vector2.fromArray(points[i]));\n    }\n    return p;\n};\n\nPolygon2.getStats = function() {\n    return [cache.length, created];\n};\n\nPolygon2.prototype.free = function ()\n{\n    this.freePoints();\n    cache.push(this);\n};\n\nPolygon2.prototype.freePoints = function ()\n{\n    var p = this.points.pop();\n    while (p) {\n        p.free();\n        p = this.points.pop();\n    }\n    return this;\n};\n\nPolygon2.prototype.set = function (points)\n{\n    this.points = points || [];\n    return this;\n};\n\nPolygon2.prototype.add = function (point)\n{\n    this.points.push(point);\n    return this;\n};\n\nPolygon2.prototype.translate = function (vec)\n{\n    for ( var i = 0; i<this.points.length;i++) {\n        this.points[i].add(vec);\n    }\n    return this;\n};\n\nPolygon2.prototype.rotate = function (angle, origin)\n{\n    for (var i = 0; i<this.points.length;i++) {\n        this.points[i].rotate(angle, origin);\n    }\n    return this;\n};\n\nPolygon2.prototype.containsPoint = function (point)\n{\n    var inside = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n\n        var intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n\nPolygon2.prototype.intersectsLine = function (line, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    var intersect = false;\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y;\n        var xj = this.points[j].x, yj = this.points[j].y;\n        tempLine.start.set(xi, yi);\n        tempLine.end.set(xj, yj);\n        var is = tempLine.intersect(line);\n        if (is) {\n            if (ignorePoints && (this.points[i].isEqualEpsilon(is) || this.points[j].isEqualEpsilon(is) || line.start.isEqualEpsilon(is) || line.end.isEqualEpsilon(is) )) {\n                // special perpendicular test\n                var a = this.points[i].clone().subtract(this.points[j]).normalize();\n                var aa = a.angle();\n                a.copy(line.start).subtract(line.end).normalize();\n                var bb = a.angle();\n                a.free();\n                is.free();\n                if (Math.abs(aa - bb) < epsilon) {\n                    intersect = true;\n                    break;\n                }\n                continue;\n            }\n            is.free();\n            intersect = true;\n            break;\n        }\n    }\n    tempLine.free();\n    return intersect;\n};\n\n\nPolygon2.prototype.intersectsTriangle = function (triangle, ignorePoints)\n{\n    var tempLine = LineSegment2();\n\n    tempLine.start.copy(triangle.v0);\n    tempLine.end.copy(triangle.v1);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v1);\n    tempLine.end.copy(triangle.v2);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n\n    tempLine.start.copy(triangle.v2);\n    tempLine.end.copy(triangle.v0);\n\n    if (this.intersectsLine(tempLine, ignorePoints)) {\n        tempLine.free();\n        return true;\n    }\n    return false;\n};\n\nPolygon2.prototype.AABB = function()\n{\n    var min = this.points[0].clone();\n    var max = this.points[0].clone();\n\n    for (var i = 1; i< this.points.length; i++) {\n        var p = this.points[i];\n        if ( p.x < min.x ) {\n            min.x = p.x;\n        } else if ( p.x > max.x ) {\n            max.x = p.x;\n        }\n        if ( p.y < min.y ) {\n            min.y = p.y;\n        } else if ( p.y > max.y ) {\n            max.y = p.y;\n        }\n    }\n    return [min, max];\n};\n\n// negative = CCW\nPolygon2.prototype.winding = function() {\n    return this.area() > 0;\n};\n\nPolygon2.prototype.rewind = function(cw) {\n    cw = !!cw;\n    var winding = this.winding();\n    if (winding !== cw) {\n        this.points.reverse();\n    }\n    return this;\n};\n\nPolygon2.prototype.area = function() {\n    var area = 0;\n    var first = this.points[0];\n    var p1 = Vector2();\n    var p2 = Vector2();\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        p1.copy(first).subtract(this.points[i]);\n        p2.copy(first).subtract(this.points[j]);\n        area += p1.cross(p2);\n    }\n    p1.free();\n    p2.free();\n    return area/2;\n};\n\nPolygon2.prototype.clean = function(distance)\n{\n    var p1 = Vector2();\n    var newpoints = [];\n    for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var length = p1.copy(this.points[i]).subtract(this.points[j]).length();\n        if (length > distance) {\n            newpoints.push(this.points[i]);\n        } else {\n            this.points[i].free();\n        }\n    }\n    this.points = newpoints;\n};\n\nPolygon2.prototype.toArray = function ()\n{\n    var ret = [];\n    for (var i = 0; i< this.points.length; i++) {\n        ret.push(this.points[i].toArray());\n    }\n    return ret;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\nvar PointNode = require('./pointnode');\n\nfunction BoundsNode(bounds, depth, maxChildren, maxDepth) {\n    PointNode.call(this, bounds, depth, maxChildren, maxDepth);\n    this._stuckChildren = [];\n}\n\nBoundsNode.prototype = new PointNode();\nBoundsNode.prototype._classConstructor = BoundsNode;\nBoundsNode.prototype._stuckChildren = null;\n\n//we use this to collect and conctenate items being retrieved. This way\n//we dont have to continuously create new Array instances.\n//Note, when returned from QuadTree.retrieve, we then copy the array\nBoundsNode.prototype._out = [];\n\nBoundsNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        //todo: make _bounds bounds\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            this.nodes[index].insert(item);\n\n        } else {\n            this._stuckChildren.push(item);\n        }\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nBoundsNode.prototype.getChildren = function () {\n    return this.children.concat(this._stuckChildren);\n};\n\nBoundsNode.prototype.retrieve = function (item) {\n    var out = this._out;\n    out.length = 0;\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n        var node = this.nodes[index];\n\n        if (item.x >= node._bounds.x &&\n                item.x + item.width <= node._bounds.x + node._bounds.width &&\n                item.y >= node._bounds.y &&\n                item.y + item.height <= node._bounds.y + node._bounds.height) {\n\n            out.push.apply(out, this.nodes[index].retrieve(item));\n        } else {\n            //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n            if (item.x <= this.nodes[PointNode.TOP_RIGHT]._bounds.x) {\n                if (item.y <= this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_LEFT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_LEFT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_LEFT].retrieve(item));\n                }\n            }\n\n            if (item.x + item.width > this.nodes[PointNode.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                if (item.y <= this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.TOP_RIGHT].retrieve(item));\n                }\n\n                if (item.y + item.height > this.nodes[PointNode.BOTTOM_RIGHT]._bounds.y) {\n                    out.push.apply(out, this.nodes[PointNode.BOTTOM_RIGHT].retrieve(item));\n                }\n            }\n        }\n    }\n\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n\n    return out;\n};\n\n//Returns all contents of node.\nBoundsNode.prototype.getAllContent = function () {\n    var out = this._out;\n    if (this.nodes.length) {\n\n        var i;\n        for (i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].getAllContent();\n        }\n    }\n    out.push.apply(out, this._stuckChildren);\n    out.push.apply(out, this.children);\n    return out;\n};\n\nBoundsNode.prototype.clear = function () {\n\n    this._stuckChildren.length = 0;\n\n    //array\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    if (!len) {\n        return;\n    }\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    //array\n    this.nodes.length = 0;\n\n    //we could call the super clear function but for now, im just going to inline it\n    //call the hidden super.clear, and make sure its called with this = this instance\n    //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n};\n\nexports = module.exports = BoundsNode;\n","module.exports = {\n  QuadTree: require('./quadtree'),\n  PointNode: require('./pointnode'),\n  BoundsNode: require('./boundsnode')  \n};\n","'use strict';\n\nfunction PointNode(bounds, depth, maxDepth, maxChildren) {\n    this._bounds = bounds;\n    this.children = [];\n    this.nodes = [];\n\n    if (maxChildren) {\n        this._maxChildren = maxChildren;\n    }\n\n    if (maxDepth) {\n        this._maxDepth = maxDepth;\n    }\n\n    if (depth) {\n        this._depth = depth;\n    }\n}\n\n//subnodes\nPointNode.prototype.nodes = null;\nPointNode.prototype._classConstructor = PointNode;\n\n//children contained directly in the node\nPointNode.prototype.children = null;\nPointNode.prototype._bounds = null;\n\n//read only\nPointNode.prototype._depth = 0;\n\nPointNode.prototype._maxChildren = 4;\nPointNode.prototype._maxDepth = 4;\n\nPointNode.TOP_LEFT = 0;\nPointNode.TOP_RIGHT = 1;\nPointNode.BOTTOM_LEFT = 2;\nPointNode.BOTTOM_RIGHT = 3;\n\n\nPointNode.prototype.insert = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        this.nodes[index].insert(item);\n\n        return;\n    }\n\n    this.children.push(item);\n\n    var len = this.children.length;\n    if (this._depth < this._maxDepth &&\n            len > this._maxChildren) {\n\n        this.subdivide();\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.insert(this.children[i]);\n        }\n\n        this.children.length = 0;\n    }\n};\n\nPointNode.prototype.retrieve = function (item) {\n    if (this.nodes.length) {\n        var index = this._findIndex(item);\n\n        return this.nodes[index].retrieve(item);\n    }\n\n    return this.children;\n};\n\nPointNode.prototype._findIndex = function (item) {\n    var b = this._bounds;\n    var left = (item.x > b.x + b.width / 2) ? false : true;\n    var top = (item.y > b.y + b.height / 2) ? false : true;\n\n    //top left\n    var index = PointNode.TOP_LEFT;\n    if (left) {\n        //left side\n        if (!top) {\n            //bottom left\n            index = PointNode.BOTTOM_LEFT;\n        }\n    } else {\n        //right side\n        if (top) {\n            //top right\n            index = PointNode.TOP_RIGHT;\n        } else {\n            //bottom right\n            index = PointNode.BOTTOM_RIGHT;\n        }\n    }\n\n    return index;\n};\n\n\nPointNode.prototype.subdivide = function () {\n    var depth = this._depth + 1;\n\n    var bx = this._bounds.x;\n    var by = this._bounds.y;\n\n    //floor the values\n    var b_w_h = (this._bounds.width / 2) | 0; //todo: Math.floor?\n    var b_h_h = (this._bounds.height / 2) | 0;\n    var bx_b_w_h = bx + b_w_h;\n    var by_b_h_h = by + b_h_h;\n\n    //top left\n    this.nodes[PointNode.TOP_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //top right\n    this.nodes[PointNode.TOP_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n    //bottom left\n    this.nodes[PointNode.BOTTOM_LEFT] = new this._classConstructor({\n        x: bx,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n\n\n    //bottom right\n    this.nodes[PointNode.BOTTOM_RIGHT] = new this._classConstructor({\n        x: bx_b_w_h,\n        y: by_b_h_h,\n        width: b_w_h,\n        height: b_h_h\n    },\n        depth, this._maxDepth, this._maxChildren);\n};\n\nPointNode.prototype.clear = function () {\n    this.children.length = 0;\n\n    var len = this.nodes.length;\n\n    var i;\n    for (i = 0; i < len; i++) {\n        this.nodes[i].clear();\n    }\n\n    this.nodes.length = 0;\n};\n\n\nexports = module.exports = PointNode;\n","'use strict';\n\nvar PointNode = require('./pointnode'),\n    BoundsNode = require('./boundsnode');\n\n/**\n* QuadTree data structure.\n* @class QuadTree\n* @constructor\n* @param {Object} An object representing the bounds of the top level of the QuadTree. The object\n* should contain the following properties : x, y, width, height\n* @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds\n* (width / height)(false). Default value is false.\n* @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n* @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n**/\nfunction QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n    var node;\n    if (pointQuad) {\n        node = new PointNode(bounds, 0, maxDepth, maxChildren);\n    } else {\n        node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n    }\n\n    this.root = node;\n}\n\n/**\n* The root node of the QuadTree which covers the entire area being segmented.\n* @property root\n* @type Node\n**/\nQuadTree.prototype.root = null;\n\n\n/**\n* Inserts an item into the QuadTree.\n* @method insert\n* @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y\n* properties that represents its position in 2D space.\n**/\nQuadTree.prototype.insert = function (item) {\n    if (item instanceof Array) {\n        var i = 0,\n            len = item.length;\n        while (i<len) {\n            this.root.insert(item[i]);\n            i++;\n        }\n    } else {\n        this.root.insert(item);\n    }\n};\n\n/**\n* Clears all nodes and children from the QuadTree\n* @method clear\n**/\nQuadTree.prototype.clear = function () {\n    this.root.clear();\n};\n\n/**\n* Retrieves all items / points in the same node as the specified item / point. If the specified item\n* overlaps the bounds of a node, then all children in both nodes will be returned.\n* @method retrieve\n* @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n* with dimensions (x, y, width, height) properties.\n**/\nQuadTree.prototype.retrieve = function (item) {\n    //get a copy of the array of items\n    return this.root.retrieve(item);\n    // var out = this.root.retrieve(item).slice(0);\n    // return out;\n};\n\nexports = module.exports = QuadTree;\n","'use strict';\n\n/* jshint -W064 */\n\nvar Vector2 = require('./vector2'),\n    Polygon2 = require('./polygon2');\n\nexports = module.exports = RegularPolygon2;\n\nfunction RegularPolygon2 (radius,sides, center)\n{\n    center = center || Vector2();\n\n    if (!sides || sides < 2) {\n        sides = 3;\n    }\n    if (!radius || radius <= 0) {\n        radius = 1;\n    }\n\n    var p = Polygon2();\n    for ( var i = 0; i < sides; i++) {\n        p.add(Vector2( center.x + radius * Math.cos( (i * 2 * Math.PI / sides) + 0.25*Math.PI), center.y + radius * Math.sin((i * 2 * Math.PI / sides) + 0.25*Math.PI)));\n    }\n    return p;\n}\n/* jshint +W064 */\n","'use strict';\n\n/* jshint -W064 */\n\nexports = module.exports = Triangle2;\n\nvar epsilon = 0.0000001;\nvar cache = [];\nvar created = 0;\n\nfunction Triangle2 (v0, v1, v2) {\n    if (!(this instanceof Triangle2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Triangle2(v0, v1, v2);\n            created++;\n        } else {\n            v.set(v0, v1, v2);\n            //v.calcCircumcircle();\n        }\n        return v;\n    }\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    /*\n    this.center = Vector2();\n    this.radius = 0;\n    this.radius_squared = 0;\n\n    this.calcCircumcircle();\n    */\n}\n\nTriangle2.getStats = function() {\n    return [cache.length, created];\n};\n\nTriangle2.prototype.free = function ()\n{\n    cache.push(this);\n};\n\n\nTriangle2.prototype.set = function (v0, v1, v2)\n{\n    this.v0.free();\n    this.v1.free();\n    this.v2.free();\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    return this;\n};\n\nTriangle2.prototype.translate = function (vec)\n{\n    this.v0.add(vec);\n    this.v1.add(vec);\n    this.v2.add(vec);\n    return this;\n};\n\nTriangle2.prototype.calcCircumcircle = function() {\n    // From: http://www.exaflop.org/docs/cgafaq/cga1.html\n\n    var A = this.v1.x - this.v0.x;\n    var B = this.v1.y - this.v0.y;\n    var C = this.v2.x - this.v0.x;\n    var D = this.v2.y - this.v0.y;\n\n    var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);\n    var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);\n\n    var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));\n\n    var dx, dy;\n\n    if (Math.abs(G) < epsilon) {\n        // Collinear - find extremes and use the midpoint\n\n        var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);\n        var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);\n        var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);\n        var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);\n\n        this.center.set((minx + maxx) / 2, (miny + maxy) / 2);\n\n        dx = this.center.x - minx;\n        dy = this.center.y - miny;\n    } else {\n        var cx = (D * E - B * F) / G;\n        var cy = (A * F - C * E) / G;\n\n        this.center.set(cx, cy);\n\n        dx = this.center.x - this.v0.x;\n        dy = this.center.y - this.v0.y;\n    }\n\n    this.radius_squared = dx * dx + dy * dy;\n    this.radius = Math.sqrt(this.radius_squared);\n};\n\nTriangle2.prototype.inCircumcircle = function(v) {\n    var dx = this.center.x - v.x;\n    var dy = this.center.y - v.y;\n    var dist_squared = dx * dx + dy * dy;\n\n    return (dist_squared <= this.radius_squared);\n};\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\nexports = module.exports = Vector2;\n\nvar epsilon = 0.0000001;\nvar degrees = 180 / Math.PI;\n\nvar cache = [];\nvar created = 0;\n\nfunction Vector2 (x, y) {\n    if (!(this instanceof Vector2)) {\n        var v = cache.pop();\n        if (!v) {\n            v = new Vector2(x || 0, y || 0);\n            created++;\n        } else {\n            v.set(x, y);\n        }\n        return v;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n}\n\nVector2.getStats = function() {\n    return [cache.length, created];\n};\n\nVector2.fromArray = function (arr) {\n    return Vector2(arr[0] || 0, arr[1] || 0);\n};\n\nVector2.fromObject = function (obj) {\n    return Vector2(obj.x || 0, obj.y || 0);\n};\n\nVector2.prototype.set = function (x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n};\n\nVector2.prototype.free = function () {\n    cache.push(this);\n};\n\nVector2.prototype.add = function (vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n    return this;\n};\n\nVector2.prototype.addScalar = function (scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    return this;\n};\n\n\nVector2.prototype.subtract = function (vec) {\n    this.x -= vec.x;\n    this.y -= vec.y;\n    return this;\n};\n\nVector2.prototype.subtractScalar = function (scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n};\n\n\nVector2.prototype.divide = function (vec) {\n    this.x /= vec.x;\n    this.y /= vec.y;\n    return this;\n};\n\nVector2.prototype.multiply = function (vec) {\n    this.x *= vec.x;\n    this.y *= vec.y;\n    return this;\n};\n\nVector2.prototype.multiplyScalar = function (scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n};\n\nVector2.prototype.normalize = function () {\n    var length = this.length();\n\n    if (length === 0) {\n        this.x = 0;\n        this.y = 0;\n    } else {\n        this.x /= length;\n        this.y /= length;\n    }\n    return this;\n};\n\nVector2.prototype.clone = function () {\n    return Vector2(this.x, this.y);\n};\n\nVector2.prototype.copy = function (vec) {\n    this.x = vec.x;\n    this.y = vec.y;\n    return this;\n};\n\nVector2.prototype.zero = function () {\n    this.x = this.y = 0;\n    return this;\n};\n\nVector2.prototype.dot = function (vec) {\n    return this.x * vec.x + this.y * vec.y;\n};\n\nVector2.prototype.cross = function (vec) {\n    return (this.x * vec.y ) - (this.y * vec.x );\n};\n\nVector2.prototype.projectOnto = function (vec) {\n    var coeff = ( (this.x * vec.x)+(this.y * vec.y) ) / ((vec.x*vec.x)+(vec.y*vec.y));\n    this.x = coeff * vec.x;\n    this.y = coeff * vec.y;\n    return this;\n};\n\n\nVector2.prototype.horizontalAngle = function () {\n    return Math.atan2(this.y, this.x);\n};\n\nVector2.prototype.horizontalAngleDeg = function () {\n    return radian2degrees(this.horizontalAngle());\n};\n\nVector2.prototype.verticalAngle = function () {\n    return Math.atan2(this.x, this.y);\n};\n\nVector2.prototype.verticalAngleDeg = function () {\n    return radian2degrees(this.verticalAngle());\n};\n\nVector2.prototype.angle = Vector2.prototype.horizontalAngle;\nVector2.prototype.angleDeg = Vector2.prototype.horizontalAngleDeg;\nVector2.prototype.direction = Vector2.prototype.horizontalAngle;\n\nVector2.prototype.rotate = function (angle, origin) {\n    var ox = 0,\n        oy = 0;\n    if (origin) {\n        ox = origin.x || 0;\n        oy = origin.y || 0;\n    }\n\n    var nx = ox + (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));\n    var ny = oy + (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));\n\n    this.x = nx;\n    this.y = ny;\n\n    return this;\n};\n\nVector2.prototype.rotateDeg = function (angle) {\n    angle = degrees2radian(angle);\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateBy = function (rotation) {\n    var angle = this.angle() + rotation;\n    return this.rotate(angle);\n};\n\nVector2.prototype.rotateByDeg = function (rotation) {\n    rotation = degrees2radian(rotation);\n    return this.rotateBy(rotation);\n};\n\nVector2.prototype.distance = function (vec) {\n    return Math.sqrt(this.distanceSq(vec));\n};\n\nVector2.prototype.distanceSq = function (vec) {\n    var dx = this.x - vec.x,\n    dy = this.y - vec.y;\n    return dx * dx + dy * dy;\n};\n\nVector2.prototype.length = function () {\n    return Math.sqrt(this.lengthSq());\n};\n\nVector2.prototype.lengthSq = function () {\n    return this.x * this.x + this.y * this.y;\n};\n\nVector2.prototype.magnitude = Vector2.prototype.length;\n\nVector2.prototype.isZero = function() {\n    return this.x === 0 && this.y === 0;\n};\nVector2.prototype.isEqualTo = function(vec) {\n    return this.x === vec.x && this.y === vec.y;\n};\n\nVector2.prototype.isEqualEpsilon = function(vec) {\n    return Math.abs(this.x - vec.x) < epsilon && Math.abs(this.y - vec.y) < epsilon;\n};\n\nVector2.prototype.toString = function () {\n    return 'x:' + this.x + ', y:' + this.y;\n};\n\nVector2.prototype.toArray = function () {\n    return [ this.x, this.y ];\n};\n\nVector2.prototype.toObject = function () {\n    return { x: this.x, y: this.y };\n};\n\nfunction radian2degrees (rad) {\n    return rad * degrees;\n}\n\nfunction degrees2radian (deg) {\n    return deg / degrees;\n}\n/* jshint +W064 */\n","'use strict';\n/* jshint -W064 */\n\n/*\n    Based upon https://code.google.com/p/visibility-polygon-js/\n    Made by Byron Knoll in 2013/2014.\n*/\n\nvar Polygon2 = require('./polygon2'),\n    Vector2 = require('./vector2'),\n    LineSegment2 = require('./linesegment2');\n\nvar PI = Math.PI;\nvar PI2 = PI*2;\nvar PImin = -1*PI;\nvar epsilon = 0.0000001;\n\nvar segmentIter = ['start', 'end'];\nfunction pointsorter(a,b) {\n    return a[2] - b[2];\n}\n\nfunction VisibilityPolygon(segments)\n{\n    this.polygon = Polygon2();\n    this.segments = segments;\n    this.heap = [];\n    this.map = new Array(this.segments.length);\n    this.points = new Array(this.segments.length * 2);\n    this.position = Vector2();\n}\n\nVisibilityPolygon.prototype.angle = function (p1, p2)\n{\n    var p = p2.clone().subtract(p1);\n    var a = p.angle();\n    p.free();\n    return a;\n};\n\nVisibilityPolygon.prototype.angle2 = function (a, b, c) {\n    var a1 = this.angle(a, b);\n    var a2 = this.angle(b, c);\n    var a3 = a1 - a2;\n    if (a3 < 0) { a3 += PI2; }\n    if (a3 > PI2) { a3 -= PI2; }\n    return a3;\n};\n\n\nVisibilityPolygon.prototype.compute = function (position)\n{\n    this.position.copy(position);\n    this.reset();\n    this.sortPoints();\n\n    var start = this.position.clone();\n    start.x +=1; // why?\n\n    var i = 0,\n        n = this.segments.length;\n    while (i < n) {\n        var a1 = this.angle(this.segments[i].start, this.position);\n        var a2 = this.angle(this.segments[i].end, this.position);\n        if (\n            ( a1 > PImin && a1 <= 0 && a2 <= PI && a2 >= 0 && a2 - a1 > PI) ||\n            (a2 > PImin && a2 <= 0 && a1 <= PI && a1 >= 0 && a1 - a2 > PI)\n        ) {\n            this.insert(i, start);\n        }\n        i += 1;\n    }\n    i = 0;\n    n = this.segments.length*2;\n    while (i < n) {\n        var extend = false;\n        var shorten = false;\n        var orig = i;\n        var vertex = this.segments[this.points[i][0]][this.points[i][1]];\n        var old_segment = this.heap[0];\n        do {\n            if (this.map[this.points[i][0]] !== -1) {\n                if (this.points[i][0] === old_segment) {\n                    extend = true;\n                    vertex = this.segments[this.points[i][0]][this.points[i][1]];\n                }\n                this.remove(this.map[this.points[i][0]], vertex);\n            } else {\n                this.insert(this.points[i][0], vertex);\n                if (this.heap[0] !== old_segment) {\n                    shorten = true;\n                }\n            }\n            ++i;\n            if (i === n) { break; }\n        } while (this.points[i][2] < this.points[orig][2] + epsilon);\n\n        var l = LineSegment2(position.clone(), vertex.clone());\n        if (extend) {\n            this.polygon.add(vertex.clone());\n            var cur = this.segments[this.heap[0]].intersect(l, true);\n            if (cur ) {\n                if (!cur.isEqualEpsilon(vertex)) {\n                    this.polygon.add(cur);\n                } else {\n                    cur.free();\n                }\n            }\n        } else if (shorten) {\n            this.polygon.add(this.segments[old_segment].intersect(l, true));\n            this.polygon.add(this.segments[this.heap[0]].intersect(l, true));\n        }\n    }\n    return this.polygon;\n};\n\n\nVisibilityPolygon.prototype.insert = function (index, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var intersect = this.segments[index].intersect(l, true);\n    if (intersect === false) {\n        l.free();\n        return;\n    }\n    intersect.free();\n\n    var cur = this.heap.length;\n    this.heap.push(index);\n    this.map[index] = cur;\n    while (cur > 0) {\n        var parent = this.parent(cur);\n        if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n            break;\n        }\n        this.map[this.heap[parent]] = cur;\n        this.map[this.heap[cur]] = parent;\n        var temp = this.heap[cur];\n        this.heap[cur] = this.heap[parent];\n        this.heap[parent] = temp;\n        cur = parent;\n    }\n};\n\nVisibilityPolygon.prototype.remove = function (index, destination) {\n    this.map[this.heap[index]] = -1;\n    if (index === this.heap.length - 1) {\n        this.heap.pop();\n        return;\n    }\n    this.heap[index] = this.heap.pop();\n    this.map[this.heap[index]] = index;\n    var cur = index;\n    var parent = this.parent(cur);\n    if (cur !== 0 && this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n        while (cur > 0) {\n            parent = this.parent(cur);\n            if (!this.lessThan(this.heap[cur], this.heap[parent], destination)) {\n                break;\n            }\n            this.swap(cur, parent);\n            cur = parent;\n        }\n    } else {\n        while (true) {\n            var left = this.child(cur);\n            var right = left + 1;\n            if (left < this.heap.length && this.lessThan(this.heap[left], this.heap[cur], destination) &&\n                (right === this.heap.length || this.lessThan(this.heap[left], this.heap[right], destination))) {\n                    this.swap(cur, left);\n                    cur = left;\n                } else if (right < this.heap.length && this.lessThan(this.heap[right], this.heap[cur], destination)) {\n                    this.swap(cur, right);\n                    cur = right;\n                } else {\n                    break;\n                }\n            }\n        }\n    };\n\n\n\nVisibilityPolygon.prototype.lessThan = function (index1, index2, destination) {\n    var l = LineSegment2(this.position.clone(), destination.clone());\n    var inter1 = this.segments[index1].intersect(l, true);\n    var inter2 = this.segments[index2].intersect(l, true);\n    if (!inter1.isEqualEpsilon(inter2)) {\n        var d1 = inter1.distanceSq(this.position);\n        var d2 = inter2.distanceSq(this.position);\n        inter1.free();\n        inter2.free();\n        l.free();\n        return d1 < d2;\n    }\n    var end1 = this.segments[index1].start;\n    if (inter1.isEqualEpsilon(this.segments[index1].start)) {\n        end1 = this.segments[index1].end;\n    }\n    var end2 = this.segments[index2].start;\n    if (inter2.isEqualEpsiolon(this.segments[index2].start)) {\n        end2 = this.segments[index2].end;\n    }\n    var a1 = this.angle2(end1, inter1, this.position);\n    var a2 = this.angle2(end2, inter2, this.position);\n    inter1.free();\n    inter2.free();\n    if (a1 < PI) {\n        if (a2 > PI) {\n            return true;\n        }\n        return a2 < a1;\n    }\n    return a1 < a2;\n};\n\nVisibilityPolygon.prototype.parent = function (index) {\n    return Math.floor((index - 1) / 2);\n};\n\nVisibilityPolygon.prototype.child = function (index) {\n    return 2 * index + 1;\n};\n\nVisibilityPolygon.prototype.swap = function (c, l) {\n    this.map[this.heap[l]] = c;\n    this.map[this.heap[c]] = l;\n    var temp = this.heap[l];\n    this.heap[l] = this.heap[c];\n    this.heap[c] = temp;\n};\n\n\nVisibilityPolygon.prototype.sortPoints = function ()\n{\n    var i = 0,\n    n = this.segments.length,\n    p = null,\n    pp = Vector2();\n    while (i < n) {\n        for (var j = 0; j < 2; ++j) {\n            if (j === 0) {\n                p = this.segments[i][segmentIter[j]];\n            } else {\n                p = this.segments[i][segmentIter[j]];\n            }\n            pp.copy(this.position).subtract(p);\n            var nr = 2 * i + j;\n            if (this.points[nr]) {\n                this.points[nr][0] = i;\n                this.points[nr][1] = segmentIter[j];\n                this.points[nr][2] = pp.angle();\n            } else {\n                this.points[nr] = [i, segmentIter[j], pp.angle()];\n            }\n        }\n        i += 1;\n    }\n    pp.free();\n    this.points = this.points.sort(pointsorter);\n};\n\nVisibilityPolygon.prototype.reset = function ()\n{\n    this.polygon.freePoints();\n    var i = 0,\n    n = this.map.length;\n    while (i < n) {\n        this.map[i] = -1;\n        i += 1;\n    }\n    while (this.heap.length > 0) {\n        this.heap.pop();\n    }\n};\n/* jshint +W064 */\n","var core = {};\n\n\ncore.geometry = require('./geometry');\ncore.linkedlist = require('./linkedlist');\ncore.procedural = require('./procedural');\ncore.timer = require('./timer');\ncore.input = require('./input');\n\nmodule.exports = core;\n\nglobal.ULTRON = core;\n","module.exports = {\n  Unified: require('./unified')\n};\n","//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\n// taken from game-shell\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif ( window.addEventListener ) {\n  _addEventListener = \"addEventListener\";\n} else {\n  _addEventListener = \"attachEvent\";\n  prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\n  elem[ _addEventListener ]( prefix + eventName, support === \"wheel\" ? callback : function( originalEvent ) {\n    !originalEvent && ( originalEvent = window.event );\n\n    // create a normalized event object\n    var event = {\n      // keep a ref to the original event object\n      originalEvent: originalEvent,\n      target: originalEvent.target || originalEvent.srcElement,\n      type: \"wheel\",\n      deltaMode: originalEvent.type === \"MozMousePixelScroll\" ? 0 : 1,\n      deltaX: 0,\n      delatZ: 0,\n      preventDefault: function() {\n        originalEvent.preventDefault ?\n          originalEvent.preventDefault() :\n          originalEvent.returnValue = false;\n      }\n    };\n\n    // calculate deltaY (and deltaX) according to the event\n    if ( support === \"mousewheel\" ) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n      // Webkit also support wheelDeltaX\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n    } else {\n      event.deltaY = originalEvent.detail;\n    }\n\n    // it's time to fire the callback\n    return callback( event );\n  }, useCapture || false );\n}\n\nmodule.exports = function( elem, callback, useCapture ) {\n  _addWheelListener( elem, support, callback, useCapture );\n\n  // handle MozMousePixelScroll in older Firefox\n  if( support === \"DOMMouseScroll\" ) {\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\n  }\n};\n","'use strict';\n\n// taken from https://github.com/andyhall/game-inputs\n\nvar vkey = require('vkey');\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\nvar EventEmitter = require('eventemitter3');\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = require('./mousewheel-polyfill');\n\nmodule.exports = function(domElement, options) {\n  return new Inputs(domElement, options);\n};\n\n// map button index to name\nvar gamepadButtonNames = [\n    'a',\n    'b',\n    'x',\n    'y',\n    'left-shoulder',\n    'right-shoulder',\n    'left-trigger',\n    'right-trigger',\n    'select',\n    'start',\n    'left-stick',\n    'right-stick',\n    'dpad-up',\n    'dpad-down',\n    'dpad-left',\n    'dpad-right'\n];\nvar gamepadAxesNames = [\n    'left-stick-x',\n    'left-stick-y',\n    'right-stick-x',\n    'right-stick-y'\n];\nvar hasGamepadEvents = 'GamepadEvent' in window;\n\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from)\n *        game-shell: https://github.com/mikolalysenko/game-shell\n *\n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *\n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n*/\n\n\nfunction Inputs(element, opts) {\n\n  // settings\n  this.element = element || document;\n  opts = opts || {};\n  this.preventDefaults = !!opts.preventDefaults;\n  this.stopPropagation = !!opts.stopPropagation;\n\n  // emitters\n  this.down = new EventEmitter();\n  this.up = new EventEmitter();\n  this.gamepadconnected = new EventEmitter();\n  this.gamepaddisconnected = new EventEmitter();\n\n  // state object to be queried\n  this.state = {\n    dx: 0, dy: 0,\n    scrollx: 0, scrolly: 0, scrollz: 0\n  };\n\n  // internal state\n  this._keybindmap = {};       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n  this._keyStates = {};        // { 'vkeycode' : boolean }\n  this._bindPressCounts = {};  // { 'binding' : int }\n  this._gamepads = {}; // { 'index' : gamepad }\n  this._gamepadButtonStates = {}; // { 'vcode' : int }\n\n  // raf handle\n  this._gamepadRaf = false;\n\n  // register for dom events\n  this.initEvents();\n}\n\n\n/*\n *\n *   PUBLIC API\n *\n*/\n\nInputs.prototype.initEvents = function() {\n  // keys\n  window.addEventListener( 'keydown', onKeyEvent.bind(undefined,this,true), false );\n  window.addEventListener( 'keyup', onKeyEvent.bind(undefined,this,false), false );\n  // mouse buttons\n  this.element.addEventListener('mousedown', onMouseEvent.bind(undefined,this,true), false);\n  this.element.addEventListener('mouseup', onMouseEvent.bind(undefined,this,false), false);\n  this.element.oncontextmenu = onContextMenu.bind(undefined,this);\n  // mouse other\n  this.element.addEventListener('mousemove', onMouseMove.bind(undefined,this), false);\n  addMouseWheel(this.element, onMouseWheel.bind(undefined,this), false);\n\n  // gamepads\n  if ( hasGamepadEvents ) {\n      window.addEventListener('gamepadconnected', onGamepadConnected.bind(undefined,this), false);\n      window.addEventListener('gamepaddisconnected', onGamepadDisconnected.bind(undefined,this), false);\n  } else {\n      window.setInterval(scanGamepads.bind(undefined, this), 500);\n  }\n};\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function(binding) {\n  for (var i=1; i<arguments.length; ++i) {\n    var vkeyCode = arguments[i];\n    var arr = this._keybindmap[vkeyCode] || [];\n    if (arr.indexOf(binding) === -1) {\n      arr.push(binding);\n    }\n    this._keybindmap[vkeyCode] = arr;\n  }\n  this.state[binding] = !!this.state[binding];\n};\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function(binding) {\n  for (var b in this._keybindmap) {\n    var arr = this._keybindmap[b];\n    var i = arr.indexOf(binding);\n    if (i>-1) { arr.splice(i,1); }\n  }\n};\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function() {\n  this.state['mouse-dx'] = this.state['mouse-dy'] = 0;\n  this.state['mouse-scrollx'] = this.state['mouse-scrolly'] = this.state['mouse-scrollz'] = 0;\n};\n\n\n\nInputs.prototype.getBoundKeys = function() {\n  var arr = [];\n  for (var b in this._keybindmap) { arr.push(b); }\n  return arr;\n};\n\n\n/*\n *   INTERNALS - DOM EVENT HANDLERS\n*/\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n  handleKeyEvent( ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev );\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n  // simulate a code out of range of vkey\n  var keycode = -1 - ev.button;\n  var vkeycode = '<mouse '+ (ev.button+1) +'>';\n  handleKeyEvent( keycode, vkeycode, wasDown, inputs, ev );\n  return false;\n}\n\nfunction onContextMenu(inputs) {\n  // cancel context menu if there's a binding for right mousebutton\n  var arr = inputs._keybindmap['<mouse 3>'];\n  if (arr) { return false; }\n}\n\nfunction onMouseMove(inputs, ev) {\n  // for now, just populate the state object with mouse movement\n  var dx = ev.movementX || ev.mozMovementX || ev.webkitMovementX || 0,\n      dy = ev.movementY || ev.mozMovementY || ev.webkitMovementY || 0;\n  inputs.state['mouse-dx'] += dx;\n  inputs.state['mouse-dy'] += dy;\n  // TODO: verify if this is working/useful during pointerlock?\n}\n\nfunction onMouseWheel(inputs, ev) {\n  // basically borrowed from game-shell\n  var scale = 1;\n  switch(ev.deltaMode) {\n    case 0: scale=1;   break;  // Pixel\n    case 1: scale=12;  break;  // Line\n    case 2:  // page\n      // TODO: investigagte when this happens, what correct handling is\n      scale = inputs.element.clientHeight || window.innerHeight;\n      break;\n  }\n  // accumulate state\n  inputs.state['mouse-scrollx'] += ev.deltaX * scale;\n  inputs.state['mouse-scrolly'] += ev.deltaY * scale;\n  inputs.state['mouse-scrollz'] += (ev.deltaZ * scale) || 0;\n  return false;\n}\n\n\n/*\n *   KEY BIND HANDLING\n*/\n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n  var arr = inputs._keybindmap[vcode];\n  // don't prevent defaults if there's no binding\n  if (!arr) { return; }\n  if (inputs.preventDefaults) { ev.preventDefault(); }\n  if (inputs.stopPropagation) { ev.stopPropagation(); }\n\n  // if the key's state has changed, handle an event for all bindings\n  var currstate = inputs._keyStates[keycode];\n  if ( XOR(currstate, wasDown) ) {\n    // for each binding: emit an event, and update cached state information\n    for (var i=0; i<arr.length; ++i) {\n      handleBindingEvent( arr[i], wasDown, inputs, ev );\n    }\n  }\n  inputs._keyStates[keycode] = wasDown;\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n  // keep count of presses mapped by binding\n  // (to handle two keys with the same binding pressed at once)\n  var ct = inputs._bindPressCounts[binding] || 0;\n  ct += wasDown ? 1 : -1;\n  if (ct<0) { ct = 0; } // shouldn't happen\n  inputs._bindPressCounts[binding] = ct;\n\n  // emit event if binding's state has changed\n  var currstate = inputs.state[binding];\n  if ( XOR(currstate, ct) ) {\n    var emitter = wasDown ? inputs.down : inputs.up;\n    emitter.emit( binding, ev );\n  }\n  inputs.state[binding] = !!ct;\n}\n\n/**\nGamepad HANDLERS\n*/\n\nfunction handleGamePadButtonEvent(val, vcode, inputs) {\n    var arr = inputs._keybindmap[vcode];\n    if (!arr) { return; }\n\n    var pressed = val === 1.0;\n    var isPerc = false;\n    if (typeof(val) === 'object') {\n        pressed = val.pressed;\n        val = val.value;\n        isPerc = true;\n        inputs.state[vcode] = val;\n    } else {\n        var currstate = inputs._buttonStates[vcode];\n        if (XOR(currstate, val)) {\n            var i = 0;\n            for (i=0; i<arr.length; ++i) {\n                handleBindingEvent( arr[i], pressed, inputs, null); // pass null as fake event\n            }\n        }\n    }\n}\n\nfunction updateGamepads(inputs) {\n    var found = scanGamepads(inputs);\n    if (!found) {\n        if (inputs._gamepadRaf) {\n            cancel(inputs._gamepadRaf);\n            inputs._gamepadRaf = false;\n        }\n        return;\n    }\n\n    var vcode = '';\n    for (var j in inputs._gamepads) {\n        var gamepad = inputs._gamepads[j];\n\n        for (var i=0;i<gamepad.buttons.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadButtonNames[i] + '>';\n            handleGamePadButtonEvent(gamepad.buttons[i], vcode, inputs);\n        }\n\n        for (i=0;i<gamepad.axes.length;i++) {\n            vcode = '<gamepad-' + j + '-' + gamepadAxesNames[i] + '>';\n            inputs.state[vcode] = gamepad.axes[i];\n        }\n    }\n    inputs._gamepadRaf = request(updateGamepads);\n}\n\nfunction onGamepadConnected(inputs, ev) {\n    addGamepad(inputs, ev.gamepad);\n}\n\nfunction onGamepadDisconnected(inputs, ev) {\n    removeGamepad(inputs, ev.gamepad);\n}\n\n\nfunction addGamepad(inputs, gamepad) {\n    inputs._gamepads[gamepad.index] = gamepad;\n    inputs.gamepadconnected.emit(gamepad);\n    if (!inputs._gamepadRaf) {\n        inputs._gamepadRaf = request(updateGamepads);\n    }\n}\n\nfunction removeGamepad(inputs, gamepad) {\n    delete inputs._gamepads[gamepad.index];\n    inputs.gamepaddisconnected.emit(gamepad);\n    for (var j in inputs._gamepads) {\n        if (inputs._gamepads.hasOwnProperty(j)) {\n            return;\n        }\n    }\n    if (inputs._gamepadRaf) {\n        cancel(inputs._gamepadRaf);\n        inputs._gamepadRaf = false;\n    }\n}\n\n\nfunction scanGamepads(inputs) {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n    var found = false;\n    for (var i = 0; i < gamepads.length; i++) {\n        if (gamepads[i]) {\n            found = true;\n            if (!(gamepads[i].index in inputs._gamepads)) {\n                addGamepad(inputs, gamepads[i]);\n            } else {\n                inputs._gamepads[gamepads[i].index] = gamepads[i];\n            }\n        }\n    }\n    return found;\n}\n\n/*\n *    HELPERS\n *\n*/\n\n\n// how is this not part of Javascript?\nfunction XOR(a,b) {\n  return a ? !b : b;\n}\n","/*\n * Doubly Linked List implementation in JavaScript\n * Copyright (c) 2009 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n /*\n  * Optimizations and data reuse by Wouter Commandeur\n */\n\n'use strict';\n\n/**\n * A linked list implementation in JavaScript.\n * @class DoublyLinkedList\n * @constructor\n */\nfunction DoublyLinkedList() {\n\n    /**\n     * Pointer to first item in the list.\n     * @property _head\n     * @type Object\n     * @private\n     */\n    this._head = null;\n\n    /**\n     * Pointer to last item in the list.\n     * @property _tail\n     * @type Object\n     * @private\n     */\n    this._tail = null;\n\n    /**\n     * The number of items in the list.\n     * @property _length\n     * @type int\n     * @private\n     */\n    this._length = 0;\n\n    this._nodeCache = [];\n\n}\n\nDoublyLinkedList.prototype = {\n\n    //restore constructor\n    constructor: DoublyLinkedList,\n\n    /**\n     * Appends some data to the end of the list. This method traverses\n     * the existing list and places the value at the end in a new item.\n     * @param {variant} data The data to add to the list.\n     * @return {Void}\n     * @method add\n     */\n    add: function (data) {\n        //create a new item object, place data in\n        var node = this._allocate(data);\n\n        //special case: no items in the list yet\n        if (this._length === 0) {\n            this._head = node;\n            this._tail = node;\n        } else {\n            //attach to the tail node\n            this._tail.next = node;\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        //don't forget to update the count\n        this._length++;\n\n    },\n\n\n    set: function(index, data) {\n        // update data at index\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            current.data = data;\n        }\n    },\n\n\n    /**\n     * Retrieves the data in the given position in the list.\n     * @param {int} index The zero-based index of the item whose value\n     *      should be returned.\n     * @return {variant} The value in the \"data\" portion of the given item\n     *      or null if the item doesn't exist.\n     * @method item\n     */\n    item: function(index){\n\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n            var current, i;\n            if (index > this._length / 2) {\n                current = this._tail;\n                i = this._length - 1;\n                while(i-- > index) {\n                    current = current.prev;\n                }\n            } else {\n                current = this._head;\n                i = 0;\n                while(i++ < index){\n                    current = current.next;\n                }\n            }\n            return current.data;\n        } else {\n            return null;\n        }\n    },\n\n    pop: function() {\n        return this.remove(this._length -1);\n    },\n\n    /**\n     * Removes the item from the given location in the list.\n     * @param {int} index The zero-based index of the item to remove.\n     * @return {variant} The data in the given position in the list or null if\n     *      the item doesn't exist.\n     * @method remove\n     */\n    remove: function(index){\n        //check for out-of-bounds values\n        if (index > -1 && index < this._length){\n\n            var current = this._head,\n                i = 0;\n\n            //special case: removing first item\n            if (index === 0){\n                this._head = current.next;\n\n                /*\n                 * If there's only one item in the list and you remove it,\n                 * then this._head will be null. In that case, you should\n                 * also set this._tail to be null to effectively destroy\n                 * the list. Otherwise, set the previous pointer on the new\n                 * this._head to be null.\n                 */\n                if (!this._head){\n                    this._tail = null;\n                } else {\n                    this._head.prev = null;\n                }\n\n            //special case: removing last item\n            } else if (index === this._length -1){\n                current = this._tail;\n                this._tail = current.prev;\n                this._tail.next = null;\n            } else {\n\n                //find the right location\n                while(i++ < index){\n                    current = current.next;\n                }\n\n                //skip over the item to remove\n                current.prev.next = current.next;\n            }\n\n            //decrement the length\n            this._length--;\n\n            // release into object pool\n            this._free(current);\n\n            //return the value\n            return current.data;\n\n        } else {\n            return null;\n        }\n    },\n\n    clear: function() {\n        while (this._length > 0) {\n            this.remove(0);\n        }\n    },\n\n   /**\n     * Returns the number of items in the list.\n     * @return {int} The number of items in the list.\n     * @method size\n     */\n    size: function(){\n        return this._length;\n    },\n\n    /**\n     * Converts the list into an array.\n     * @return {Array} An array containing all of the data in the list.\n     * @method toArray\n     */\n    toArray: function(){\n        var result = [],\n            current = this._head;\n\n        while(current){\n            result.push(current.data);\n            current = current.next;\n        }\n\n        return result;\n    },\n\n    /**\n     * Converts the list into a string representation.\n     * @return {String} A string representation of the list.\n     * @method toString\n     */\n    toString: function(){\n        return this.toArray().toString();\n    },\n\n    _free: function(node) {\n        this._nodeCache.push(node);\n    },\n\n    _allocate: function(data) {\n        var node = this._nodeCache.pop();\n        if (!node) {\n            node = {};\n        }\n        node.data = data;\n        node.prev = null;\n        node.next = null;\n        return node;\n    }\n};\n\nexports = module.exports = DoublyLinkedList;\n","module.exports = {\n  DoublyLinkedList: require('./doublylinkedlist')\n};\n","'use strict';\n\n/* jshint -W064 */\nvar RegularPolygon2 = require('../geometry/regularpolygon2');\nvar Polygon2 = require('../geometry/polygon2');\nvar Vector2 = require('../geometry/vector2');\nvar LineSegment2 = require('../geometry/linesegment2');\nvar gpc = require('../geometry/gpc');\nvar Delaunay = require('delaunay-fast');\nvar Graph = require('./graph');\n\nexports = module.exports = Building;\n\nvar createPoly = function(points) {\n\tvar res  = new gpc.geometry.PolyDefault();\n\tfor(var i=0 ; i < points.length ; i++) {\n\t\tres.addPoint(new gpc.geometry.Point(points[i][0],points[i][1]));\n\t}\n\treturn res;\n};\n\nvar getPolygonVertices = function(poly) {\n\tvar vertices=[];\n\tvar numPoints = poly.getNumPoints();\n\tvar i;\n\n\tfor(i=0;i<numPoints;i++) {\n\t\tvertices.push([poly.getX(i) , poly.getY(i)]);\n\t}\n\treturn vertices;\n};\n\nfunction Building( chance, iterations, minRadius, maxRadius, maxSides, noRotate)\n{\n\tvar end, l;\n\tthis.centers = [];\n\titerations = iterations || 1;\n//\tif ( iterations < 3 ) {\n//\t\titerations = 3;\n//\t}\n\tmaxSides = maxSides || 6;\n\tif ( maxSides < 4 ) {\n\t\tmaxSides = 4;\n\t}\n\tvar sidesChanceObj = { min: 4, max: maxSides };\n\tvar radiusChanceObj = { min: minRadius, max: maxRadius };\n\n\tvar sides = chance.integer(sidesChanceObj);\n\tvar polygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\tvar gpcPoly = createPoly(polygon.toArray());\n\tpolygon.free();\n\tvar vec, gpcPoly2, num;\n\tthis.centers.push(Vector2());\n\n\tfor (var i = 1; i < iterations;i++) {\n\t\t// new random polygon\n\t\tsides = chance.integer(sidesChanceObj);\n\t\tpolygon = RegularPolygon2(chance.floating(radiusChanceObj), sides);\n\n\t\t// rotate random\n\t\tif (!noRotate) {\n\t\t\tpolygon.rotate(chance.floating({min: 0, max: 2 * Math.PI / sides}));\n\t\t}\n\n\t\t// random point on prev poly\n\t\tnum = chance.integer({min: 0, max:gpcPoly.getNumPoints()-1});\n\t\tvec = Vector2(gpcPoly.getX(num), gpcPoly.getY(num));\n\t\tthis.centers.push(vec);\n\n\t\t// center the polygon on a random point of the previous polygon\n\t\tpolygon.translate(vec);\n\t\tgpcPoly2 = createPoly(polygon.toArray());\n\t\tgpcPoly = gpcPoly.union(gpcPoly2);\n\n\t\t// free our stuff for reuse\n\t\tpolygon.free();\n\t}\n\tvar arr = getPolygonVertices(gpcPoly);\n\n\t// generate final polygon\n\tpolygon = Polygon2.fromArray(arr);\n\tthis.polygon = polygon;\n\n\t// this.polygon.clean(30);\n\n\t// add outer doors\n\tvar nrdoors = Math.ceil(iterations/2);\n\tthis.doors = [];\n\n\tvar nr;\n\tvar dooredges = {};\n\tfor ( i=0;i<nrdoors;i++) {\n\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\twhile (dooredges[nr]) {\n\t\t\tnr = chance.integer({min: 0, max: this.polygon.points.length -1});\n\t\t}\n\t\tdooredges[nr] = true;\n\t\tend = nr + 1;\n\t\tif (end === this.polygon.points.length) {\n\t\t\tend = 0;\n\t\t}\n\t\tl = LineSegment2(this.polygon.points[nr].clone(), this.polygon.points[end].clone());\n\t\tvar p2 = l.end.clone();\n\t\tvar p1 = l.start.clone();\n\t\tvar length = l.length(); // p2.subtract(l.start).length();\n\t\tp2.subtract(l.start).normalize().multiplyScalar(length/2);\n\t\tp1.add(p2);\n\t\t// this.centers.push(p1);\n\t\tthis.doors.push(p1);\n\t\tp2.free();\n\t\tl.free();\n\t}\n\n\n\n\tvar c = [];\n\tfor (i = 0; i < this.centers.length; i++) {\n\t\tc.push(this.centers[i].toArray());\n\t}\n\n\tthis.graph = new Graph();\n\tthis.delaunay_used = {};\n\n\t// delaunay the centers\n\tthis.delaunay = Delaunay.triangulate(c);\n\n\tfor (i = 0; i < this.delaunay.length; i += 1) {\n\t\tif (!this.delaunay_used[this.delaunay[i]]) {\n\t\t\tthis.graph.addNode(this.delaunay[i]);\n\t\t\tthis.delaunay_used[this.delaunay[i]] = true;\n\t\t}\n\t}\n\n\n\tthis.delaunay_exists = {};\n\n\tthis.delaunay_triangles = [];\n\tthis.delaunay_lines = [];\n\tfor (i = 0; i < this.delaunay.length; i += 3) {\n\t\t// line 1\n\t\tthis.addDelaunayLine(i, i+1);\n\t\tthis.addDelaunayLine(i+1, i+2);\n\t\tthis.addDelaunayLine(i+2, i);\n\t}\n\n\t// connect the doors;\n\tnr = this.centers.length;\n\tfor (i = 0; i < this.doors.length; i++) {\n\t\tthis.connectDoor(this.doors[i], nr);\n\t}\n\n\n\n\t// calculate the minimal spanning tree\n\tvar edges = this.graph.prim(); // Prim(this.graph);\n\t// console.log(edges);\n\tthis.mst_lines = [];\n\n\tfor (i = 0; i < edges.length; i ++) {\n\t\tvar start = edges[i].source;\n\t\tend = edges[i].sink;\n\t\tl = LineSegment2(this.centers[start].clone(), this.centers[end].clone());\n\t\tthis.mst_lines.push(l);\n\t\t//var l = LineSegment2()\n\t}\n\n\n\tthis.outside = this.polygon.AABB();\n\n\tthis.outside[0].subtractScalar(50);\n\tthis.outside[1].addScalar(50);\n\n}\n\nBuilding.prototype.connectDoor = function(door, nr)\n{\n\tvar min = 9999999;\n\tvar l,d;\n\tvar point = false;\n\tfor (var i= 0;i<nr;i++) {\n\t\tl = LineSegment2(this.centers[i].clone(), door.clone());\n\t\tif (!this.polygon.intersectsLine(l, true)) {\n\t\t\td = l.length();\n\t\t\tif ( d < min ) {\n\t\t\t\tmin = d;\n\t\t\t\tpoint = i;\n\t\t\t}\n\t\t}\n\t\tl.free();\n\t}\n\tif (point !== false) {\n\t\tthis.centers.push(door.clone());\n\t\tthis.graph.addNode(this.centers.length - 1);\n\t\tthis.graph.addEdge(point, this.centers.length - 1, min);\n\t\tthis.delaunay_lines.push(LineSegment2(this.centers[point].clone(), door.clone()));\n\t} else {\n\t\tl.free();\n\t}\n\n};\n\nBuilding.prototype.addDelaunayLine = function(start, end)\n{\n\tvar key1 = start + ':' + end;\n\tvar key2 = end + ':' + start;\n\tif (this.delaunay_exists[key1] || this.delaunay_exists[key2]) {\n\t\treturn;\n\t}\n\tthis.delaunay_exists[key1] = true;\n\tthis.delaunay_exists[key2] = true;\n\tvar l = LineSegment2(this.centers[this.delaunay[start]].clone(), this.centers[this.delaunay[end]].clone());\n\tif (this.polygon.intersectsLine(l)) {\n\t\tl.free();\n\t} else {\n\t\tthis.graph.addEdge(this.delaunay[start], this.delaunay[end], l.length());\n\t\tthis.delaunay_lines.push(l);\n\t}\n};\n\n\nBuilding.prototype.translate = function (vec)\n{\n\tthis.polygon.translate(vec);\n\tfor (var i=0;i<this.centers.length;i++) {\n\t\tthis.centers[i].add(vec);\n\t}\n\tfor (i =0;i<this.delaunay_triangles.length;i++) {\n\t\tthis.delaunay_triangles[i].translate(vec);\n\t}\n\treturn this;\n};\n\n\n/* jshint +W064 */\n","'use strict';\n\n\n\n// Represents an edge from source to sink with capacity\nvar Edge = function(source, sink, capacity) {\n    this.source = source;\n    this.sink = sink;\n    this.capacity = capacity;\n};\n\n// Main class to manage the network\nvar Graph = function() {\n    this.edges = {};\n    this.nodes = [];\n    this.nodeMap = {};\n\n    // Add a node to the graph\n    this.addNode = function(node) {\n        this.nodes.push(node);\n        this.nodeMap[node] = this.nodes.length-1;\n        this.edges[node] = [];\n    };\n\n    // Add an edge from source to sink with capacity\n    this.addEdge = function(source, sink, capacity) {\n        // Create the two edges = one being the reverse of the other\n        this.edges[source].push(new Edge(source, sink, capacity));\n        this.edges[sink].push(new Edge(sink, source, capacity));\n    };\n\n    // Does edge from source to sink exist?\n    this.edgeExists = function(source, sink) {\n        if(this.edges[source] !== undefined) {\n            for(var i=0;i<this.edges[source].length;i++) {\n                if(this.edges[source][i].sink === sink) {\n                    return this.edges[source][i];\n                }\n            }\n        }\n        return null;\n    };\n\n\n    this.prim = function() {\n        var result = [];\n        var resultEdges = [];\n        var usedNodes = {};\n\n        function findMin(g) {\n            var min = [999999,null];\n            for(var i=0;i<result.length;i++) {\n                for(var n=0;n<g.edges[result[i]].length;n++) {\n                    if(g.edges[result[i]][n].capacity < min[0] && usedNodes[g.edges[result[i]][n].sink] === undefined) {\n                        min = [g.edges[result[i]][n].capacity, g.edges[result[i]][n]];\n                    }\n                }\n            }\n            return min;\n        }\n\n        // Pick random start point\n        var node = this.nodes[Math.round(Math.random()*(this.nodes.length-1))];\n        result.push(node);\n        usedNodes[node] = true;\n\n        var min = findMin(this);\n        while(min[1] !== null) {\n            resultEdges.push(min[1]);\n            result.push(min[1].sink);\n            usedNodes[min[1].sink] = true;\n            min = findMin(this);\n        }\n\n        return resultEdges;\n    };\n\n};\n\nmodule.exports = Graph;\n","module.exports = {\n  Graph: require('./graph'),\n  Building: require('./building')\n};\n","'use strict';\n\nvar requestFrame = require('request-frame');\nvar request = requestFrame('request');\nvar cancel = requestFrame('cancel');\n\nvar NOOP = function(){};\n\nexports = module.exports = GameLoop;\n\nfunction GameLoop () {\n  this.simulationTimestep = 1000 / 60;\n  this.frameDelta = 0;\n  this.lastFrameTimeMs = 0;\n  this.fps = 60;\n  this.lastFpsUpdate = 0;\n  this.framesThisSecond = 0;\n  this.numUpdateSteps = 0;\n  this.minFrameDelay = 0;\n  this.running = false;\n  this.started = false;\n  this.panic = false;\n  this.rafHandle = false;\n  this.boundAnimate = this.animate.bind(this);\n}\n\nGameLoop.prototype.begin = NOOP;\nGameLoop.prototype.update = NOOP;\nGameLoop.prototype.render = NOOP;\nGameLoop.prototype.end = NOOP;\n\nGameLoop.prototype.getSimulationTimestep = function() {\n  return this.simulationTimestep;\n};\n\nGameLoop.prototype.setSimulationTimestep = function(timestep) {\n  this.simulationTimestep = timestep;\n  return this;\n};\n\nGameLoop.prototype.getFPS = function () {\n  return this.fps;\n};\n\nGameLoop.prototype.getMaxAllowedFPS = function() {\n  return 1000 / this.minFrameDelay;\n};\n\nGameLoop.prototype.setMaxAllowedFPS =  function(fps) {\n  if (typeof fps === 'undefined') {\n    fps = Infinity;\n  }\n  if (fps === 0) {\n    this.stop();\n  }\n  else {\n    // Dividing by Infinity returns zero.\n    this.minFrameDelay = 1000 / fps;\n  }\n  return this;\n};\n\nGameLoop.prototype.resetFrameDelta = function() {\n  var oldFrameDelta = this.frameDelta;\n  this.frameDelta = 0;\n  return oldFrameDelta;\n};\n\nGameLoop.prototype.setBegin = function(fun) {\n  this.begin = fun || this.begin;\n  return this;\n};\n\nGameLoop.prototype.setUpdate = function(fun) {\n  this.update = fun || this.update;\n  return this;\n};\n\nGameLoop.prototype.setRender = function(fun) {\n  this.render = fun || this.render;\n  return this;\n};\n\nGameLoop.prototype.setEnd = function(fun) {\n  this.end = fun || this.end;\n  return this;\n};\n\nGameLoop.prototype.start = function() {\n  if (!this.started) {\n    this.started = true;\n    this.rafHandle = request(function(timestamp) {\n      this.render(1);\n      this.running = true;\n      this.lastFrameTimeMs = timestamp;\n      this.lastFpsUpdate = timestamp;\n      this.framesThisSecond = 0;\n      this.rafHandle = request(this.animate.bind(this));\n    });\n  }\n  return this;\n};\n\nGameLoop.prototype.stop = function() {\n  this.running = false;\n  this.started = false;\n  cancel(this.rafHandle);\n  return this;\n};\n\nGameLoop.prototype.isRunning = function() {\n  return this.running;\n};\n\nGameLoop.prototype.animate = function animate(timestamp) {\n\n    if (timestamp < this.lastFrameTimeMs + this.minFrameDelay) {\n        this.rafHandle = request(this.boundAnimate);\n        return;\n    }\n\n    this.frameDelta += timestamp - this.lastFrameTimeMs;\n    this.lastFrameTimeMs = timestamp;\n\n    this.begin(timestamp, this.frameDelta);\n\n    if (timestamp > this.lastFpsUpdate + 1000) {\n        this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;\n        this.lastFpsUpdate = timestamp;\n        this.framesThisSecond = 0;\n    }\n    this.framesThisSecond++;\n\n     /* - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    this.numUpdateSteps = 0;\n    while (this.frameDelta >= this.simulationTimestep) {\n        this.update(this.simulationTimestep);\n        this.frameDelta -= this.simulationTimestep;\n\n        if (++this.numUpdateSteps >= 240) {\n            this.panic = true;\n            break;\n        }\n    }\n\n    this.render(this.frameDelta / this.simulationTimestep);\n\n    this.end(this.fps, this.panic);\n\n    this.panic = false;\n\n    this.rafHandle = request(this.boundAnimate);\n};\n","module.exports = {\n  GameLoop: require('./gameloop')\n};\n"],"sourceRoot":"./"}